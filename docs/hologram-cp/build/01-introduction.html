<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction - The Hologram Container Engine and Platform</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation of the Hologram Container Engine and Platform conceptual model">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hologram Container Engine and Platform</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/yourusername/Hologram" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="the-hologram-container-engine-and-platform"><a class="header" href="#the-hologram-container-engine-and-platform">The Hologram Container Engine and Platform</a></h2>
<p>Hologram is a universal container engine and platform built on a fundamental insight: <strong>all information can be contained through projection rather than classification</strong>.</p>
<p>Traditional systems organize information through type hierarchies, schemas, and rigid classifications imposed at write time. Hologram inverts this model. Resources exist without inherent type or structure in a universal store, identified only by their content. Meaning, structure, and purpose emerge through <strong>projections</strong>—queries that identify, aggregate, and transform resources into containers.</p>
<p>This document introduces the core concepts, architecture, and operating principles of the Hologram Container Engine and Platform.</p>
<h2 id="what-hologram-is"><a class="header" href="#what-hologram-is">What Hologram Is</a></h2>
<p>Hologram is:</p>
<ul>
<li>
<p><strong>A universal resource store</strong> using content-addressed storage where resources exist as immutable, undifferentiated data identified by cryptographic hash of their content</p>
</li>
<li>
<p><strong>A projection engine</strong> that executes projection definitions to identify, aggregate, and transform resources into containers with meaning and purpose</p>
</li>
<li>
<p><strong>A container platform</strong> providing base container types (components, instances, interfaces, documentation, tests, managers, views) that are themselves defined through projections</p>
</li>
<li>
<p><strong>A self-describing system</strong> where the platform’s own definition exists as projections in the store, enabling evolution without external dependencies</p>
</li>
</ul>
<h2 id="core-innovation-containment-through-projection"><a class="header" href="#core-innovation-containment-through-projection">Core Innovation: Containment Through Projection</a></h2>
<p>The central innovation is the <strong>projection-emission cycle</strong>:</p>
<ol>
<li><strong>Projection</strong> identifies and aggregates resources from the store based on queries</li>
<li><strong>Execution</strong> operates on projected resources, producing results</li>
<li><strong>Emission</strong> writes new resources back to the store as immutable, content-addressed data</li>
<li><strong>Storage</strong> persists emitted resources, making them available for future projections</li>
</ol>
<p>This cycle applies uniformly across the platform:</p>
<ul>
<li>Creating a component definition projects artifacts and emits component resources</li>
<li>Running an instance projects a component definition and emits logs, state, and application data</li>
<li>Materializing a view projects resources and emits a persistent representation</li>
<li>Every operation is a projection that emits</li>
</ul>
<p>The cycle creates a <strong>self-evolving system</strong> where emitted resources become inputs to future projections, enabling continuous refinement and extension without modifying the engine or platform core.</p>
<h2 id="key-principles"><a class="header" href="#key-principles">Key Principles</a></h2>
<h3 id="1-resources-have-no-inherent-type"><a class="header" href="#1-resources-have-no-inherent-type">1. Resources Have No Inherent Type</a></h3>
<p>Resources in the store are undifferentiated data. A JSON document, a binary blob, a text file—all exist as content with a cryptographic identifier. Type, structure, and meaning emerge through projection, not classification.</p>
<h3 id="2-content-addressing-provides-identity"><a class="header" href="#2-content-addressing-provides-identity">2. Content Addressing Provides Identity</a></h3>
<p>Resources are identified by the cryptographic hash of their content (Content Identifier, or CID). Identical content always produces the same CID. This provides:</p>
<ul>
<li><strong>Deduplication</strong> - identical content stored once</li>
<li><strong>Integrity</strong> - content cannot change without changing CID</li>
<li><strong>Immutability</strong> - resources are write-once, enabling reliable referencing</li>
<li><strong>Distribution</strong> - content can move between stores while maintaining identity</li>
</ul>
<h3 id="3-projections-create-containers"><a class="header" href="#3-projections-create-containers">3. Projections Create Containers</a></h3>
<p>A <strong>projection</strong> is a query-based definition that identifies resources matching certain criteria, aggregates them according to relationship rules, and transforms them into a container. The same resources can participate in multiple projections, appearing in different containers with different purposes.</p>
<h3 id="4-emissions-produce-new-resources"><a class="header" href="#4-emissions-produce-new-resources">4. Emissions Produce New Resources</a></h3>
<p>Executing a projection produces results—these results are <strong>emitted</strong> as new resources to the store. Emissions are themselves projectable, creating feedback loops where operations build on previous results.</p>
<h3 id="5-the-platform-is-self-describing"><a class="header" href="#5-the-platform-is-self-describing">5. The Platform Is Self-Describing</a></h3>
<p>The projection engine, container types, and platform operations are all defined as projections in the store. The system contains its own definition, enabling introspection, evolution, and extension through the same mechanisms used for application containers.</p>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>The platform consists of three fundamental layers:</p>
<h3 id="the-container-store"><a class="header" href="#the-container-store">The Container Store</a></h3>
<p>A content-addressed storage system providing four core capabilities:</p>
<ul>
<li><strong>Store</strong>: Write immutable resources identified by content hash</li>
<li><strong>Retrieve</strong>: Read resources by CID</li>
<li><strong>Reference</strong>: Link resources through CID references</li>
<li><strong>Query</strong>: Identify resources matching projection criteria</li>
</ul>
<p>The store is implementation-independent—filesystem, database, distributed storage, or cloud object storage can provide the backend.</p>
<h3 id="the-projection-engine"><a class="header" href="#the-projection-engine">The Projection Engine</a></h3>
<p>Executes projection definitions to create containers:</p>
<ul>
<li>Evaluates queries to identify resources in the store</li>
<li>Follows references to aggregate related resources</li>
<li>Applies transformations to produce container contents</li>
<li>Delivers projected containers to requesters</li>
</ul>
<p>The engine interprets projection definitions (themselves resources in the store) and orchestrates the projection-emission cycle.</p>
<h3 id="the-container-platform"><a class="header" href="#the-container-platform">The Container Platform</a></h3>
<p>Provides base container types and operations:</p>
<ul>
<li><strong>Component containers</strong> define reusable capabilities</li>
<li><strong>Instance containers</strong> execute component definitions</li>
<li><strong>Interface containers</strong> specify contracts between components</li>
<li><strong>Documentation containers</strong> provide human-readable views</li>
<li><strong>Test containers</strong> validate behavior</li>
<li><strong>Manager containers</strong> control lifecycle operations</li>
<li><strong>View containers</strong> materialize persistent projections</li>
</ul>
<p>All platform container types are defined through projections, making them extensible and evolvable.</p>
<h2 id="the-projection-emission-cycle"><a class="header" href="#the-projection-emission-cycle">The Projection-Emission Cycle</a></h2>
<p>The fundamental operating principle is the continuous cycle:</p>
<p><strong>Project → Execute → Emit → Store → Project…</strong></p>
<p>Every interaction with Hologram follows this cycle:</p>
<ul>
<li>A client submits a projection request</li>
<li>The engine identifies and aggregates resources</li>
<li>Execution produces results</li>
<li>Results are emitted as new resources to the store</li>
<li>Emitted resources become available for projection</li>
</ul>
<p>This creates a <strong>generative system</strong> where operations compound—each emission adds to the store, enabling more sophisticated projections that produce richer emissions.</p>
<h2 id="what-hologram-enables"><a class="header" href="#what-hologram-enables">What Hologram Enables</a></h2>
<p>The projection model provides unique capabilities:</p>
<p><strong>Flexible Organization</strong>: Resources can participate in multiple containers simultaneously. A documentation resource might appear in a component container, a searchable documentation view, and a tutorial container—without duplication or synchronization.</p>
<p><strong>Immutable History</strong>: All resources are immutable. Changes create new resources with new CIDs. The complete history exists in the store, enabling time-travel queries and audit trails.</p>
<p><strong>Composable Projections</strong>: Projections can project other projections. A view might project components, which themselves project interfaces, documentation, and tests. Composition creates powerful abstractions without runtime overhead.</p>
<p><strong>Self-Evolution</strong>: The platform definition exists as projections. Improving Hologram means emitting new projection definitions to the store. The system evolves through the same mechanisms used for applications.</p>
<p><strong>Implementation Independence</strong>: The projection model is abstract—the engine, store backend, and platform operations can be implemented in any language, on any infrastructure. Portability is inherent.</p>
<h2 id="reading-guide"><a class="header" href="#reading-guide">Reading Guide</a></h2>
<p>This documentation is organized into four parts, each building on the previous:</p>
<p><strong>Part I: Foundation</strong> (Documents 1-4)
Establishes first principles: the container store, projection-emission cycle, and how resources become containers through projection.</p>
<p><strong>Part II: The Engine</strong> (Documents 5-7)
Details how the projection engine executes projections, the projection language for defining projections, and how emissions work.</p>
<p><strong>Part III: The Platform</strong> (Documents 8-11)
Describes platform container types, views, operations, and the client API for interacting with the platform.</p>
<p><strong>Part IV: System Architecture</strong> (Documents 12-15)
Covers bootstrap architecture, system properties, implementation considerations, and terminology.</p>
<p>Each document builds on concepts from previous documents. Reading sequentially provides the clearest understanding, though individual documents can serve as reference material.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>The next document, <strong>The Container Store</strong>, establishes the foundation by describing how content-addressed storage provides the universal resource container underlying all projections.</p>
<p>From that foundation, we build up the projection-emission cycle, the projection engine, and the container platform—all based on the simple primitive of immutable, content-addressed resources.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next prefetch" href="02-container-store.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next prefetch" href="02-container-store.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
