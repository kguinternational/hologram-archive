<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Hologram Container Engine and Platform</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation of the Hologram Container Engine and Platform conceptual model">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hologram Container Engine and Platform</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/yourusername/Hologram" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="the-hologram-container-engine-and-platform"><a class="header" href="#the-hologram-container-engine-and-platform">The Hologram Container Engine and Platform</a></h2>
<p>Hologram is a universal container engine and platform built on a fundamental insight: <strong>all information can be contained through projection rather than classification</strong>.</p>
<p>Traditional systems organize information through type hierarchies, schemas, and rigid classifications imposed at write time. Hologram inverts this model. Resources exist without inherent type or structure in a universal store, identified only by their content. Meaning, structure, and purpose emerge through <strong>projections</strong>—queries that identify, aggregate, and transform resources into containers.</p>
<p>This document introduces the core concepts, architecture, and operating principles of the Hologram Container Engine and Platform.</p>
<h2 id="what-hologram-is"><a class="header" href="#what-hologram-is">What Hologram Is</a></h2>
<p>Hologram is:</p>
<ul>
<li>
<p><strong>A universal resource store</strong> using content-addressed storage where resources exist as immutable, undifferentiated data identified by cryptographic hash of their content</p>
</li>
<li>
<p><strong>A projection engine</strong> that executes projection definitions to identify, aggregate, and transform resources into containers with meaning and purpose</p>
</li>
<li>
<p><strong>A container platform</strong> providing base container types (components, instances, interfaces, documentation, tests, managers, views) that are themselves defined through projections</p>
</li>
<li>
<p><strong>A self-describing system</strong> where the platform’s own definition exists as projections in the store, enabling evolution without external dependencies</p>
</li>
</ul>
<h2 id="core-innovation-containment-through-projection"><a class="header" href="#core-innovation-containment-through-projection">Core Innovation: Containment Through Projection</a></h2>
<p>The central innovation is the <strong>projection-emission cycle</strong>:</p>
<ol>
<li><strong>Projection</strong> identifies and aggregates resources from the store based on queries</li>
<li><strong>Execution</strong> operates on projected resources, producing results</li>
<li><strong>Emission</strong> writes new resources back to the store as immutable, content-addressed data</li>
<li><strong>Storage</strong> persists emitted resources, making them available for future projections</li>
</ol>
<p>This cycle applies uniformly across the platform:</p>
<ul>
<li>Creating a component definition projects artifacts and emits component resources</li>
<li>Running an instance projects a component definition and emits logs, state, and application data</li>
<li>Materializing a view projects resources and emits a persistent representation</li>
<li>Every operation is a projection that emits</li>
</ul>
<p>The cycle creates a <strong>self-evolving system</strong> where emitted resources become inputs to future projections, enabling continuous refinement and extension without modifying the engine or platform core.</p>
<h2 id="key-principles"><a class="header" href="#key-principles">Key Principles</a></h2>
<h3 id="1-resources-have-no-inherent-type"><a class="header" href="#1-resources-have-no-inherent-type">1. Resources Have No Inherent Type</a></h3>
<p>Resources in the store are undifferentiated data. A JSON document, a binary blob, a text file—all exist as content with a cryptographic identifier. Type, structure, and meaning emerge through projection, not classification.</p>
<h3 id="2-content-addressing-provides-identity"><a class="header" href="#2-content-addressing-provides-identity">2. Content Addressing Provides Identity</a></h3>
<p>Resources are identified by the cryptographic hash of their content (Content Identifier, or CID). Identical content always produces the same CID. This provides:</p>
<ul>
<li><strong>Deduplication</strong> - identical content stored once</li>
<li><strong>Integrity</strong> - content cannot change without changing CID</li>
<li><strong>Immutability</strong> - resources are write-once, enabling reliable referencing</li>
<li><strong>Distribution</strong> - content can move between stores while maintaining identity</li>
</ul>
<h3 id="3-projections-create-containers"><a class="header" href="#3-projections-create-containers">3. Projections Create Containers</a></h3>
<p>A <strong>projection</strong> is a query-based definition that identifies resources matching certain criteria, aggregates them according to relationship rules, and transforms them into a container. The same resources can participate in multiple projections, appearing in different containers with different purposes.</p>
<h3 id="4-emissions-produce-new-resources"><a class="header" href="#4-emissions-produce-new-resources">4. Emissions Produce New Resources</a></h3>
<p>Executing a projection produces results—these results are <strong>emitted</strong> as new resources to the store. Emissions are themselves projectable, creating feedback loops where operations build on previous results.</p>
<h3 id="5-the-platform-is-self-describing"><a class="header" href="#5-the-platform-is-self-describing">5. The Platform Is Self-Describing</a></h3>
<p>The projection engine, container types, and platform operations are all defined as projections in the store. The system contains its own definition, enabling introspection, evolution, and extension through the same mechanisms used for application containers.</p>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>The platform consists of three fundamental layers:</p>
<h3 id="the-container-store"><a class="header" href="#the-container-store">The Container Store</a></h3>
<p>A content-addressed storage system providing four core capabilities:</p>
<ul>
<li><strong>Store</strong>: Write immutable resources identified by content hash</li>
<li><strong>Retrieve</strong>: Read resources by CID</li>
<li><strong>Reference</strong>: Link resources through CID references</li>
<li><strong>Query</strong>: Identify resources matching projection criteria</li>
</ul>
<p>The store is implementation-independent—filesystem, database, distributed storage, or cloud object storage can provide the backend.</p>
<h3 id="the-projection-engine"><a class="header" href="#the-projection-engine">The Projection Engine</a></h3>
<p>Executes projection definitions to create containers:</p>
<ul>
<li>Evaluates queries to identify resources in the store</li>
<li>Follows references to aggregate related resources</li>
<li>Applies transformations to produce container contents</li>
<li>Delivers projected containers to requesters</li>
</ul>
<p>The engine interprets projection definitions (themselves resources in the store) and orchestrates the projection-emission cycle.</p>
<h3 id="the-container-platform"><a class="header" href="#the-container-platform">The Container Platform</a></h3>
<p>Provides base container types and operations:</p>
<ul>
<li><strong>Component containers</strong> define reusable capabilities</li>
<li><strong>Instance containers</strong> execute component definitions</li>
<li><strong>Interface containers</strong> specify contracts between components</li>
<li><strong>Documentation containers</strong> provide human-readable views</li>
<li><strong>Test containers</strong> validate behavior</li>
<li><strong>Manager containers</strong> control lifecycle operations</li>
<li><strong>View containers</strong> materialize persistent projections</li>
</ul>
<p>All platform container types are defined through projections, making them extensible and evolvable.</p>
<h2 id="the-projection-emission-cycle"><a class="header" href="#the-projection-emission-cycle">The Projection-Emission Cycle</a></h2>
<p>The fundamental operating principle is the continuous cycle:</p>
<p><strong>Project → Execute → Emit → Store → Project…</strong></p>
<p>Every interaction with Hologram follows this cycle:</p>
<ul>
<li>A client submits a projection request</li>
<li>The engine identifies and aggregates resources</li>
<li>Execution produces results</li>
<li>Results are emitted as new resources to the store</li>
<li>Emitted resources become available for projection</li>
</ul>
<p>This creates a <strong>generative system</strong> where operations compound—each emission adds to the store, enabling more sophisticated projections that produce richer emissions.</p>
<h2 id="what-hologram-enables"><a class="header" href="#what-hologram-enables">What Hologram Enables</a></h2>
<p>The projection model provides unique capabilities:</p>
<p><strong>Flexible Organization</strong>: Resources can participate in multiple containers simultaneously. A documentation resource might appear in a component container, a searchable documentation view, and a tutorial container—without duplication or synchronization.</p>
<p><strong>Immutable History</strong>: All resources are immutable. Changes create new resources with new CIDs. The complete history exists in the store, enabling time-travel queries and audit trails.</p>
<p><strong>Composable Projections</strong>: Projections can project other projections. A view might project components, which themselves project interfaces, documentation, and tests. Composition creates powerful abstractions without runtime overhead.</p>
<p><strong>Self-Evolution</strong>: The platform definition exists as projections. Improving Hologram means emitting new projection definitions to the store. The system evolves through the same mechanisms used for applications.</p>
<p><strong>Implementation Independence</strong>: The projection model is abstract—the engine, store backend, and platform operations can be implemented in any language, on any infrastructure. Portability is inherent.</p>
<h2 id="reading-guide"><a class="header" href="#reading-guide">Reading Guide</a></h2>
<p>This documentation is organized into four parts, each building on the previous:</p>
<p><strong>Part I: Foundation</strong> (Documents 1-4)
Establishes first principles: the container store, projection-emission cycle, and how resources become containers through projection.</p>
<p><strong>Part II: The Engine</strong> (Documents 5-7)
Details how the projection engine executes projections, the projection language for defining projections, and how emissions work.</p>
<p><strong>Part III: The Platform</strong> (Documents 8-11)
Describes platform container types, views, operations, and the client API for interacting with the platform.</p>
<p><strong>Part IV: System Architecture</strong> (Documents 12-15)
Covers bootstrap architecture, system properties, implementation considerations, and terminology.</p>
<p>Each document builds on concepts from previous documents. Reading sequentially provides the clearest understanding, though individual documents can serve as reference material.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>The next document, <strong>The Container Store</strong>, establishes the foundation by describing how content-addressed storage provides the universal resource container underlying all projections.</p>
<p>From that foundation, we build up the projection-emission cycle, the projection engine, and the container platform—all based on the simple primitive of immutable, content-addressed resources.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-container-store-1"><a class="header" href="#the-container-store-1">The Container Store</a></h1>
<h2 id="universal-resource-storage"><a class="header" href="#universal-resource-storage">Universal Resource Storage</a></h2>
<p>The container store is the foundation of the Hologram platform. It is a universal storage system where all resources exist as immutable, content-addressed data without inherent type or structure.</p>
<p>This document establishes the principles, capabilities, and properties of the container store from first principles.</p>
<h2 id="first-principles"><a class="header" href="#first-principles">First Principles</a></h2>
<h3 id="resources-as-undifferentiated-data"><a class="header" href="#resources-as-undifferentiated-data">Resources as Undifferentiated Data</a></h3>
<p>A <strong>resource</strong> is any sequence of bytes stored in the container store. Resources have no inherent type, schema, or semantic meaning. A JSON document, a binary executable, an image file, a text log—all exist as resources without distinction.</p>
<p>The store does not interpret, validate, or classify resources at write time. It stores bytes and provides mechanisms for retrieval and reference. Meaning emerges later through projection, not at storage time.</p>
<p>This principle enables universal applicability—any data can be stored, and any interpretation can be applied through projections.</p>
<h3 id="content-addressed-identity"><a class="header" href="#content-addressed-identity">Content-Addressed Identity</a></h3>
<p>Every resource is identified by a <strong>Content Identifier (CID)</strong>, a cryptographic hash computed from the resource’s complete content.</p>
<p>The CID function has these properties:</p>
<ul>
<li><strong>Deterministic</strong>: The same content always produces the same CID</li>
<li><strong>Unique</strong>: Different content produces different CIDs (with cryptographic collision resistance)</li>
<li><strong>Opaque</strong>: The CID reveals nothing about content structure or meaning</li>
<li><strong>Immutable</strong>: Content cannot change without changing the CID</li>
</ul>
<p>CIDs provide <strong>intrinsic identity</strong>—identity derived from content itself rather than assigned externally. This makes resources self-verifying: retrieving a resource by CID guarantees you receive exactly the content that produced that CID.</p>
<h3 id="immutability"><a class="header" href="#immutability">Immutability</a></h3>
<p>Resources are <strong>write-once</strong>. Once stored, a resource’s content never changes. The CID permanently identifies that specific content.</p>
<p>If content needs to change, a new resource with new content is written, producing a new CID. The original resource remains unchanged and available.</p>
<p>Immutability provides:</p>
<ul>
<li><strong>Reliable references</strong>: A CID always refers to the same content</li>
<li><strong>Historical record</strong>: All versions persist as distinct resources</li>
<li><strong>Concurrent access</strong>: No coordination needed for reads (content never changes)</li>
<li><strong>Distribution</strong>: Resources can move between stores with identity intact</li>
</ul>
<h3 id="references-as-cids"><a class="header" href="#references-as-cids">References as CIDs</a></h3>
<p>Resources can reference other resources by including CIDs in their content. A JSON resource might contain:</p>
<pre><code>{
  "spec": "cid:abc123...",
  "interface": "cid:def456...",
  "documentation": "cid:789ghi..."
}
</code></pre>
<p>These references form a <strong>directed graph</strong> where nodes are resources and edges are CID references. The graph is immutable—references never change—but new resources can reference existing resources, extending the graph.</p>
<p>The reference graph enables:</p>
<ul>
<li><strong>Aggregation</strong>: Collecting related resources by following references</li>
<li><strong>Composition</strong>: Building complex structures from simple resources</li>
<li><strong>Deduplication</strong>: Multiple resources can reference the same resource</li>
<li><strong>Versioning</strong>: New versions reference previous versions</li>
</ul>
<h2 id="store-capabilities"><a class="header" href="#store-capabilities">Store Capabilities</a></h2>
<p>The container store provides four fundamental capabilities.</p>
<h3 id="1-store"><a class="header" href="#1-store">1. Store</a></h3>
<p><strong>Operation</strong>: Given content (bytes), compute the CID and store the content indexed by CID.</p>
<p><strong>Properties</strong>:</p>
<ul>
<li>Idempotent: Storing identical content multiple times produces the same CID and stores content once</li>
<li>Atomic: Content is either fully stored or not stored (no partial writes)</li>
<li>Durable: Once stored, content persists until explicitly deleted</li>
</ul>
<p><strong>Result</strong>: The CID identifying the stored resource.</p>
<p>This operation makes resources available for retrieval and projection.</p>
<h3 id="2-retrieve"><a class="header" href="#2-retrieve">2. Retrieve</a></h3>
<p><strong>Operation</strong>: Given a CID, retrieve the corresponding resource content.</p>
<p><strong>Properties</strong>:</p>
<ul>
<li>Deterministic: The same CID always retrieves the same content</li>
<li>Verified: Retrieved content can be hashed to verify it matches the CID</li>
<li>Complete: Resources are retrieved entirely (no partial retrieval in base operation)</li>
</ul>
<p><strong>Result</strong>: The complete content of the resource, or an indication that the CID is not present in the store.</p>
<p>This operation makes stored resources accessible.</p>
<h3 id="3-reference"><a class="header" href="#3-reference">3. Reference</a></h3>
<p><strong>Operation</strong>: Parse a resource’s content to extract CIDs that reference other resources.</p>
<p><strong>Properties</strong>:</p>
<ul>
<li>Format-dependent: Different content types encode references differently (JSON uses strings, binary formats use specific fields)</li>
<li>Transitive: Following references from referenced resources builds the reference graph</li>
<li>Graph-forming: References create a directed graph structure over resources</li>
</ul>
<p><strong>Result</strong>: A set of CIDs referenced by the resource.</p>
<p>This operation enables graph traversal and aggregation.</p>
<h3 id="4-query"><a class="header" href="#4-query">4. Query</a></h3>
<p><strong>Operation</strong>: Identify resources matching specified criteria (content patterns, reference relationships, metadata constraints).</p>
<p><strong>Properties</strong>:</p>
<ul>
<li>Set-valued: Queries return zero or more matching resources</li>
<li>Composable: Query results can be inputs to other queries</li>
<li>Projection-enabling: Queries identify resources to aggregate into containers</li>
</ul>
<p><strong>Result</strong>: A set of CIDs for resources matching the query criteria.</p>
<p>This operation enables projections to identify relevant resources.</p>
<h2 id="store-properties"><a class="header" href="#store-properties">Store Properties</a></h2>
<p>These capabilities provide foundational properties that the projection engine and platform rely upon.</p>
<h3 id="deduplication"><a class="header" href="#deduplication">Deduplication</a></h3>
<p>Identical content produces the same CID. If the same content is stored multiple times, it occupies storage space once but can be referenced by multiple CID references.</p>
<p>This eliminates redundancy—shared resources (common dependencies, standard interfaces, repeated data) exist once in the store regardless of how many containers reference them.</p>
<h3 id="integrity"><a class="header" href="#integrity">Integrity</a></h3>
<p>Retrieved content can be verified by computing its hash and comparing to the CID. Any corruption, tampering, or transmission error is detectable.</p>
<p>This makes the store <strong>trustless</strong>—you can retrieve resources from untrusted sources and verify integrity cryptographically.</p>
<h3 id="immutability-1"><a class="header" href="#immutability-1">Immutability</a></h3>
<p>Resources never change after being written. This provides:</p>
<ul>
<li><strong>Stable references</strong>: CIDs are reliable permanent identifiers</li>
<li><strong>Historical completeness</strong>: All versions of evolving data persist as separate resources</li>
<li><strong>Conflict-free replication</strong>: Immutable resources can be copied between stores without coordination</li>
</ul>
<h3 id="content-equivalence"><a class="header" href="#content-equivalence">Content Equivalence</a></h3>
<p>If two stores contain resources with the same CID, the content is identical. This enables:</p>
<ul>
<li><strong>Store synchronization</strong>: Comparing CID sets identifies missing resources</li>
<li><strong>Distributed storage</strong>: Resources can live in different stores while maintaining identity</li>
<li><strong>Caching</strong>: Resources can be cached anywhere without invalidation concerns</li>
</ul>
<h3 id="addressability"><a class="header" href="#addressability">Addressability</a></h3>
<p>Every resource has a globally unique identifier (its CID) that remains valid across stores, networks, and time. Resources can be:</p>
<ul>
<li>Moved between storage backends without changing identity</li>
<li>Cached locally while referencing remote stores</li>
<li>Shared through CIDs without transferring content</li>
<li>Archived and restored while maintaining references</li>
</ul>
<h2 id="graph-structure"><a class="header" href="#graph-structure">Graph Structure</a></h2>
<p>The reference capability creates an immutable directed graph:</p>
<ul>
<li><strong>Nodes</strong> are resources identified by CID</li>
<li><strong>Edges</strong> are references (CID values in resource content)</li>
<li><strong>Properties</strong>:
<ul>
<li>Acyclic or cyclic (nothing prevents cycles)</li>
<li>Immutable (edges never change, but new nodes can be added)</li>
<li>Traversable (following edges from any node explores connected resources)</li>
</ul>
</li>
</ul>
<p>The graph structure enables:</p>
<p><strong>Aggregation</strong>: Starting from a root resource, follow references to collect all related resources (a component and its documentation, tests, dependencies).</p>
<p><strong>Reachability</strong>: Determine what resources are transitively referenced from a starting point, enabling garbage collection of unreferenced resources.</p>
<p><strong>Versioning</strong>: New versions of resources can reference previous versions, creating version chains in the graph.</p>
<p><strong>Composition</strong>: Complex containers are projections over subgraphs—collecting specific resources based on reference patterns.</p>
<h2 id="implementation-independence"><a class="header" href="#implementation-independence">Implementation Independence</a></h2>
<p>The container store is defined by its capabilities and properties, not by a specific implementation.</p>
<p>Valid store implementations include:</p>
<p><strong>Filesystem</strong>: Resources as files in content-addressed directories, references parsed from file contents.</p>
<p><strong>Relational Database</strong>: Resources as BLOBs in tables, CIDs as primary keys, references extracted and indexed for query performance.</p>
<p><strong>Object Storage</strong>: Resources as objects in cloud storage (S3, Azure Blob), CIDs as object keys.</p>
<p><strong>Distributed Hash Table</strong>: Resources distributed across nodes in a DHT, CID-based retrieval and replication.</p>
<p><strong>Hybrid</strong>: Filesystem for local working set, database for indexing and queries, object storage for archival.</p>
<p>The platform operates identically regardless of backend. This allows:</p>
<ul>
<li>Choosing storage appropriate to scale and access patterns</li>
<li>Migrating between backends without changing platform semantics</li>
<li>Using multiple backends simultaneously (local cache + remote archive)</li>
</ul>
<h2 id="store-metadata"><a class="header" href="#store-metadata">Store Metadata</a></h2>
<p>The store may maintain metadata about resources beyond their content:</p>
<ul>
<li><strong>Storage timestamp</strong>: When the resource was written to this store</li>
<li><strong>Access patterns</strong>: How frequently the resource is retrieved</li>
<li><strong>Reference count</strong>: How many other resources reference this CID</li>
<li><strong>Size</strong>: Byte count of resource content</li>
</ul>
<p>This metadata is <strong>not part of the resource</strong> and does not affect the CID. It assists with store management (garbage collection, caching, performance optimization) but is not visible to projections.</p>
<p>Metadata is store-specific and not preserved when resources move between stores.</p>
<h2 id="garbage-collection"><a class="header" href="#garbage-collection">Garbage Collection</a></h2>
<p>Since resources are immutable and referenced by CID, unused resources can accumulate. <strong>Garbage collection</strong> identifies and removes resources that are no longer reachable from any root.</p>
<p><strong>Roots</strong> are resources designated as starting points (active component definitions, running instances, materialized views). Resources reachable by following references from roots are retained. Unreachable resources can be deleted.</p>
<p>Garbage collection is a store management operation, not a platform operation. It operates on the store’s reference graph without affecting the projection engine or platform semantics.</p>
<h2 id="the-store-as-foundation"><a class="header" href="#the-store-as-foundation">The Store as Foundation</a></h2>
<p>The container store provides the invariant foundation for the platform:</p>
<ul>
<li>All resources exist in the store</li>
<li>All resources are content-addressed and immutable</li>
<li>All resources are referenceable by CID</li>
<li>All resources are queryable for projection</li>
</ul>
<p>From this foundation, we build the projection-emission cycle: projections identify and aggregate resources from the store, execution produces results, and emissions write new resources back to the store.</p>
<p>The next document, <strong>The Projection-Emission Cycle</strong>, describes how the platform operates on the container store through continuous cycles of projection and emission.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-projection-emission-cycle-1"><a class="header" href="#the-projection-emission-cycle-1">The Projection-Emission Cycle</a></h1>
<h2 id="the-fundamental-operating-principle"><a class="header" href="#the-fundamental-operating-principle">The Fundamental Operating Principle</a></h2>
<p>The Hologram platform operates through a continuous cycle of <strong>projection</strong> and <strong>emission</strong>:</p>
<p><strong>Project → Execute → Emit → Store → Project…</strong></p>
<p>This cycle is the fundamental mechanism by which the platform creates containers, executes operations, and evolves over time. Every interaction with Hologram—creating components, running instances, materializing views, executing operations—follows this cycle.</p>
<p>This document establishes how the projection-emission cycle works and why it provides a universal operating model for the platform.</p>
<h2 id="the-four-phases"><a class="header" href="#the-four-phases">The Four Phases</a></h2>
<h3 id="phase-1-project"><a class="header" href="#phase-1-project">Phase 1: Project</a></h3>
<p><strong>Projection</strong> identifies and aggregates resources from the container store to form a container.</p>
<p>A projection definition specifies:</p>
<ul>
<li><strong>Query criteria</strong>: Which resources to identify (by content patterns, reference relationships, metadata)</li>
<li><strong>Aggregation rules</strong>: How to collect related resources (following references, grouping by properties)</li>
<li><strong>Transformation</strong>: How to structure aggregated resources into a container</li>
</ul>
<p>The projection engine evaluates the definition against the store, producing a <strong>container</strong>—a structured collection of resources with defined relationships and purpose.</p>
<p>Projection is <strong>read-only</strong>. It examines the store but does not modify it. The same projection evaluated multiple times against an unchanged store produces the same container.</p>
<h3 id="phase-2-execute"><a class="header" href="#phase-2-execute">Phase 2: Execute</a></h3>
<p><strong>Execution</strong> operates on the projected container to produce results.</p>
<p>Execution might:</p>
<ul>
<li>Validate that resources satisfy constraints</li>
<li>Transform resources into different formats</li>
<li>Run computation using resources as inputs</li>
<li>Coordinate between multiple containers</li>
<li>Generate new content from container resources</li>
</ul>
<p>Execution consumes projected resources and produces results. Results might be:</p>
<ul>
<li>Status information (success, failure, validation results)</li>
<li>Transformed content (compiled artifacts, rendered documentation)</li>
<li>Generated data (logs, metrics, computed results)</li>
<li>New resource definitions (component updates, instance state)</li>
</ul>
<p>Execution is <strong>isolated</strong>. It operates on projected resources without directly accessing the store. This isolation enables:</p>
<ul>
<li>Reproducibility: Same inputs produce same results</li>
<li>Testability: Execution can be tested with mock containers</li>
<li>Distribution: Execution can occur anywhere with the projected resources</li>
</ul>
<h3 id="phase-3-emit"><a class="header" href="#phase-3-emit">Phase 3: Emit</a></h3>
<p><strong>Emission</strong> writes execution results back to the container store as new resources.</p>
<p>Each result is:</p>
<ol>
<li>Serialized to bytes</li>
<li>Hashed to produce a CID</li>
<li>Stored in the container store indexed by CID</li>
</ol>
<p>Emitted resources become immediately available for future projections. They exist in the store alongside resources from previous operations, forming an accumulated knowledge base.</p>
<p>Emission is <strong>additive</strong>. New resources are added; existing resources are never modified. This preserves complete history—every emission creates a new snapshot while previous snapshots remain accessible.</p>
<h3 id="phase-4-store"><a class="header" href="#phase-4-store">Phase 4: Store</a></h3>
<p><strong>Storage</strong> persists emitted resources durably in the container store.</p>
<p>The store:</p>
<ul>
<li>Indexes resources by CID for retrieval</li>
<li>Updates queryable metadata for projection</li>
<li>Extends the reference graph with new resources</li>
<li>Maintains integrity guarantees (immutability, deduplication)</li>
</ul>
<p>Once stored, resources are available for projection. The cycle completes and can begin again—new projections can include newly emitted resources.</p>
<h2 id="the-complete-cycle"><a class="header" href="#the-complete-cycle">The Complete Cycle</a></h2>
<p>Chaining these phases creates a continuous cycle:</p>
<ol>
<li>A client requests an operation (create component, run instance, materialize view)</li>
<li><strong>Project</strong>: The engine projects resources needed for the operation</li>
<li><strong>Execute</strong>: The operation runs using projected resources</li>
<li><strong>Emit</strong>: Results are emitted as new resources</li>
<li><strong>Store</strong>: Emitted resources are persisted</li>
<li>The client can request further operations, which project the newly stored resources</li>
</ol>
<p>Each cycle adds to the store. Over time, the store accumulates:</p>
<ul>
<li>Component definitions</li>
<li>Instance states</li>
<li>Operation logs</li>
<li>Materialized views</li>
<li>Application data</li>
<li>User content</li>
</ul>
<p>All emitted as immutable, content-addressed resources available for projection.</p>
<h2 id="why-this-cycle-works"><a class="header" href="#why-this-cycle-works">Why This Cycle Works</a></h2>
<h3 id="universal-applicability"><a class="header" href="#universal-applicability">Universal Applicability</a></h3>
<p>The same cycle applies to every platform operation:</p>
<p><strong>Creating a component definition</strong>:</p>
<ul>
<li>Project: Identify artifact resources (spec, interface, docs, tests)</li>
<li>Execute: Validate artifacts against schemas, compute component structure</li>
<li>Emit: Write component definition resource</li>
<li>Store: Persist component definition</li>
</ul>
<p><strong>Running an instance</strong>:</p>
<ul>
<li>Project: Identify component definition and dependencies</li>
<li>Execute: Run the component’s defined computation</li>
<li>Emit: Write logs, state snapshots, application outputs</li>
<li>Store: Persist instance emissions continuously</li>
</ul>
<p><strong>Materializing a view</strong>:</p>
<ul>
<li>Project: Identify resources matching view criteria</li>
<li>Execute: Transform resources into view format</li>
<li>Emit: Write materialized view resource</li>
<li>Store: Persist view for efficient access</li>
</ul>
<p>Every operation is a projection-emission cycle with operation-specific execution logic.</p>
<h3 id="composability"><a class="header" href="#composability">Composability</a></h3>
<p>Cycles can chain. One operation’s emissions become another operation’s projection inputs:</p>
<ul>
<li>Create component definition → emit component resource</li>
<li>Create instance from component → project component, emit instance resource</li>
<li>Instance runs → emit logs and state</li>
<li>Materialize log view → project logs, emit view</li>
<li>Query log view → project view, return results</li>
</ul>
<p>Each operation builds on previous emissions. Complex workflows emerge from composing simple projection-emission cycles.</p>
<h3 id="self-evolution"><a class="header" href="#self-evolution">Self-Evolution</a></h3>
<p>The platform itself is defined through projections. Improving the platform means:</p>
<ul>
<li>Defining new projection definitions (new container types, new operations)</li>
<li>Emitting those definitions as resources</li>
<li>The engine projects the new definitions and incorporates them</li>
</ul>
<p>The platform evolves through the same projection-emission cycle used for applications. There is no separate “platform update” mechanism—platform and application use the same primitives.</p>
<h3 id="auditability"><a class="header" href="#auditability">Auditability</a></h3>
<p>Every emission is immutable and content-addressed. The store contains complete history:</p>
<ul>
<li>What resources were projected (recorded in operation logs)</li>
<li>What execution occurred (recorded in execution logs)</li>
<li>What results were emitted (the emitted resources themselves)</li>
<li>When operations occurred (store metadata)</li>
</ul>
<p>This provides full audit trails without additional logging infrastructure. The projection-emission cycle inherently records its own history.</p>
<h3 id="reproducibility"><a class="header" href="#reproducibility">Reproducibility</a></h3>
<p>Given the same projected resources and execution logic, the same results are emitted. This enables:</p>
<ul>
<li><strong>Deterministic operations</strong>: Re-running projections produces consistent results</li>
<li><strong>Testing</strong>: Mock stores with known resources enable testing projection-emission cycles</li>
<li><strong>Debugging</strong>: Reproducing issues by projecting the same historical resources</li>
</ul>
<p>Immutability of resources guarantees that historical projections remain reproducible—the resources never change.</p>
<h2 id="examples-across-the-platform"><a class="header" href="#examples-across-the-platform">Examples Across the Platform</a></h2>
<h3 id="component-crud-operations"><a class="header" href="#component-crud-operations">Component CRUD Operations</a></h3>
<p><strong>Create</strong>:</p>
<ul>
<li>Project: Artifact resources submitted by client</li>
<li>Execute: Validate artifacts, build component structure</li>
<li>Emit: Component definition resource</li>
<li>Store: Component available for projection</li>
</ul>
<p><strong>Read</strong>:</p>
<ul>
<li>Project: Component definition and referenced resources</li>
<li>Execute: Assemble complete component container</li>
<li>Emit: None (read-only operation, but query results could be cached as emissions)</li>
<li>Store: No new resources (unless caching results)</li>
</ul>
<p><strong>Update</strong>:</p>
<ul>
<li>Project: Existing component definition, new artifact resources</li>
<li>Execute: Validate changes, build updated component</li>
<li>Emit: New component definition resource (original unchanged)</li>
<li>Store: Updated component available, original remains for versioning</li>
</ul>
<p><strong>Delete</strong>:</p>
<ul>
<li>Project: Component definition, dependency references</li>
<li>Execute: Verify no dependencies, mark component as deleted</li>
<li>Emit: Deletion marker or updated catalog</li>
<li>Store: Component no longer appears in catalogs (but resources remain for history)</li>
</ul>
<h3 id="instance-lifecycle"><a class="header" href="#instance-lifecycle">Instance Lifecycle</a></h3>
<p><strong>Start</strong>:</p>
<ul>
<li>Project: Component definition</li>
<li>Execute: Initialize instance state, begin execution</li>
<li>Emit: Instance resource with initial state</li>
<li>Store: Instance available for monitoring</li>
</ul>
<p><strong>Run</strong>:</p>
<ul>
<li>Project: Instance state, component definition</li>
<li>Execute: Continue instance execution</li>
<li>Emit: Logs, metrics, application data, state updates</li>
<li>Store: Continuous stream of emitted resources</li>
</ul>
<p><strong>Stop</strong>:</p>
<ul>
<li>Project: Running instance resource</li>
<li>Execute: Graceful shutdown</li>
<li>Emit: Final state, shutdown logs</li>
<li>Store: Instance state preserved</li>
</ul>
<p><strong>Restart</strong>:</p>
<ul>
<li>Project: Stopped instance resource</li>
<li>Execute: Reinitialize from last state</li>
<li>Emit: New instance resource (new start)</li>
<li>Store: New instance lifecycle begins</li>
</ul>
<h3 id="view-materialization"><a class="header" href="#view-materialization">View Materialization</a></h3>
<p><strong>Materialize</strong>:</p>
<ul>
<li>Project: Resources matching view criteria</li>
<li>Execute: Transform to view format, aggregate</li>
<li>Emit: Materialized view resource</li>
<li>Store: View available for efficient queries</li>
</ul>
<p><strong>Refresh</strong>:</p>
<ul>
<li>Project: Current view, new resources since last materialization</li>
<li>Execute: Update view with new data</li>
<li>Emit: Updated view resource</li>
<li>Store: Fresh view available</li>
</ul>
<p><strong>Query</strong>:</p>
<ul>
<li>Project: Materialized view resource</li>
<li>Execute: Filter/search within view</li>
<li>Emit: Query results (potentially cached)</li>
<li>Store: Results available for reuse</li>
</ul>
<h2 id="the-generative-property"><a class="header" href="#the-generative-property">The Generative Property</a></h2>
<p>Each emission adds to the store. Over time, the store grows richer:</p>
<ul>
<li>More components → more capabilities</li>
<li>More instances → more application data</li>
<li>More logs → better observability</li>
<li>More views → more ways to understand the system</li>
</ul>
<p>This is <strong>generative</strong>—the system becomes more capable through use. Every operation contributes to the knowledge base available for future projections.</p>
<p>The projection-emission cycle creates a <strong>flywheel effect</strong>: more emissions enable richer projections, which enable more sophisticated operations, which produce richer emissions.</p>
<h2 id="invariants"><a class="header" href="#invariants">Invariants</a></h2>
<p>The cycle maintains critical invariants:</p>
<p><strong>Store Immutability</strong>: Resources never change after emission. History is preserved.</p>
<p><strong>Projection Purity</strong>: Projections don’t modify the store. They’re reproducible queries.</p>
<p><strong>Emission Atomicity</strong>: Resources are either fully emitted or not emitted (no partial writes).</p>
<p><strong>CID Integrity</strong>: Emitted resources are correctly identified by content hash.</p>
<p><strong>Reference Validity</strong>: CID references in emitted resources refer to actual stored resources.</p>
<p>These invariants enable reasoning about the system—projections are safe queries, emissions are durable writes, the store is a reliable foundation.</p>
<h2 id="contrast-with-traditional-systems"><a class="header" href="#contrast-with-traditional-systems">Contrast with Traditional Systems</a></h2>
<p>Traditional systems often separate:</p>
<ul>
<li><strong>Data storage</strong> (databases, filesystems)</li>
<li><strong>Computation</strong> (application logic)</li>
<li><strong>Output</strong> (write operations, side effects)</li>
</ul>
<p>Hologram unifies these through the projection-emission cycle:</p>
<ul>
<li>Storage, computation, and output are phases of a single cycle</li>
<li>All operations follow the same pattern</li>
<li>The boundary between platform and application blurs (both use projection-emission)</li>
</ul>
<p>This unification provides consistency—learning one operation teaches the pattern for all operations.</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>The projection-emission cycle operates on containers. The next document, <strong>Container Projections</strong>, describes how projections transform undifferentiated resources into containers with structure, meaning, and purpose.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-projections"><a class="header" href="#container-projections">Container Projections</a></h1>
<h2 id="from-resources-to-containers"><a class="header" href="#from-resources-to-containers">From Resources to Containers</a></h2>
<p>Resources in the container store exist as undifferentiated, content-addressed data without inherent structure or meaning. <strong>Projections</strong> transform resources into <strong>containers</strong>—structured collections with defined purpose, relationships, and semantics.</p>
<p>This document establishes how projections work, what containers are, and how the projection mechanism provides universal containment.</p>
<h2 id="what-is-a-container"><a class="header" href="#what-is-a-container">What is a Container?</a></h2>
<p>A <strong>container</strong> is a structured view of resources produced by a projection. Containers have:</p>
<p><strong>Identity</strong>: A container is identified by the projection that produced it and the query parameters used (which resources, what time, what filters).</p>
<p><strong>Content</strong>: A container contains or references specific resources from the store.</p>
<p><strong>Structure</strong>: A container organizes resources according to the projection definition (aggregation rules, transformation logic).</p>
<p><strong>Purpose</strong>: A container serves a defined role (component definition, running instance, documentation view, test suite).</p>
<p><strong>Behavior</strong>: A container may define operations that can be performed with its resources (validate, execute, transform).</p>
<p>Containers are <strong>ephemeral projections</strong> or <strong>materialized resources</strong>:</p>
<ul>
<li><strong>Ephemeral</strong>: The container exists during projection evaluation, used immediately, then discarded</li>
<li><strong>Materialized</strong>: The container is emitted as a resource to the store for persistent access</li>
</ul>
<h2 id="projection-mechanism"><a class="header" href="#projection-mechanism">Projection Mechanism</a></h2>
<p>A projection transforms resources into containers through three stages:</p>
<h3 id="stage-1-identification"><a class="header" href="#stage-1-identification">Stage 1: Identification</a></h3>
<p><strong>Query evaluation</strong> identifies resources in the store matching specified criteria.</p>
<p>Query criteria can include:</p>
<ul>
<li><strong>Content patterns</strong>: Resources containing specific data (JSON with particular fields, text matching patterns)</li>
<li><strong>CID references</strong>: Resources referenced by known CIDs</li>
<li><strong>Reference relationships</strong>: Resources that reference or are referenced by other resources</li>
<li><strong>Metadata constraints</strong>: Resources with specific metadata (stored during a time range, accessed frequently)</li>
</ul>
<p>The result is a <strong>resource set</strong>—the CIDs of matching resources.</p>
<h3 id="stage-2-aggregation"><a class="header" href="#stage-2-aggregation">Stage 2: Aggregation</a></h3>
<p><strong>Aggregation</strong> collects related resources by following reference relationships.</p>
<p>Starting from the resource set, aggregation:</p>
<ul>
<li>Follows CID references to retrieve related resources</li>
<li>Applies traversal rules (depth limits, reference type filters)</li>
<li>Collects transitive closure (all reachable resources) or specific subgraphs</li>
<li>Groups resources by relationships or properties</li>
</ul>
<p>The result is an <strong>aggregated resource graph</strong>—resources and their relationships.</p>
<h3 id="stage-3-transformation"><a class="header" href="#stage-3-transformation">Stage 3: Transformation</a></h3>
<p><strong>Transformation</strong> structures aggregated resources into container format.</p>
<p>Transformation might:</p>
<ul>
<li>Extract specific fields from resources</li>
<li>Combine multiple resources into unified structure</li>
<li>Apply formatting or encoding conversions</li>
<li>Compute derived values from resource content</li>
<li>Order or filter based on container requirements</li>
</ul>
<p>The result is a <strong>container</strong>—the final structured collection ready for use.</p>
<h2 id="projection-definitions"><a class="header" href="#projection-definitions">Projection Definitions</a></h2>
<p>A <strong>projection definition</strong> is itself a resource in the store that specifies how to project resources into containers.</p>
<p>Projection definitions contain:</p>
<ul>
<li><strong>Query specification</strong>: How to identify resources</li>
<li><strong>Aggregation rules</strong>: How to collect related resources</li>
<li><strong>Transformation logic</strong>: How to structure the container</li>
<li><strong>Conformance requirements</strong>: What constraints aggregated resources must satisfy</li>
</ul>
<p>Because projection definitions are resources, they can be:</p>
<ul>
<li>Versioned (new projection definitions with different CIDs)</li>
<li>Composed (projection definitions that reference other projection definitions)</li>
<li>Projected (meta-projections that analyze or transform projection definitions)</li>
</ul>
<p>This creates <strong>recursive projections</strong>—the system projects its own projection definitions.</p>
<h2 id="container-types-through-projection"><a class="header" href="#container-types-through-projection">Container Types Through Projection</a></h2>
<p>Different projection definitions create different container types. The platform provides base projection definitions for standard container types:</p>
<p><strong>Component Container</strong>:</p>
<ul>
<li>Identifies: Resources with component namespace</li>
<li>Aggregates: Spec, interface, documentation, tests, dependencies</li>
<li>Transforms: Structured component definition</li>
<li>Purpose: Reusable capability definition</li>
</ul>
<p><strong>Instance Container</strong>:</p>
<ul>
<li>Identifies: Resources with instance identifier</li>
<li>Aggregates: Component definition, instance state, runtime context</li>
<li>Transforms: Executable instance</li>
<li>Purpose: Running component with state</li>
</ul>
<p><strong>Interface Container</strong>:</p>
<ul>
<li>Identifies: Resources with interface definitions</li>
<li>Aggregates: Method signatures, type definitions, contracts</li>
<li>Transforms: Interface specification</li>
<li>Purpose: Contract between components</li>
</ul>
<p><strong>Documentation Container</strong>:</p>
<ul>
<li>Identifies: Documentation resources</li>
<li>Aggregates: Docs by namespace, cross-references</li>
<li>Transforms: Human-readable documentation</li>
<li>Purpose: Understanding and guidance</li>
</ul>
<p><strong>Test Container</strong>:</p>
<ul>
<li>Identifies: Test resources</li>
<li>Aggregates: Test cases, expected results, validation logic</li>
<li>Transforms: Executable test suite</li>
<li>Purpose: Validation and verification</li>
</ul>
<p><strong>View Container</strong>:</p>
<ul>
<li>Identifies: Resources matching view criteria</li>
<li>Aggregates: According to view definition</li>
<li>Transforms: Materialized view format</li>
<li>Purpose: Efficient access to projected data</li>
</ul>
<p>Each container type is defined by its projection definition. New container types are created by emitting new projection definitions.</p>
<h2 id="projection-composition"><a class="header" href="#projection-composition">Projection Composition</a></h2>
<p>Projections can compose—one projection can use another’s results as input.</p>
<p><strong>Nested Projection</strong>: A component container projects interface containers for each interface it references. The interface projections run as sub-projections of the component projection.</p>
<p><strong>Sequential Projection</strong>: Create component → project component → create instance → project instance. Each projection’s output becomes input to the next operation.</p>
<p><strong>Parallel Projection</strong>: Multiple projections execute concurrently over the same store. A documentation view and a test view project the same components simultaneously.</p>
<p>Composition enables building complex containers from simple projections without implementing complex monolithic projection logic.</p>
<h2 id="projection-parameters"><a class="header" href="#projection-parameters">Projection Parameters</a></h2>
<p>Projections can accept parameters that customize their behavior:</p>
<p><strong>Resource Filters</strong>: Project only resources matching specific criteria (namespace, time range, content patterns).</p>
<p><strong>Depth Limits</strong>: Control how deeply to follow references during aggregation.</p>
<p><strong>Transformation Options</strong>: Enable optional transformations (include/exclude certain fields, format preferences).</p>
<p><strong>Temporal Constraints</strong>: Project resources as they existed at a specific point in time (time-travel queries).</p>
<p>Parameterized projections enable reusing projection definitions for different contexts without creating multiple definition variants.</p>
<h2 id="the-projection-graph"><a class="header" href="#the-projection-graph">The Projection Graph</a></h2>
<p>Executing multiple projections creates a <strong>projection graph</strong>:</p>
<ul>
<li><strong>Nodes</strong>: Containers produced by projections</li>
<li><strong>Edges</strong>: Dependencies where one projection uses another’s results</li>
</ul>
<p>The projection graph shows relationships between containers:</p>
<ul>
<li>Component containers reference interface containers</li>
<li>Instance containers reference component containers</li>
<li>View containers reference multiple other container types</li>
</ul>
<p>The projection graph is distinct from the resource reference graph:</p>
<ul>
<li>Resource graph: Immutable CID references between resources</li>
<li>Projection graph: Ephemeral relationships between projected containers</li>
</ul>
<h2 id="containers-vs-resources"><a class="header" href="#containers-vs-resources">Containers vs Resources</a></h2>
<p>Key distinctions:</p>
<p><strong>Resources</strong>:</p>
<ul>
<li>Immutable content in the store</li>
<li>Identified by CID (content hash)</li>
<li>No inherent structure or meaning</li>
<li>Permanent (until garbage collected)</li>
</ul>
<p><strong>Containers</strong>:</p>
<ul>
<li>Structured projections of resources</li>
<li>Identified by projection definition + parameters</li>
<li>Defined structure and purpose</li>
<li>Ephemeral (exist during use) or materialized (emitted as resources)</li>
</ul>
<p>A resource can participate in multiple containers. The same documentation resource might appear in:</p>
<ul>
<li>A component container (as component docs)</li>
<li>A documentation view container (as part of searchable docs)</li>
<li>A tutorial container (as example content)</li>
</ul>
<p>Projection determines how the resource appears and what role it serves.</p>
<h2 id="projection-purity"><a class="header" href="#projection-purity">Projection Purity</a></h2>
<p>Projections are <strong>pure queries</strong>—they do not modify the store or have side effects.</p>
<p>Properties:</p>
<ul>
<li><strong>Deterministic</strong>: Same store state and parameters produce same container</li>
<li><strong>Repeatable</strong>: Projecting multiple times yields consistent results</li>
<li><strong>Concurrent</strong>: Multiple projections can run simultaneously without interference</li>
<li><strong>Cacheable</strong>: Projection results can be cached and reused</li>
</ul>
<p>Purity enables:</p>
<ul>
<li><strong>Testing</strong>: Projections can be tested with known resource sets</li>
<li><strong>Debugging</strong>: Reproducing projections for investigation</li>
<li><strong>Optimization</strong>: Caching projection results for performance</li>
</ul>
<p>Side effects (creating resources, executing stateful operations) occur during the <strong>Execute</strong> phase of the projection-emission cycle, not during projection itself.</p>
<h2 id="temporal-projections"><a class="header" href="#temporal-projections">Temporal Projections</a></h2>
<p>Because resources are immutable, the store preserves history. <strong>Temporal projections</strong> project resources as they existed at a previous time.</p>
<p>A temporal projection:</p>
<ol>
<li>Identifies resources that existed at the specified time (based on store metadata)</li>
<li>Aggregates using only references that existed at that time</li>
<li>Produces a container representing historical state</li>
</ol>
<p>This enables:</p>
<ul>
<li><strong>Versioning</strong>: View previous versions of components or instances</li>
<li><strong>Audit</strong>: Understand what resources were available when operations occurred</li>
<li><strong>Debugging</strong>: Reproduce historical state to investigate issues</li>
</ul>
<p>Temporal projections work because resources never change—a CID always refers to the same content, regardless of when you project it.</p>
<h2 id="dynamic-projections"><a class="header" href="#dynamic-projections">Dynamic Projections</a></h2>
<p>Some projections depend on runtime state or external context:</p>
<p><strong>Instance Projections</strong>: Project current instance state, which changes as the instance emits new resources.</p>
<p><strong>Live View Projections</strong>: Project continuously, incorporating new resources as they’re emitted.</p>
<p><strong>Contextual Projections</strong>: Include user-specific or environment-specific resources (user permissions, deployment configuration).</p>
<p>Dynamic projections are still pure queries against the store’s current state, but that state evolves through emissions, causing projection results to change over time.</p>
<h2 id="projection-performance"><a class="header" href="#projection-performance">Projection Performance</a></h2>
<p>Projection performance depends on:</p>
<p><strong>Store Query Efficiency</strong>: How quickly the store can identify matching resources (indexing, caching).</p>
<p><strong>Graph Traversal</strong>: How many references must be followed during aggregation (depth, branching factor).</p>
<p><strong>Transformation Complexity</strong>: How much computation is required to structure the container.</p>
<p><strong>Resource Size</strong>: How much data must be retrieved and processed.</p>
<p>Optimization strategies:</p>
<ul>
<li><strong>Materialized Views</strong>: Pre-compute and emit common projections as resources</li>
<li><strong>Incremental Updates</strong>: Update views with only new/changed resources rather than full reprojection</li>
<li><strong>Lazy Aggregation</strong>: Follow references only as needed rather than complete traversal</li>
<li><strong>Query Optimization</strong>: Index store metadata for fast resource identification</li>
</ul>
<h2 id="projection-as-lens"><a class="header" href="#projection-as-lens">Projection as Lens</a></h2>
<p>Projections act as <strong>lenses</strong> that reveal different aspects of the store:</p>
<ul>
<li>A component lens reveals reusable definitions</li>
<li>An instance lens reveals running state</li>
<li>A documentation lens reveals human-readable content</li>
<li>A dependency lens reveals relationship graphs</li>
</ul>
<p>The same underlying resources appear differently through different lenses. There is no “true” view—all containers are valid projections serving different purposes.</p>
<p>This multiplicity enables flexible organization: structure resources however projections require without committing to a single schema or hierarchy.</p>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Projections are defined and executed by the <strong>Projection Engine</strong>, which interprets projection definitions and orchestrates the identification-aggregation-transformation pipeline.</p>
<p>The next section, Part II: The Engine, details how the projection engine works, the projection language for defining projections, and how emissions create new resources for future projections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-projection-engine-1"><a class="header" href="#the-projection-engine-1">The Projection Engine</a></h1>
<h2 id="executing-projections"><a class="header" href="#executing-projections">Executing Projections</a></h2>
<p>The <strong>projection engine</strong> is the component that interprets projection definitions and executes them against the container store to produce containers.</p>
<p>This document describes how the engine works, its architecture, execution model, and how it orchestrates the projection-emission cycle.</p>
<h2 id="engine-responsibilities"><a class="header" href="#engine-responsibilities">Engine Responsibilities</a></h2>
<p>The projection engine:</p>
<p><strong>Interprets Projection Definitions</strong>: Reads projection definition resources from the store and parses them into executable instructions.</p>
<p><strong>Executes Queries</strong>: Evaluates query criteria against the store to identify matching resources.</p>
<p><strong>Traverses References</strong>: Follows CID references to aggregate related resources according to aggregation rules.</p>
<p><strong>Applies Transformations</strong>: Structures aggregated resources into containers according to transformation logic.</p>
<p><strong>Manages Execution Context</strong>: Maintains state during projection execution (visited resources, depth tracking, intermediate results).</p>
<p><strong>Coordinates Composition</strong>: Orchestrates nested and sequential projections, managing dependencies between them.</p>
<p><strong>Handles Errors</strong>: Validates constraints, reports failures, ensures projections complete successfully or fail cleanly.</p>
<p>The engine is the <strong>interpreter</strong> for the projection language—it gives operational meaning to declarative projection definitions.</p>
<h2 id="execution-model"><a class="header" href="#execution-model">Execution Model</a></h2>
<h3 id="projection-request"><a class="header" href="#projection-request">Projection Request</a></h3>
<p>A projection execution begins with a <strong>request</strong> specifying:</p>
<ul>
<li><strong>Projection Definition CID</strong>: Which projection to execute</li>
<li><strong>Parameters</strong>: Values for parameterized queries or transformations</li>
<li><strong>Context</strong>: Additional information (user identity, environment, temporal constraints)</li>
</ul>
<p>The engine retrieves the projection definition resource, validates it, and begins execution.</p>
<h3 id="three-phase-execution"><a class="header" href="#three-phase-execution">Three-Phase Execution</a></h3>
<p>The engine executes projections in three phases, corresponding to the projection mechanism:</p>
<h4 id="phase-1-query-evaluation-identification"><a class="header" href="#phase-1-query-evaluation-identification">Phase 1: Query Evaluation (Identification)</a></h4>
<p>The engine evaluates query criteria from the projection definition against the container store.</p>
<p>Steps:</p>
<ol>
<li>Parse query specification from projection definition</li>
<li>Apply parameters to customize query</li>
<li>Execute query against store (using store’s query capability)</li>
<li>Receive resource set (CIDs of matching resources)</li>
<li>Validate resource set meets minimum requirements (if specified)</li>
</ol>
<p>Result: A set of CIDs identifying resources to aggregate.</p>
<h4 id="phase-2-reference-traversal-aggregation"><a class="header" href="#phase-2-reference-traversal-aggregation">Phase 2: Reference Traversal (Aggregation)</a></h4>
<p>The engine follows references from the resource set to collect related resources.</p>
<p>Steps:</p>
<ol>
<li>Parse aggregation rules from projection definition</li>
<li>Initialize traversal state (visited set, depth counter)</li>
<li>For each resource in the set:
<ul>
<li>Retrieve resource content from store</li>
<li>Extract CID references from content</li>
<li>Determine which references to follow (based on rules)</li>
<li>Recursively retrieve referenced resources</li>
<li>Track relationships in aggregated graph</li>
</ul>
</li>
<li>Apply depth limits and cycle detection</li>
<li>Validate aggregated resources meet conformance requirements</li>
</ol>
<p>Result: An aggregated resource graph with content and relationships.</p>
<h4 id="phase-3-transformation-structuring"><a class="header" href="#phase-3-transformation-structuring">Phase 3: Transformation (Structuring)</a></h4>
<p>The engine transforms the aggregated graph into container format.</p>
<p>Steps:</p>
<ol>
<li>Parse transformation logic from projection definition</li>
<li>Extract required fields from resources</li>
<li>Combine resources according to structure rules</li>
<li>Apply formatting and encoding conversions</li>
<li>Compute derived values</li>
<li>Order and filter based on container requirements</li>
<li>Validate final container structure</li>
</ol>
<p>Result: A structured container ready for use.</p>
<h3 id="execution-context"><a class="header" href="#execution-context">Execution Context</a></h3>
<p>The engine maintains execution context throughout projection:</p>
<p><strong>Visited Resources</strong>: Set of CIDs already retrieved during traversal, preventing redundant retrieval and cycle detection.</p>
<p><strong>Depth Tracking</strong>: Current traversal depth for enforcing depth limits.</p>
<p><strong>Error State</strong>: Collection of validation failures or constraint violations encountered during execution.</p>
<p><strong>Intermediate Results</strong>: Partial containers or computed values used across phases.</p>
<p><strong>Parameter Bindings</strong>: Resolved parameter values used throughout execution.</p>
<p>Context is isolated per projection—concurrent projections do not share context or interfere with each other.</p>
<h2 id="query-evaluation"><a class="header" href="#query-evaluation">Query Evaluation</a></h2>
<p>The engine delegates query evaluation to the container store’s query capability, but orchestrates the process:</p>
<p><strong>Query Translation</strong>: Convert projection definition’s query specification into store-specific query format.</p>
<p><strong>Query Execution</strong>: Invoke store query, handling pagination or streaming for large result sets.</p>
<p><strong>Result Filtering</strong>: Apply additional filters that the store cannot evaluate (complex content patterns, computed predicates).</p>
<p><strong>Result Validation</strong>: Ensure query results meet cardinality constraints (minimum/maximum resource counts).</p>
<p>The engine abstracts store-specific query details—the same projection definition works with different store implementations that have different query capabilities.</p>
<h2 id="reference-traversal-algorithm"><a class="header" href="#reference-traversal-algorithm">Reference Traversal Algorithm</a></h2>
<p>Reference traversal follows a <strong>controlled graph traversal</strong>:</p>
<pre><code>function traverse(rootCIDs, rules, maxDepth):
    visited = empty set
    toVisit = queue of (CID, depth=0) from rootCIDs
    graph = empty aggregated graph

    while toVisit not empty:
        (cid, depth) = toVisit.dequeue()

        if cid in visited:
            continue
        if depth &gt; maxDepth:
            continue

        visited.add(cid)
        content = store.retrieve(cid)
        graph.addResource(cid, content)

        references = extractReferences(content)
        for refCID in references:
            if shouldFollow(refCID, rules):
                toVisit.enqueue((refCID, depth+1))
                graph.addEdge(cid, refCID)

    return graph
</code></pre>
<p>Key aspects:</p>
<p><strong>Visited Tracking</strong>: Prevents retrieving the same resource multiple times and handles reference cycles.</p>
<p><strong>Depth Limits</strong>: Controls traversal extent, preventing unbounded graph exploration.</p>
<p><strong>Selective Following</strong>: Rules determine which references to follow (by reference type, target resource properties).</p>
<p><strong>Breadth-First</strong>: Queue-based traversal explores resources level by level (though depth-first is also valid).</p>
<h2 id="transformation-pipeline"><a class="header" href="#transformation-pipeline">Transformation Pipeline</a></h2>
<p>Transformation applies a sequence of operations to the aggregated graph:</p>
<p><strong>Extraction</strong>: Select specific resources or fields from the graph.</p>
<p><strong>Combination</strong>: Merge multiple resources into unified structures.</p>
<p><strong>Computation</strong>: Derive values from resource content (counts, aggregations, computed fields).</p>
<p><strong>Formatting</strong>: Convert encodings or representations (JSON to human-readable, binary to text).</p>
<p><strong>Filtering</strong>: Remove resources or fields that don’t meet criteria.</p>
<p><strong>Ordering</strong>: Sort resources by specified properties.</p>
<p>Each operation takes the current intermediate result and produces a new intermediate result, building toward the final container structure.</p>
<h2 id="conformance-validation"><a class="header" href="#conformance-validation">Conformance Validation</a></h2>
<p>During aggregation, the engine validates that resources conform to requirements specified in the projection definition.</p>
<p><strong>Schema Validation</strong>: Resources match expected structure (JSON schema, type definitions).</p>
<p><strong>Cardinality Constraints</strong>: Required resources are present, optional resources handled correctly.</p>
<p><strong>Reference Integrity</strong>: Referenced CIDs exist in the store and are reachable.</p>
<p><strong>Semantic Constraints</strong>: Application-specific rules (version compatibility, naming conventions).</p>
<p>Validation failures:</p>
<ul>
<li><strong>Hard Failures</strong>: Abort projection, return error (missing required resources)</li>
<li><strong>Soft Failures</strong>: Record warning, continue (optional resource not found)</li>
<li><strong>Accumulation</strong>: Collect all failures, report at completion</li>
</ul>
<p>The engine provides detailed error information identifying which resources or constraints failed.</p>
<h2 id="projection-composition-1"><a class="header" href="#projection-composition-1">Projection Composition</a></h2>
<p>The engine handles composed projections where one projection uses another’s results.</p>
<p><strong>Nested Projection</strong>: During Phase 2 (aggregation), encounter a reference that requires sub-projection:</p>
<ol>
<li>Suspend current projection</li>
<li>Initiate sub-projection with referenced projection definition</li>
<li>Execute sub-projection to completion</li>
<li>Incorporate sub-projection result into current aggregated graph</li>
<li>Resume current projection</li>
</ol>
<p><strong>Sequential Projection</strong>: One projection completes, results emitted to store, next projection projects the emitted resources:</p>
<ol>
<li>Execute first projection</li>
<li>Emit results to store</li>
<li>Store returns CIDs of emitted resources</li>
<li>Execute second projection with emitted CIDs as query parameters</li>
<li>Continue chain</li>
</ol>
<p><strong>Parallel Projection</strong>: Multiple projections execute concurrently:</p>
<ol>
<li>Engine spawns multiple execution contexts</li>
<li>Each context executes its projection independently</li>
<li>Contexts do not share state (pure queries, no interference)</li>
<li>Results collected as projections complete</li>
</ol>
<p>Composition enables building complex containers from simple, reusable projection definitions.</p>
<h2 id="caching-and-optimization"><a class="header" href="#caching-and-optimization">Caching and Optimization</a></h2>
<p>The engine can optimize repeated projections:</p>
<p><strong>Result Caching</strong>: Store completed container results, keyed by (projection definition CID, parameters). Repeated identical projections return cached results.</p>
<p><strong>Partial Caching</strong>: Cache intermediate results (query results, aggregated graphs) for reuse in similar projections.</p>
<p><strong>Incremental Evaluation</strong>: For dynamic projections over evolving stores, update previous results with only new/changed resources rather than complete re-evaluation.</p>
<p><strong>Query Planning</strong>: Analyze projection definitions to optimize execution order (evaluate selective queries first, parallelize independent operations).</p>
<p>Caching is transparent—cached projections return identical results to fresh evaluation, just faster.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The engine provides structured error information:</p>
<p><strong>Query Failures</strong>: Store query errors (malformed query, store unavailable).</p>
<p><strong>Retrieval Failures</strong>: Missing CIDs, corrupted resources, access denied.</p>
<p><strong>Validation Failures</strong>: Resources don’t conform to schema or constraints.</p>
<p><strong>Transformation Failures</strong>: Cannot convert format, computation errors, invalid structure.</p>
<p><strong>Resource Errors</strong>: Out of memory, timeout, execution limits exceeded.</p>
<p>Each error includes:</p>
<ul>
<li>Error type and description</li>
<li>Affected resource CIDs</li>
<li>Projection definition context (which phase, which rule)</li>
<li>Suggestions for resolution (if applicable)</li>
</ul>
<p>Errors propagate: sub-projection failures cause parent projection failure, providing complete failure trace.</p>
<h2 id="execution-guarantees"><a class="header" href="#execution-guarantees">Execution Guarantees</a></h2>
<p>The engine provides guarantees:</p>
<p><strong>Purity</strong>: Projections do not modify the store or have side effects. Same input always produces same output.</p>
<p><strong>Isolation</strong>: Concurrent projections do not interfere. Each has independent execution context.</p>
<p><strong>Completeness</strong>: Successful projection returns complete container meeting all conformance requirements. Partial results are not returned.</p>
<p><strong>Determinism</strong>: Given identical store state and parameters, projection produces identical results.</p>
<p><strong>Atomicity</strong>: Projection either completes successfully or fails cleanly. No partial state persists.</p>
<p>These guarantees enable reliable reasoning about projections and composing them confidently.</p>
<h2 id="engine-architecture"><a class="header" href="#engine-architecture">Engine Architecture</a></h2>
<p>The engine consists of modular components:</p>
<p><strong>Definition Parser</strong>: Reads projection definition resources, validates syntax, produces executable representation.</p>
<p><strong>Query Executor</strong>: Translates and executes queries against store, handles results.</p>
<p><strong>Traversal Manager</strong>: Implements reference traversal algorithm, manages visited tracking and depth limits.</p>
<p><strong>Transformation Engine</strong>: Applies transformation pipeline, validates intermediate results.</p>
<p><strong>Conformance Validator</strong>: Checks resources against schemas and constraints.</p>
<p><strong>Context Manager</strong>: Maintains execution context, handles error state, provides telemetry.</p>
<p><strong>Composition Coordinator</strong>: Manages nested and sequential projections, tracks dependencies.</p>
<p>Components interact through well-defined interfaces, enabling implementations in different languages or with different optimization strategies.</p>
<h2 id="engine-implementation-independence"><a class="header" href="#engine-implementation-independence">Engine Implementation Independence</a></h2>
<p>Like the container store, the projection engine is defined by its behavior, not implementation.</p>
<p>Valid engine implementations might:</p>
<ul>
<li>Interpret projection definitions directly (interpreter)</li>
<li>Compile projection definitions to native code (compiler)</li>
<li>Distribute execution across multiple nodes (distributed engine)</li>
<li>Specialize for specific projection types (optimizing engine)</li>
</ul>
<p>The platform works identically with any conforming engine implementation.</p>
<h2 id="meta-projections"><a class="header" href="#meta-projections">Meta-Projections</a></h2>
<p>The engine can project its own projection definitions—examining, analyzing, or transforming them.</p>
<p><strong>Projection Analysis</strong>: Project all projection definitions, analyze query patterns, identify optimization opportunities.</p>
<p><strong>Projection Validation</strong>: Project projection definitions, validate they’re well-formed and reference valid resources.</p>
<p><strong>Projection Composition</strong>: Project multiple projection definitions, synthesize new composed projection definition.</p>
<p>This reflexivity enables the platform to reason about and improve its own projection capabilities.</p>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>The projection engine interprets projection definitions written in the <strong>projection language</strong>. The next document describes this language—how conformance requirements specify projection instructions, and how projections are defined as resources in the store.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-projection-language"><a class="header" href="#the-projection-language">The Projection Language</a></h1>
<h2 id="conformance-as-projection-instructions"><a class="header" href="#conformance-as-projection-instructions">Conformance as Projection Instructions</a></h2>
<p>The <strong>projection language</strong> is how projections are defined as resources in the container store. What appears as “conformance requirements” in component definitions is actually a <strong>declarative language</strong> for specifying how to project resources into containers.</p>
<p>This document describes the projection language—its syntax, semantics, and how conformance requirements serve as projection instructions.</p>
<h2 id="the-conformance-model"><a class="header" href="#the-conformance-model">The Conformance Model</a></h2>
<p>Traditional systems use conformance for validation: “does this data match this schema?”</p>
<p>Hologram inverts this: <strong>conformance defines how to project</strong>. A conformance requirement specifies:</p>
<ul>
<li>What resources to identify</li>
<li>How to aggregate related resources</li>
<li>What structure the resulting container must have</li>
<li>What transformations to apply</li>
</ul>
<p>Conformance requirements are <strong>projection instructions</strong> interpreted by the projection engine to produce containers.</p>
<h2 id="projection-definition-structure"><a class="header" href="#projection-definition-structure">Projection Definition Structure</a></h2>
<p>A projection definition is a resource containing:</p>
<p><strong>Identity</strong>: The projection type and namespace (e.g., “hologram.component”, “hologram.interface”).</p>
<p><strong>Query Specification</strong>: Criteria for identifying resources to project.</p>
<p><strong>Conformance Requirements</strong>: Rules for aggregating and structuring resources into containers.</p>
<p><strong>Schema Definitions</strong>: Expected structure for aggregated resources (JSON schemas, type definitions).</p>
<p><strong>Transformation Rules</strong>: How to convert aggregated resources into final container format.</p>
<p><strong>Metadata</strong>: Versioning, documentation, dependencies on other projection definitions.</p>
<p>The definition itself is stored in the container store, identified by CID. Different versions of a projection definition have different CIDs.</p>
<h2 id="query-specification"><a class="header" href="#query-specification">Query Specification</a></h2>
<p>The query specification identifies which resources to project.</p>
<h3 id="namespace-queries"><a class="header" href="#namespace-queries">Namespace Queries</a></h3>
<p>Resources are often organized by <strong>namespace</strong>—a hierarchical naming scheme embedded in resource content.</p>
<p>A namespace query identifies resources belonging to a specific namespace:</p>
<ul>
<li>“hologram.component” → all component definition resources</li>
<li>“hologram.interface” → all interface resources</li>
<li>“application.user” → application-specific user resources</li>
</ul>
<p>The engine queries the store for resources with matching namespace fields.</p>
<h3 id="content-pattern-queries"><a class="header" href="#content-pattern-queries">Content Pattern Queries</a></h3>
<p>Queries can match resource content patterns:</p>
<ul>
<li>Resources containing specific fields</li>
<li>Resources with field values matching predicates</li>
<li>Resources matching text patterns</li>
<li>Resources of specific content types (JSON, binary, text)</li>
</ul>
<p>Content pattern queries enable flexible resource identification beyond namespace conventions.</p>
<h3 id="reference-queries"><a class="header" href="#reference-queries">Reference Queries</a></h3>
<p>Queries can identify resources based on reference relationships:</p>
<ul>
<li>Resources referenced by a known resource</li>
<li>Resources that reference a known resource</li>
<li>Resources transitively reachable from a starting point</li>
<li>Resources forming specific graph patterns</li>
</ul>
<p>Reference queries enable graph-based resource selection.</p>
<h3 id="temporal-queries"><a class="header" href="#temporal-queries">Temporal Queries</a></h3>
<p>Queries can include temporal constraints:</p>
<ul>
<li>Resources stored within a time range</li>
<li>Resources as they existed at a specific point in time</li>
<li>Resources modified after a certain timestamp</li>
</ul>
<p>Temporal queries enable historical projections and time-travel.</p>
<h3 id="composite-queries"><a class="header" href="#composite-queries">Composite Queries</a></h3>
<p>Queries can combine multiple criteria:</p>
<ul>
<li>Namespace AND content pattern</li>
<li>Reference relationship OR namespace</li>
<li>Temporal constraint AND content pattern</li>
</ul>
<p>Boolean composition enables precise resource identification.</p>
<h2 id="conformance-requirements"><a class="header" href="#conformance-requirements">Conformance Requirements</a></h2>
<p>Conformance requirements define how to aggregate and structure identified resources.</p>
<h3 id="required-resources"><a class="header" href="#required-resources">Required Resources</a></h3>
<p>Specify resources that <strong>must</strong> be present for valid projection:</p>
<p>A component conformance requirement might specify:</p>
<ul>
<li>“spec” resource (component specification)</li>
<li>“interface” resource (interface definition)</li>
</ul>
<p>Missing required resources cause projection failure.</p>
<h3 id="optional-resources"><a class="header" href="#optional-resources">Optional Resources</a></h3>
<p>Specify resources that <strong>may</strong> be present:</p>
<p>A component might have:</p>
<ul>
<li>Optional “documentation” resource</li>
<li>Optional “examples” resource</li>
</ul>
<p>Missing optional resources do not cause failure but affect container structure.</p>
<h3 id="cardinality-constraints"><a class="header" href="#cardinality-constraints">Cardinality Constraints</a></h3>
<p>Specify how many of each resource type:</p>
<ul>
<li>Exactly one: “spec” (1)</li>
<li>One or more: “tests” (1..n)</li>
<li>Zero or more: “dependencies” (0..n)</li>
<li>Zero or one: “documentation” (0..1)</li>
</ul>
<p>Cardinality violations cause projection failure.</p>
<h3 id="reference-requirements"><a class="header" href="#reference-requirements">Reference Requirements</a></h3>
<p>Specify how resources must reference each other:</p>
<p>An interface conformance requirement might specify:</p>
<ul>
<li>Must reference a “component” (parent relationship)</li>
<li>Must be referenced by component’s “interface” field (consistency)</li>
</ul>
<p>Reference requirements ensure graph structure integrity.</p>
<h3 id="schema-requirements"><a class="header" href="#schema-requirements">Schema Requirements</a></h3>
<p>Specify structure for each resource type:</p>
<p>Each required or optional resource has an associated schema (often JSON Schema) defining:</p>
<ul>
<li>Required and optional fields</li>
<li>Field types and formats</li>
<li>Valid value ranges</li>
<li>Structural constraints</li>
</ul>
<p>Resources that don’t match schemas cause validation failure.</p>
<h3 id="semantic-requirements"><a class="header" href="#semantic-requirements">Semantic Requirements</a></h3>
<p>Specify application-specific constraints:</p>
<ul>
<li>Naming conventions (namespace follows pattern)</li>
<li>Version compatibility (dependencies at compatible versions)</li>
<li>Uniqueness (no duplicate names within namespace)</li>
<li>Business rules (specific field relationships)</li>
</ul>
<p>Semantic requirements are evaluated during aggregation or transformation.</p>
<h2 id="transformation-rules"><a class="header" href="#transformation-rules">Transformation Rules</a></h2>
<p>Transformation rules specify how aggregated resources become the final container structure.</p>
<h3 id="field-extraction"><a class="header" href="#field-extraction">Field Extraction</a></h3>
<p>Extract specific fields from resources:</p>
<ul>
<li>From “spec” resource, extract “namespace”, “version”, “description”</li>
<li>From “interface” resource, extract “methods”</li>
</ul>
<p>Extracted fields populate container properties.</p>
<h3 id="resource-combination"><a class="header" href="#resource-combination">Resource Combination</a></h3>
<p>Combine multiple resources into unified structure:</p>
<ul>
<li>Merge all “test” resources into “tests” array</li>
<li>Combine “documentation” resources by section</li>
</ul>
<p>Combination creates hierarchical container structure.</p>
<h3 id="computed-fields"><a class="header" href="#computed-fields">Computed Fields</a></h3>
<p>Derive values from resource content:</p>
<ul>
<li>Count of dependencies</li>
<li>Hash of concatenated test resources</li>
<li>Latest timestamp across all resources</li>
</ul>
<p>Computed fields add metadata to containers.</p>
<h3 id="format-conversion"><a class="header" href="#format-conversion">Format Conversion</a></h3>
<p>Convert resource encodings:</p>
<ul>
<li>Binary to base64 text</li>
<li>JSON to human-readable formatted text</li>
<li>Markdown to HTML</li>
</ul>
<p>Format conversion adapts resources to container requirements.</p>
<h3 id="ordering-and-filtering"><a class="header" href="#ordering-and-filtering">Ordering and Filtering</a></h3>
<p>Order resources by property (alphabetically, by timestamp, by dependency order).</p>
<p>Filter resources by criteria (exclude deprecated, include only active).</p>
<p>Ordering and filtering refine container contents.</p>
<h2 id="parameterized-projections"><a class="header" href="#parameterized-projections">Parameterized Projections</a></h2>
<p>Projection definitions can include parameters that customize behavior at execution time.</p>
<h3 id="parameter-declaration"><a class="header" href="#parameter-declaration">Parameter Declaration</a></h3>
<p>Define parameters the projection accepts:</p>
<ul>
<li>“namespace” (string): Which namespace to project</li>
<li>“include_optional” (boolean): Whether to include optional resources</li>
<li>“max_depth” (integer): Maximum reference traversal depth</li>
</ul>
<p>Parameters are declared in the projection definition with types and constraints.</p>
<h3 id="parameter-binding"><a class="header" href="#parameter-binding">Parameter Binding</a></h3>
<p>At execution time, the engine binds parameter values:</p>
<ul>
<li>From client request (explicit parameter values)</li>
<li>From context (environment variables, user identity)</li>
<li>From defaults (declared in projection definition)</li>
</ul>
<p>Bound parameters are substituted into query specification and transformation rules.</p>
<h3 id="parameterized-queries"><a class="header" href="#parameterized-queries">Parameterized Queries</a></h3>
<p>Parameters customize queries:</p>
<p>Instead of hard-coding “hologram.component”, parameterize as “{namespace}”.</p>
<p>At execution, “{namespace}” is replaced with the bound value.</p>
<p>This enables reusing projection definitions across different namespaces.</p>
<h3 id="conditional-rules"><a class="header" href="#conditional-rules">Conditional Rules</a></h3>
<p>Rules can be conditional on parameters:</p>
<p>IF “include_optional” THEN aggregate optional documentation resources.</p>
<p>Conditional rules enable flexible projection behavior.</p>
<h2 id="projection-composition-in-the-language"><a class="header" href="#projection-composition-in-the-language">Projection Composition in the Language</a></h2>
<p>The projection language supports defining composed projections.</p>
<h3 id="sub-projection-references"><a class="header" href="#sub-projection-references">Sub-Projection References</a></h3>
<p>A projection definition can reference other projection definitions:</p>
<p>A component projection might specify:</p>
<ul>
<li>Project “hologram.interface” for interface resources</li>
<li>Project “hologram.documentation” for documentation resources</li>
</ul>
<p>The engine executes sub-projections and incorporates results into the parent projection.</p>
<h3 id="nested-conformance"><a class="header" href="#nested-conformance">Nested Conformance</a></h3>
<p>Conformance requirements can nest:</p>
<p>A component requires:</p>
<ul>
<li>“interface” conforming to “hologram.interface” projection</li>
<li>“documentation” conforming to “hologram.documentation” projection</li>
</ul>
<p>Nested conformance creates projection hierarchies.</p>
<h3 id="projection-inheritance"><a class="header" href="#projection-inheritance">Projection Inheritance</a></h3>
<p>Projection definitions can extend other projection definitions:</p>
<p>“hologram.advanced_component” extends “hologram.component”:</p>
<ul>
<li>Inherits all base requirements</li>
<li>Adds additional requirements</li>
<li>Overrides specific transformation rules</li>
</ul>
<p>Inheritance enables specialization without duplication.</p>
<h2 id="language-semantics"><a class="header" href="#language-semantics">Language Semantics</a></h2>
<h3 id="declarative-nature"><a class="header" href="#declarative-nature">Declarative Nature</a></h3>
<p>The projection language is <strong>declarative</strong>—it describes <strong>what</strong> to project, not <strong>how</strong> to project.</p>
<p>The engine determines execution strategy (query optimization, traversal algorithm, caching).</p>
<p>This enables engine evolution without changing projection definitions.</p>
<h3 id="purity"><a class="header" href="#purity">Purity</a></h3>
<p>Projection definitions are <strong>pure specifications</strong>—they don’t include imperative code with side effects.</p>
<p>No “execute this function”, only “aggregate these resources with these rules”.</p>
<p>Purity enables analysis, optimization, and reasoning about projections.</p>
<h3 id="composability-1"><a class="header" href="#composability-1">Composability</a></h3>
<p>Projections compose cleanly:</p>
<ul>
<li>Reference other projections without tight coupling</li>
<li>Inherit and extend without duplicating logic</li>
<li>Parameterize without creating explosion of variants</li>
</ul>
<p>Composability enables building complex projections from simple components.</p>
<h3 id="versioning"><a class="header" href="#versioning">Versioning</a></h3>
<p>Projection definitions are versioned through CID:</p>
<ul>
<li>New version → new resource → new CID</li>
<li>Old versions remain available (immutability)</li>
<li>Resources can reference specific projection versions</li>
</ul>
<p>Versioning enables evolution without breaking existing projections.</p>
<h2 id="schema-language"><a class="header" href="#schema-language">Schema Language</a></h2>
<p>The projection language includes or references a schema language for defining resource structure.</p>
<h3 id="json-schema-integration"><a class="header" href="#json-schema-integration">JSON Schema Integration</a></h3>
<p>The platform uses JSON Schema as the primary schema language:</p>
<ul>
<li>Mature, widely adopted standard</li>
<li>Rich constraint language</li>
<li>Tool support for validation</li>
</ul>
<p>JSON schemas are resources in the store, referenced by projection definitions.</p>
<h3 id="schema-composition"><a class="header" href="#schema-composition">Schema Composition</a></h3>
<p>Schemas can reference other schemas:</p>
<ul>
<li>Common type definitions shared across schemas</li>
<li>Schema inheritance through “allOf”, “oneOf”</li>
<li>Modular schema construction</li>
</ul>
<p>Schema composition mirrors projection composition.</p>
<h3 id="schema-versioning"><a class="header" href="#schema-versioning">Schema Versioning</a></h3>
<p>Like projection definitions, schemas are versioned via CID.</p>
<p>Projection definitions reference specific schema versions, ensuring stable validation over time.</p>
<h2 id="language-extensions"><a class="header" href="#language-extensions">Language Extensions</a></h2>
<p>The projection language is extensible—new query types, conformance requirements, and transformation rules can be added.</p>
<h3 id="custom-query-types"><a class="header" href="#custom-query-types">Custom Query Types</a></h3>
<p>Define new query types as resources:</p>
<ul>
<li>Graph pattern matching queries</li>
<li>Probabilistic similarity queries</li>
<li>Machine learning-based classification queries</li>
</ul>
<p>The engine loads custom query implementations and applies them.</p>
<h3 id="custom-validators"><a class="header" href="#custom-validators">Custom Validators</a></h3>
<p>Define new validation rules as resources:</p>
<ul>
<li>Application-specific business rules</li>
<li>Cross-resource consistency checks</li>
<li>External system integration (check against external API)</li>
</ul>
<p>Custom validators plug into the conformance validation phase.</p>
<h3 id="custom-transformations"><a class="header" href="#custom-transformations">Custom Transformations</a></h3>
<p>Define new transformations as resources:</p>
<ul>
<li>Domain-specific format conversions</li>
<li>Complex computations (rendering, compilation)</li>
<li>Aggregations specific to application needs</li>
</ul>
<p>Custom transformations extend the transformation pipeline.</p>
<p>Extensions are themselves resources, making the language <strong>self-extensible</strong>.</p>
<h2 id="conformance-as-lens-definition"><a class="header" href="#conformance-as-lens-definition">Conformance as Lens Definition</a></h2>
<p>Viewing conformance as projection instructions reveals its true role:</p>
<p><strong>Traditional View</strong>: “This resource conforms to this schema” (validation).</p>
<p><strong>Hologram View</strong>: “Project resources using these conformance requirements to create this container type” (projection).</p>
<p>Conformance requirements are <strong>lens definitions</strong>—they define how to view the store through a particular lens to see a particular type of container.</p>
<p>Different conformance requirements (lenses) applied to the same resources produce different containers (views).</p>
<h2 id="language-bootstrap"><a class="header" href="#language-bootstrap">Language Bootstrap</a></h2>
<p>The projection language is defined using itself:</p>
<ul>
<li>“hologram.projection” is a projection definition for projecting projection definitions</li>
<li>It specifies how to identify, aggregate, and structure projection definition resources</li>
<li>The engine uses “hologram.projection” to understand projection definitions</li>
</ul>
<p>This self-description enables the language to evolve—new language features are expressed as updates to the “hologram.projection” definition.</p>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>Projections produce containers through the <strong>Project → Execute</strong> phases. The <strong>Emit</strong> phase produces new resources from execution results.</p>
<p>The next document, <strong>The Emission Model</strong>, describes how containers emit resources during execution, what types of emissions occur, and how emissions integrate back into the store for future projections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-emission-model"><a class="header" href="#the-emission-model">The Emission Model</a></h1>
<h2 id="how-containers-emit-resources"><a class="header" href="#how-containers-emit-resources">How Containers Emit Resources</a></h2>
<p><strong>Emission</strong> is the process by which execution results are written back to the container store as new resources. Emissions complete the projection-emission cycle, making execution results available for future projections.</p>
<p>This document describes the emission model—what emissions are, how they work, emission types, and how they integrate into the platform.</p>
<h2 id="what-is-an-emission"><a class="header" href="#what-is-an-emission">What is an Emission?</a></h2>
<p>An <strong>emission</strong> is the creation of a new resource in the container store as a result of executing a projection.</p>
<p>Emissions have these properties:</p>
<p><strong>Content</strong>: The data being emitted (bytes, structured data, references to other resources).</p>
<p><strong>Identity</strong>: The CID computed from the content, uniquely identifying the emission.</p>
<p><strong>Immutability</strong>: Once emitted, the resource never changes (consistent with store immutability).</p>
<p><strong>Addressability</strong>: The emission is immediately available for retrieval and projection via its CID.</p>
<p><strong>Atomicity</strong>: The emission is either fully stored or not stored (no partial emissions).</p>
<p>Emissions transform ephemeral execution results into durable resources.</p>
<h2 id="the-emission-process"><a class="header" href="#the-emission-process">The Emission Process</a></h2>
<h3 id="phase-1-result-generation"><a class="header" href="#phase-1-result-generation">Phase 1: Result Generation</a></h3>
<p>During the <strong>Execute</strong> phase of the projection-emission cycle, operations produce results:</p>
<ul>
<li>Validated component definitions</li>
<li>Instance state snapshots</li>
<li>Log entries</li>
<li>Computed views</li>
<li>Application data</li>
<li>Metadata</li>
</ul>
<p>Results exist initially as ephemeral execution artifacts (in-memory structures, temporary files).</p>
<h3 id="phase-2-serialization"><a class="header" href="#phase-2-serialization">Phase 2: Serialization</a></h3>
<p>Results are <strong>serialized</strong> into a canonical byte representation:</p>
<p><strong>Structured Data</strong>: Converted to canonical JSON (sorted keys, consistent formatting).</p>
<p><strong>Binary Data</strong>: Used as-is (already bytes).</p>
<p><strong>References</strong>: Embedded as CID strings within serialized content.</p>
<p><strong>Metadata</strong>: Included in serialized representation or as separate associated resource.</p>
<p>Serialization produces deterministic byte sequences—the same result always serializes identically.</p>
<h3 id="phase-3-content-addressing"><a class="header" href="#phase-3-content-addressing">Phase 3: Content Addressing</a></h3>
<p>The serialized content is <strong>hashed</strong> to compute the CID:</p>
<ul>
<li>Apply cryptographic hash function (SHA-256 or similar)</li>
<li>Produce fixed-length hash digest</li>
<li>Format as CID (typically “cid:” prefix + hex digest)</li>
</ul>
<p>Content addressing ensures identical content produces identical CIDs (deduplication) and enables integrity verification.</p>
<h3 id="phase-4-storage"><a class="header" href="#phase-4-storage">Phase 4: Storage</a></h3>
<p>The serialized content and CID are <strong>stored</strong> in the container store:</p>
<ul>
<li>Store maps CID to content</li>
<li>Content becomes retrievable via the CID</li>
<li>Store updates indexes and metadata</li>
<li>Reference graph is extended if content contains CID references</li>
</ul>
<p>Once stored, the emission is durable and available for projection.</p>
<h3 id="phase-5-reference-return"><a class="header" href="#phase-5-reference-return">Phase 5: Reference Return</a></h3>
<p>The emission process returns the CID to the caller (the operation that produced the result).</p>
<p>The caller can:</p>
<ul>
<li>Return the CID to the client (for user-initiated operations)</li>
<li>Use the CID in further processing (as input to subsequent projections)</li>
<li>Emit additional resources that reference the new CID</li>
</ul>
<p>Returned CIDs enable chaining—one emission becomes input to the next operation.</p>
<h2 id="emission-types"><a class="header" href="#emission-types">Emission Types</a></h2>
<p>Different operations emit different types of resources.</p>
<h3 id="definition-emissions"><a class="header" href="#definition-emissions">Definition Emissions</a></h3>
<p><strong>Component Definitions</strong>: Results of creating or updating components.</p>
<p>Content:</p>
<ul>
<li>Component specification</li>
<li>References to interface, documentation, tests, dependencies</li>
<li>Version information</li>
<li>Namespace and metadata</li>
</ul>
<p>These emissions define reusable capabilities available for instantiation.</p>
<h3 id="state-emissions"><a class="header" href="#state-emissions">State Emissions</a></h3>
<p><strong>Instance State</strong>: Snapshots of running instance state.</p>
<p>Content:</p>
<ul>
<li>Current variable values</li>
<li>Execution position</li>
<li>Pending tasks</li>
<li>Resource allocations</li>
<li>State timestamp</li>
</ul>
<p>State emissions enable persistence, recovery, and debugging.</p>
<h3 id="log-emissions"><a class="header" href="#log-emissions">Log Emissions</a></h3>
<p><strong>Log Entries</strong>: Records of events during execution.</p>
<p>Content:</p>
<ul>
<li>Timestamp</li>
<li>Log level (info, warning, error)</li>
<li>Message</li>
<li>Context (operation, resource, user)</li>
<li>References to related resources</li>
</ul>
<p>Log emissions provide observability and audit trails.</p>
<h3 id="data-emissions"><a class="header" href="#data-emissions">Data Emissions</a></h3>
<p><strong>Application Data</strong>: User content, computed results, generated artifacts.</p>
<p>Content:</p>
<ul>
<li>Application-specific structured data</li>
<li>Files or binary artifacts</li>
<li>User input or user-generated content</li>
<li>Computed aggregations or transformations</li>
</ul>
<p>Data emissions are the primary output of running instances.</p>
<h3 id="view-emissions"><a class="header" href="#view-emissions">View Emissions</a></h3>
<p><strong>Materialized Views</strong>: Pre-computed projections stored for efficient access.</p>
<p>Content:</p>
<ul>
<li>Query results</li>
<li>Aggregated resources</li>
<li>Transformed representations</li>
<li>View metadata (freshness timestamp, query parameters)</li>
</ul>
<p>View emissions optimize repeated queries.</p>
<h3 id="metadata-emissions"><a class="header" href="#metadata-emissions">Metadata Emissions</a></h3>
<p><strong>Operational Metadata</strong>: Information about operations themselves.</p>
<p>Content:</p>
<ul>
<li>Operation start/end timestamps</li>
<li>Resources projected during operation</li>
<li>Execution duration</li>
<li>Success/failure status</li>
<li>Error details</li>
</ul>
<p>Metadata emissions enable monitoring and analysis.</p>
<h2 id="emission-streams"><a class="header" href="#emission-streams">Emission Streams</a></h2>
<p>Some operations produce <strong>continuous emissions</strong> rather than single emissions.</p>
<p><strong>Running Instances</strong>: Emit logs, state snapshots, and application data continuously while running.</p>
<p><strong>Live Views</strong>: Emit updated view resources as underlying resources change.</p>
<p><strong>Event Streams</strong>: Emit event resources as events occur (user actions, external triggers).</p>
<p>Emission streams are sequences of individual emissions, each producing a distinct resource with distinct CID.</p>
<h3 id="buffering-and-batching"><a class="header" href="#buffering-and-batching">Buffering and Batching</a></h3>
<p>High-frequency emission streams may use buffering:</p>
<ul>
<li>Collect multiple emission candidates in memory</li>
<li>Batch serialize and store together</li>
<li>Reduce store overhead from individual tiny emissions</li>
</ul>
<p>Batching is transparent—logically each emission is distinct, even if physically stored in a batch.</p>
<h3 id="stream-termination"><a class="header" href="#stream-termination">Stream Termination</a></h3>
<p>Emission streams terminate when:</p>
<ul>
<li>Instance stops (graceful or forced)</li>
<li>View subscription is cancelled</li>
<li>Event source is closed</li>
</ul>
<p>Termination may produce a final emission marking stream completion.</p>
<h2 id="emission-references"><a class="header" href="#emission-references">Emission References</a></h2>
<p>Emitted resources can reference other resources via CID references.</p>
<p><strong>Parent References</strong>: A log emission references the instance that produced it.</p>
<p><strong>Dependency References</strong>: A component definition references interface and documentation resources.</p>
<p><strong>Sequential References</strong>: A new component version references the previous version.</p>
<p><strong>Aggregation References</strong>: A view emission references all resources it aggregated.</p>
<p>References form the resource graph, enabling:</p>
<ul>
<li>Tracing relationships (find all logs for an instance)</li>
<li>Versioning (follow version chains)</li>
<li>Garbage collection (determine reachability)</li>
</ul>
<h2 id="emission-deduplication"><a class="header" href="#emission-deduplication">Emission Deduplication</a></h2>
<p>If emitted content is identical to an existing resource, the existing CID is returned without storing duplicate content.</p>
<p>This occurs naturally from content addressing:</p>
<ol>
<li>Serialize result</li>
<li>Compute CID</li>
<li>Check if CID exists in store</li>
<li>If yes, return existing CID (no storage needed)</li>
<li>If no, store content and return new CID</li>
</ol>
<p>Deduplication is automatic and transparent—callers always receive correct CID regardless of whether content was newly stored or already existed.</p>
<h2 id="emission-validation"><a class="header" href="#emission-validation">Emission Validation</a></h2>
<p>Before emitting, the platform may validate that the result conforms to expected structure:</p>
<p><strong>Schema Validation</strong>: Ensure emitted resource matches schema for its type.</p>
<p><strong>Reference Integrity</strong>: Ensure referenced CIDs exist in the store.</p>
<p><strong>Constraint Satisfaction</strong>: Ensure business rules or semantic constraints are met.</p>
<p>Validation failures prevent emission—invalid resources are not stored. The operation reports error and can retry or abort.</p>
<h2 id="emission-atomicity"><a class="header" href="#emission-atomicity">Emission Atomicity</a></h2>
<p>Emissions are atomic operations:</p>
<p><strong>All-or-Nothing</strong>: Content is either fully stored and indexed, or not stored at all (no partial writes).</p>
<p><strong>Consistent State</strong>: Store remains consistent whether emission succeeds or fails.</p>
<p><strong>Isolation</strong>: Concurrent emissions don’t interfere—each produces independent resource.</p>
<p>Atomicity enables reliable reasoning: if emission succeeds, the resource is available and correctly formed.</p>
<h2 id="emission-transactions"><a class="header" href="#emission-transactions">Emission Transactions</a></h2>
<p>Operations that emit multiple related resources can use <strong>emission transactions</strong>:</p>
<ol>
<li>Prepare all resources to emit</li>
<li>Compute all CIDs</li>
<li>Validate all resources</li>
<li>Store all resources atomically</li>
<li>Update store indexes</li>
</ol>
<p>If any resource fails validation, the entire transaction aborts—no resources are emitted.</p>
<p>Transactions ensure related resources appear together (component definition with all conformance resources) or not at all.</p>
<h2 id="emission-idempotence"><a class="header" href="#emission-idempotence">Emission Idempotence</a></h2>
<p>Repeating an emission operation with identical input produces identical output:</p>
<ul>
<li>Same result content</li>
<li>Same CID</li>
<li>Store state unchanged (deduplication)</li>
</ul>
<p>Idempotence enables safe retries after failures—re-emitting is harmless.</p>
<h2 id="emission-observability"><a class="header" href="#emission-observability">Emission Observability</a></h2>
<p>The platform provides visibility into emissions:</p>
<p><strong>Emission Logs</strong>: Record of what was emitted, when, by what operation.</p>
<p><strong>Emission Metrics</strong>: Count of emissions, size distribution, emission rate.</p>
<p><strong>Emission Traces</strong>: Which projections led to which emissions (operation chains).</p>
<p>Observability helps understand platform behavior and debug issues.</p>
<h2 id="emissions-as-first-class-resources"><a class="header" href="#emissions-as-first-class-resources">Emissions as First-Class Resources</a></h2>
<p>Emitted resources are indistinguishable from any other resources in the store:</p>
<ul>
<li>Same content addressing</li>
<li>Same immutability</li>
<li>Same projectionability</li>
<li>Same lifecycle</li>
</ul>
<p>There is no special “emission” type—emissions simply add resources to the store.</p>
<p>This uniformity means:</p>
<ul>
<li>Emissions can be projected like any resources</li>
<li>Emissions can reference and be referenced by any resources</li>
<li>Platform and application emissions are treated identically</li>
</ul>
<h2 id="the-feedback-loop"><a class="header" href="#the-feedback-loop">The Feedback Loop</a></h2>
<p>Emissions create a feedback loop:</p>
<ol>
<li><strong>Project</strong> resources from store</li>
<li><strong>Execute</strong> operation on projected resources</li>
<li><strong>Emit</strong> results as new resources to store</li>
<li>New resources become available for projection</li>
<li>Future projections include newly emitted resources</li>
<li><strong>Repeat</strong></li>
</ol>
<p>Each cycle enriches the store. Over time:</p>
<ul>
<li>More components → more operations possible</li>
<li>More logs → better observability</li>
<li>More state → more sophisticated recovery</li>
<li>More views → more efficient queries</li>
</ul>
<p>The feedback loop makes the platform <strong>generative</strong>—it becomes more capable through use.</p>
<h2 id="emission-policies"><a class="header" href="#emission-policies">Emission Policies</a></h2>
<p>The platform may define policies governing emissions:</p>
<p><strong>Retention</strong>: How long emissions persist before garbage collection.</p>
<p><strong>Rate Limits</strong>: Maximum emission rate to prevent store overload.</p>
<p><strong>Size Limits</strong>: Maximum size of individual emissions.</p>
<p><strong>Access Control</strong>: Who can emit what types of resources.</p>
<p><strong>Schema Requirements</strong>: What schemas emissions must conform to.</p>
<p>Policies ensure store health and enforce organizational requirements.</p>
<h2 id="emission-patterns"><a class="header" href="#emission-patterns">Emission Patterns</a></h2>
<p>Common emission patterns across operations:</p>
<p><strong>Create-Emit</strong>: Create new resource, emit immediately (component creation).</p>
<p><strong>Accumulate-Emit</strong>: Collect results over time, emit periodically (batched logs).</p>
<p><strong>Transform-Emit</strong>: Project resources, transform, emit result (view materialization).</p>
<p><strong>Trigger-Emit</strong>: External event triggers emission (user action creates data).</p>
<p><strong>Replicate-Emit</strong>: Emit copy of resource from another store (synchronization).</p>
<p>Patterns provide templates for implementing new operations.</p>
<h2 id="emission-and-versioning"><a class="header" href="#emission-and-versioning">Emission and Versioning</a></h2>
<p>Every emission creates a new version:</p>
<ul>
<li>New component definition with changes → new CID, new version</li>
<li>Updated instance state → new CID, new state snapshot</li>
<li>Refreshed view → new CID, new view version</li>
</ul>
<p>Old versions remain in store (immutability). Version history is automatically preserved through distinct CIDs.</p>
<p>Clients can reference specific versions (by CID) or request “latest” (projection query for most recent by timestamp).</p>
<h2 id="emission-performance"><a class="header" href="#emission-performance">Emission Performance</a></h2>
<p>Emission performance depends on:</p>
<p><strong>Serialization Cost</strong>: Time to convert results to bytes.</p>
<p><strong>Hashing Cost</strong>: Time to compute CID.</p>
<p><strong>Store Write Latency</strong>: Time for store to persist and index resource.</p>
<p><strong>Validation Cost</strong>: Time to validate before emission.</p>
<p>Optimization strategies:</p>
<ul>
<li>Efficient serialization formats</li>
<li>Fast hash algorithms</li>
<li>Asynchronous store writes (return CID before write completes)</li>
<li>Batch emissions</li>
</ul>
<p>High emission rate is critical for interactive applications and streaming data.</p>
<h2 id="contrast-with-traditional-systems-1"><a class="header" href="#contrast-with-traditional-systems-1">Contrast with Traditional Systems</a></h2>
<p>Traditional systems separate computation output from storage:</p>
<ul>
<li>Computation produces results</li>
<li>Separate storage operation writes results to database/filesystem</li>
<li>Multiple result formats (database rows, files, caches)</li>
</ul>
<p>Hologram unifies:</p>
<ul>
<li>Emission is the canonical output mechanism</li>
<li>Emitted resources are immediately storable and projectable</li>
<li>Single format (content-addressed resources)</li>
</ul>
<p>Unification simplifies the platform—everything flows through the same mechanism.</p>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<p>With the projection engine executing projections and the emission model creating new resources, the platform provides a complete cycle for operations.</p>
<p>The next section, Part III: The Platform, describes the <strong>Container Types</strong> provided by the platform—the specific projection definitions and emission patterns for components, instances, interfaces, documentation, tests, views, and more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-types"><a class="header" href="#container-types">Container Types</a></h1>
<h2 id="platform-container-types-and-emissions"><a class="header" href="#platform-container-types-and-emissions">Platform Container Types and Emissions</a></h2>
<p>The Hologram platform provides <strong>base container types</strong>—projection definitions and associated operations for common containment patterns. Container types define how resources are projected into containers and what emissions those containers produce.</p>
<p>This document describes the platform’s base container types, their projection patterns, and emission characteristics.</p>
<h2 id="container-type-fundamentals"><a class="header" href="#container-type-fundamentals">Container Type Fundamentals</a></h2>
<p>A <strong>container type</strong> is defined by:</p>
<p><strong>Projection Definition</strong>: The conformance requirements and transformation rules for projecting resources into this container type.</p>
<p><strong>Required Resources</strong>: What resources must be present for valid containers of this type.</p>
<p><strong>Optional Resources</strong>: What resources may be included but aren’t mandatory.</p>
<p><strong>Emission Pattern</strong>: What resources containers of this type emit during their lifecycle.</p>
<p><strong>Operations</strong>: What operations can be performed with containers of this type.</p>
<p>Container types are defined as resources in the store (projection definitions), making them extensible—new container types are added by emitting new projection definitions.</p>
<h2 id="component-containers"><a class="header" href="#component-containers">Component Containers</a></h2>
<p><strong>Purpose</strong>: Define reusable capabilities as specifications.</p>
<h3 id="projection-pattern"><a class="header" href="#projection-pattern">Projection Pattern</a></h3>
<p><strong>Query</strong>: Identify resources with component namespace (e.g., “hologram.component”, “application.service”).</p>
<p><strong>Required Resources</strong>:</p>
<ul>
<li><strong>Spec</strong>: Component specification (namespace, version, description, metadata)</li>
</ul>
<p><strong>Optional Resources</strong>:</p>
<ul>
<li><strong>Interface</strong>: Interface definition resources</li>
<li><strong>Documentation</strong>: Human-readable documentation resources</li>
<li><strong>Tests</strong>: Test suite resources</li>
<li><strong>Dependencies</strong>: References to other components required</li>
<li><strong>Build</strong>: Build process definition</li>
<li><strong>Manager</strong>: Lifecycle management definition</li>
</ul>
<p><strong>Aggregation</strong>: Follow references from spec to collect all related resources.</p>
<p><strong>Transformation</strong>: Structure into hierarchical component definition with spec as root, related resources as branches.</p>
<h3 id="emission-pattern"><a class="header" href="#emission-pattern">Emission Pattern</a></h3>
<p><strong>Creation</strong>: Emit component definition resource containing spec and references to all conformance resources.</p>
<p><strong>Update</strong>: Emit new component definition resource with updated content (new CID, immutable versioning).</p>
<p><strong>Deletion Marker</strong>: Emit resource marking component as deprecated or deleted (original definition remains for history).</p>
<h3 id="characteristics"><a class="header" href="#characteristics">Characteristics</a></h3>
<ul>
<li><strong>Immutable</strong>: Once created, component definitions don’t change (updates create new versions)</li>
<li><strong>Versioned</strong>: Each update produces new CID, creating version chain</li>
<li><strong>Reusable</strong>: Can be referenced by multiple instances or other components</li>
<li><strong>Self-Describing</strong>: Contains all information needed to understand and use the component</li>
</ul>
<h2 id="instance-containers"><a class="header" href="#instance-containers">Instance Containers</a></h2>
<p><strong>Purpose</strong>: Execute component definitions with runtime state.</p>
<h3 id="projection-pattern-1"><a class="header" href="#projection-pattern-1">Projection Pattern</a></h3>
<p><strong>Query</strong>: Identify resources with instance identifier (references specific component definition and instance ID).</p>
<p><strong>Required Resources</strong>:</p>
<ul>
<li><strong>Component Reference</strong>: CID of component definition to instantiate</li>
<li><strong>Instance Identity</strong>: Unique identifier for this instance</li>
</ul>
<p><strong>Optional Resources</strong>:</p>
<ul>
<li><strong>Initial State</strong>: Starting state for the instance</li>
<li><strong>Configuration</strong>: Instance-specific configuration overriding defaults</li>
<li><strong>Context</strong>: Runtime environment information</li>
</ul>
<p><strong>Aggregation</strong>: Project component definition, then collect instance-specific resources.</p>
<p><strong>Transformation</strong>: Combine component definition with instance state/config into executable instance container.</p>
<h3 id="emission-pattern-1"><a class="header" href="#emission-pattern-1">Emission Pattern</a></h3>
<p><strong>Initialization</strong>: Emit initial instance state resource.</p>
<p><strong>Runtime</strong>: Continuous emission stream while running:</p>
<ul>
<li><strong>State Snapshots</strong>: Periodic or event-triggered state captures</li>
<li><strong>Log Entries</strong>: Events, errors, info messages</li>
<li><strong>Application Data</strong>: Output produced by instance execution</li>
<li><strong>Metrics</strong>: Performance and resource utilization data</li>
</ul>
<p><strong>Termination</strong>: Emit final state and shutdown logs when instance stops.</p>
<h3 id="characteristics-1"><a class="header" href="#characteristics-1">Characteristics</a></h3>
<ul>
<li><strong>Stateful</strong>: Maintains evolving state over time through emissions</li>
<li><strong>Ephemeral</strong>: Can be started, stopped, removed (though emissions persist)</li>
<li><strong>Observable</strong>: Continuous emission stream provides visibility</li>
<li><strong>Recoverable</strong>: State snapshots enable restart from last known state</li>
</ul>
<h2 id="interface-containers"><a class="header" href="#interface-containers">Interface Containers</a></h2>
<p><strong>Purpose</strong>: Define contracts between components.</p>
<h3 id="projection-pattern-2"><a class="header" href="#projection-pattern-2">Projection Pattern</a></h3>
<p><strong>Query</strong>: Identify interface definition resources (often by namespace or referenced by component).</p>
<p><strong>Required Resources</strong>:</p>
<ul>
<li><strong>Interface Specification</strong>: Methods, parameters, return types, error conditions</li>
</ul>
<p><strong>Optional Resources</strong>:</p>
<ul>
<li><strong>Schema Definitions</strong>: Type definitions for parameters/returns</li>
<li><strong>Documentation</strong>: Description of interface semantics</li>
<li><strong>Examples</strong>: Usage examples</li>
</ul>
<p><strong>Aggregation</strong>: Collect interface spec and related type/schema resources.</p>
<p><strong>Transformation</strong>: Structure into interface definition with methods and types clearly defined.</p>
<h3 id="emission-pattern-2"><a class="header" href="#emission-pattern-2">Emission Pattern</a></h3>
<p><strong>Definition</strong>: Emit interface definition resource.</p>
<p><strong>Versioning</strong>: Emit new interface versions (semantic versioning for compatibility tracking).</p>
<p><strong>Conformance Validation</strong>: Implementations emit validation resources demonstrating conformance to interface.</p>
<h3 id="characteristics-2"><a class="header" href="#characteristics-2">Characteristics</a></h3>
<ul>
<li><strong>Contract-Defining</strong>: Specifies expectations between components</li>
<li><strong>Versioned</strong>: Interface evolution tracked through versions</li>
<li><strong>Reusable</strong>: Multiple components can implement same interface</li>
<li><strong>Validation-Enabling</strong>: Enables checking component compatibility</li>
</ul>
<h2 id="documentation-containers"><a class="header" href="#documentation-containers">Documentation Containers</a></h2>
<p><strong>Purpose</strong>: Provide human-readable explanations and guides.</p>
<h3 id="projection-pattern-3"><a class="header" href="#projection-pattern-3">Projection Pattern</a></h3>
<p><strong>Query</strong>: Identify documentation resources (by namespace, by reference from components).</p>
<p><strong>Required Resources</strong>:</p>
<ul>
<li><strong>Documentation Content</strong>: Markdown, HTML, or other human-readable format</li>
</ul>
<p><strong>Optional Resources</strong>:</p>
<ul>
<li><strong>Examples</strong>: Code examples, usage demonstrations</li>
<li><strong>Diagrams</strong>: Visual representations</li>
<li><strong>Cross-References</strong>: Links to related documentation</li>
</ul>
<p><strong>Aggregation</strong>: Collect documentation resources and related examples/diagrams.</p>
<p><strong>Transformation</strong>: Structure into navigable documentation with sections, cross-references resolved.</p>
<h3 id="emission-pattern-3"><a class="header" href="#emission-pattern-3">Emission Pattern</a></h3>
<p><strong>Creation</strong>: Emit documentation resource.</p>
<p><strong>Updates</strong>: Emit updated documentation (versioned with component versions).</p>
<p><strong>Rendered Views</strong>: Emit transformed formats (HTML from Markdown, PDF from LaTeX).</p>
<h3 id="characteristics-3"><a class="header" href="#characteristics-3">Characteristics</a></h3>
<ul>
<li><strong>Human-Oriented</strong>: Designed for human consumption, not machine execution</li>
<li><strong>Cross-Linked</strong>: References other documentation, components, interfaces</li>
<li><strong>Multi-Format</strong>: Can be projected into different representations</li>
<li><strong>Versioned</strong>: Evolves with component versions</li>
</ul>
<h2 id="test-containers"><a class="header" href="#test-containers">Test Containers</a></h2>
<p><strong>Purpose</strong>: Validate component behavior and correctness.</p>
<h3 id="projection-pattern-4"><a class="header" href="#projection-pattern-4">Projection Pattern</a></h3>
<p><strong>Query</strong>: Identify test resources (by namespace, by component reference).</p>
<p><strong>Required Resources</strong>:</p>
<ul>
<li><strong>Test Cases</strong>: Individual test definitions (inputs, expected outputs, assertions)</li>
</ul>
<p><strong>Optional Resources</strong>:</p>
<ul>
<li><strong>Test Fixtures</strong>: Shared setup/teardown logic</li>
<li><strong>Test Data</strong>: Input datasets for tests</li>
<li><strong>Validation Rules</strong>: Expected behavior specifications</li>
</ul>
<p><strong>Aggregation</strong>: Collect test cases, fixtures, and data into test suite.</p>
<p><strong>Transformation</strong>: Structure into executable test suite.</p>
<h3 id="emission-pattern-4"><a class="header" href="#emission-pattern-4">Emission Pattern</a></h3>
<p><strong>Suite Execution</strong>: Emit test results:</p>
<ul>
<li><strong>Pass/Fail Status</strong>: Per-test and overall results</li>
<li><strong>Execution Logs</strong>: Details of test execution</li>
<li><strong>Coverage Data</strong>: What code/behavior was tested</li>
<li><strong>Performance Metrics</strong>: Test execution time</li>
</ul>
<p><strong>Continuous Testing</strong>: Emit updated test results as tests re-run.</p>
<h3 id="characteristics-4"><a class="header" href="#characteristics-4">Characteristics</a></h3>
<ul>
<li><strong>Executable</strong>: Test containers run to produce results</li>
<li><strong>Validation-Focused</strong>: Purpose is to verify correctness</li>
<li><strong>Evolving</strong>: New tests added as components evolve</li>
<li><strong>Result-Producing</strong>: Emissions are test outcomes</li>
</ul>
<h2 id="manager-containers"><a class="header" href="#manager-containers">Manager Containers</a></h2>
<p><strong>Purpose</strong>: Control lifecycle of instances and components.</p>
<h3 id="projection-pattern-5"><a class="header" href="#projection-pattern-5">Projection Pattern</a></h3>
<p><strong>Query</strong>: Identify manager definition resources (lifecycle management logic).</p>
<p><strong>Required Resources</strong>:</p>
<ul>
<li><strong>Lifecycle Operations</strong>: Definitions for start, stop, restart, update operations</li>
</ul>
<p><strong>Optional Resources</strong>:</p>
<ul>
<li><strong>Health Checks</strong>: Logic for determining instance health</li>
<li><strong>Scaling Rules</strong>: Criteria for starting/stopping multiple instances</li>
<li><strong>Recovery Policies</strong>: How to handle failures</li>
</ul>
<p><strong>Aggregation</strong>: Collect manager operations and policies.</p>
<p><strong>Transformation</strong>: Structure into manager definition with operation handlers.</p>
<h3 id="emission-pattern-5"><a class="header" href="#emission-pattern-5">Emission Pattern</a></h3>
<p><strong>Operation Execution</strong>: Emit operation results:</p>
<ul>
<li><strong>State Transitions</strong>: Instance moved from stopped to running</li>
<li><strong>Operation Logs</strong>: What actions were taken</li>
<li><strong>Status Updates</strong>: Current manager state</li>
</ul>
<p><strong>Health Monitoring</strong>: Emit health check results periodically.</p>
<h3 id="characteristics-5"><a class="header" href="#characteristics-5">Characteristics</a></h3>
<ul>
<li><strong>Control-Oriented</strong>: Manages other containers’ lifecycles</li>
<li><strong>Policy-Driven</strong>: Behavior defined by policies in projection</li>
<li><strong>Reactive</strong>: Responds to state changes and external requests</li>
<li><strong>Status-Emitting</strong>: Continuously updates status</li>
</ul>
<h2 id="view-containers"><a class="header" href="#view-containers">View Containers</a></h2>
<p><strong>Purpose</strong>: Materialized projections for efficient access.</p>
<h3 id="projection-pattern-6"><a class="header" href="#projection-pattern-6">Projection Pattern</a></h3>
<p><strong>Query</strong>: Identify resources matching view criteria (flexible, view-specific).</p>
<p><strong>Required Resources</strong>: Varies by view type (any resources the view aggregates).</p>
<p><strong>Optional Resources</strong>: Varies by view type.</p>
<p><strong>Aggregation</strong>: Follows view-specific aggregation rules (might be complex multi-step).</p>
<p><strong>Transformation</strong>: Transform to view format (often denormalized, indexed).</p>
<h3 id="emission-pattern-6"><a class="header" href="#emission-pattern-6">Emission Pattern</a></h3>
<p><strong>Materialization</strong>: Emit view resource (pre-computed projection result).</p>
<p><strong>Refresh</strong>: Emit updated view resource as underlying resources change.</p>
<p><strong>Index Emissions</strong>: Emit index structures for efficient view queries.</p>
<h3 id="characteristics-6"><a class="header" href="#characteristics-6">Characteristics</a></h3>
<ul>
<li><strong>Denormalized</strong>: Often aggregate and flatten for query performance</li>
<li><strong>Refreshable</strong>: Can be updated incrementally or fully rebuilt</li>
<li><strong>Query-Optimized</strong>: Structured for fast access patterns</li>
<li><strong>Derived</strong>: Always derivable from underlying resources (can be rebuilt)</li>
</ul>
<h2 id="dependency-containers"><a class="header" href="#dependency-containers">Dependency Containers</a></h2>
<p><strong>Purpose</strong>: Express relationships between components.</p>
<h3 id="projection-pattern-7"><a class="header" href="#projection-pattern-7">Projection Pattern</a></h3>
<p><strong>Query</strong>: Identify dependency resources (references between components).</p>
<p><strong>Required Resources</strong>:</p>
<ul>
<li><strong>Dependent Component</strong>: Component requiring dependencies</li>
<li><strong>Required Component</strong>: Component being depended upon</li>
<li><strong>Dependency Type</strong>: Nature of dependency (interface, data, service)</li>
</ul>
<p><strong>Optional Resources</strong>:</p>
<ul>
<li><strong>Version Constraints</strong>: Compatible version ranges</li>
<li><strong>Optional Flags</strong>: Whether dependency is required or optional</li>
</ul>
<p><strong>Aggregation</strong>: Build dependency graph by following dependency references.</p>
<p><strong>Transformation</strong>: Structure into graph or list of dependencies.</p>
<h3 id="emission-pattern-7"><a class="header" href="#emission-pattern-7">Emission Pattern</a></h3>
<p><strong>Dependency Declaration</strong>: Emit dependency resource linking components.</p>
<p><strong>Resolution Results</strong>: Emit resolved dependency sets (satisfying version constraints).</p>
<p><strong>Conflict Warnings</strong>: Emit warnings if dependency conflicts detected.</p>
<h3 id="characteristics-7"><a class="header" href="#characteristics-7">Characteristics</a></h3>
<ul>
<li><strong>Graph-Forming</strong>: Dependencies create directed graph over components</li>
<li><strong>Constraint-Carrying</strong>: Express version and compatibility requirements</li>
<li><strong>Resolvable</strong>: Dependency resolution algorithms operate on these containers</li>
<li><strong>Validation-Enabling</strong>: Enable checking for circular dependencies, conflicts</li>
</ul>
<h2 id="build-containers"><a class="header" href="#build-containers">Build Containers</a></h2>
<p><strong>Purpose</strong>: Define transformation from source to executable artifacts.</p>
<h3 id="projection-pattern-8"><a class="header" href="#projection-pattern-8">Projection Pattern</a></h3>
<p><strong>Query</strong>: Identify build definition resources.</p>
<p><strong>Required Resources</strong>:</p>
<ul>
<li><strong>Build Steps</strong>: Sequence of transformation operations</li>
<li><strong>Source References</strong>: Input resources to build process</li>
</ul>
<p><strong>Optional Resources</strong>:</p>
<ul>
<li><strong>Build Environment</strong>: Required tools, dependencies</li>
<li><strong>Build Configuration</strong>: Parameters, flags, options</li>
</ul>
<p><strong>Aggregation</strong>: Collect build definition and referenced sources.</p>
<p><strong>Transformation</strong>: Structure into executable build plan.</p>
<h3 id="emission-pattern-8"><a class="header" href="#emission-pattern-8">Emission Pattern</a></h3>
<p><strong>Build Execution</strong>: Emit build results:</p>
<ul>
<li><strong>Built Artifacts</strong>: Output resources from build</li>
<li><strong>Build Logs</strong>: Details of build process</li>
<li><strong>Build Status</strong>: Success/failure</li>
<li><strong>Build Metadata</strong>: Build timestamp, environment, inputs</li>
</ul>
<h3 id="characteristics-8"><a class="header" href="#characteristics-8">Characteristics</a></h3>
<ul>
<li><strong>Transformation-Focused</strong>: Converts inputs to outputs</li>
<li><strong>Repeatable</strong>: Same inputs and build definition produce same outputs</li>
<li><strong>Artifact-Producing</strong>: Primary emission is built artifacts</li>
<li><strong>Traceable</strong>: Build logs provide full traceability</li>
</ul>
<h2 id="log-containers"><a class="header" href="#log-containers">Log Containers</a></h2>
<p><strong>Purpose</strong>: Structured logging and event records.</p>
<h3 id="projection-pattern-9"><a class="header" href="#projection-pattern-9">Projection Pattern</a></h3>
<p><strong>Query</strong>: Identify log entry resources (by source, by time range, by level).</p>
<p><strong>Required Resources</strong>:</p>
<ul>
<li><strong>Log Entries</strong>: Individual log records</li>
</ul>
<p><strong>Optional Resources</strong>:</p>
<ul>
<li><strong>Context Information</strong>: Associated resource references, user identity</li>
</ul>
<p><strong>Aggregation</strong>: Collect logs by query criteria (temporal, source-based).</p>
<p><strong>Transformation</strong>: Structure into queryable log collection (often chronological).</p>
<h3 id="emission-pattern-9"><a class="header" href="#emission-pattern-9">Emission Pattern</a></h3>
<p><strong>Log Creation</strong>: Emit individual log entry resources continuously.</p>
<p><strong>Log Aggregation</strong>: Emit aggregated log views (hourly, daily summaries).</p>
<p><strong>Alert Emissions</strong>: Emit alert resources when logs match alert criteria.</p>
<h3 id="characteristics-9"><a class="header" href="#characteristics-9">Characteristics</a></h3>
<ul>
<li><strong>Time-Ordered</strong>: Logs have timestamps, often queried chronologically</li>
<li><strong>High-Volume</strong>: Can produce many emissions rapidly</li>
<li><strong>Queryable</strong>: Often projected into views for searching</li>
<li><strong>Retention-Sensitive</strong>: May be garbage collected after retention period</li>
</ul>
<h2 id="extending-container-types"><a class="header" href="#extending-container-types">Extending Container Types</a></h2>
<p>New container types are created by emitting new projection definitions.</p>
<p><strong>Process</strong>:</p>
<ol>
<li>Define conformance requirements (what resources, what structure)</li>
<li>Define transformation rules (how to structure container)</li>
<li>Define emission patterns (what the container emits)</li>
<li>Emit projection definition resource to store</li>
<li>Platform recognizes new container type, enables projecting it</li>
</ol>
<p>This extensibility means the platform is <strong>open</strong>—applications can define domain-specific container types without modifying platform code.</p>
<h2 id="container-type-composition"><a class="header" href="#container-type-composition">Container Type Composition</a></h2>
<p>Container types compose naturally:</p>
<ul>
<li>Components reference interfaces and documentation</li>
<li>Instances reference components</li>
<li>Views aggregate any container type</li>
<li>Managers control instances</li>
</ul>
<p>Composition creates rich ecosystems where container types work together.</p>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<p>View containers deserve detailed treatment due to their role as optimized, persistent projections. The next document, <strong>Platform Views</strong>, explores views in depth—how they’re materialized, refreshed, and used for efficient access to projected data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-views"><a class="header" href="#platform-views">Platform Views</a></h1>
<h2 id="materialized-container-projections"><a class="header" href="#materialized-container-projections">Materialized Container Projections</a></h2>
<p><strong>Views</strong> are persistent materializations of projections—pre-computed container projections emitted as resources for efficient repeated access. Views optimize common queries by storing projection results rather than re-projecting on every access.</p>
<p>This document describes platform views, their materialization process, refresh strategies, and role in the platform architecture.</p>
<h2 id="what-is-a-view"><a class="header" href="#what-is-a-view">What is a View?</a></h2>
<p>A <strong>view</strong> is a container produced by projecting resources, then emitted as a resource itself for reuse.</p>
<p>Views have dual nature:</p>
<p><strong>As Containers</strong>: Views are projected containers—results of executing projection definitions against the store.</p>
<p><strong>As Resources</strong>: Views are emitted to the store as resources, making them durable and projectable themselves.</p>
<p>This duality enables:</p>
<ul>
<li>Expensive projections computed once, accessed many times</li>
<li>Projections of projections (meta-views)</li>
<li>Version control of view states (immutable CIDs)</li>
<li>Distribution of views between stores</li>
</ul>
<h2 id="view-materialization-1"><a class="header" href="#view-materialization-1">View Materialization</a></h2>
<p><strong>Materialization</strong> is the process of executing a projection and emitting the result as a view resource.</p>
<h3 id="materialization-process"><a class="header" href="#materialization-process">Materialization Process</a></h3>
<p><strong>Phase 1: Projection Execution</strong></p>
<p>Execute the view’s projection definition:</p>
<ol>
<li>Query store to identify resources</li>
<li>Aggregate related resources by following references</li>
<li>Transform aggregated resources into view structure</li>
<li>Validate view satisfies conformance requirements</li>
</ol>
<p>Result: A view container (ephemeral, in-memory).</p>
<p><strong>Phase 2: Emission</strong></p>
<p>Emit the view container as a resource:</p>
<ol>
<li>Serialize view container to canonical format</li>
<li>Compute CID from serialized content</li>
<li>Store view resource in container store</li>
<li>Index view for efficient retrieval</li>
</ol>
<p>Result: A view resource with CID, available for projection.</p>
<p><strong>Phase 3: Catalog Update</strong></p>
<p>Update the view catalog:</p>
<ol>
<li>Record view existence (CID, view type, parameters)</li>
<li>Record materialization timestamp</li>
<li>Record source resources (what was projected)</li>
<li>Index by view type and parameters for discovery</li>
</ol>
<p>Result: View discoverable through catalog queries.</p>
<h2 id="view-types"><a class="header" href="#view-types">View Types</a></h2>
<p>Different view types serve different purposes.</p>
<h3 id="catalog-views"><a class="header" href="#catalog-views">Catalog Views</a></h3>
<p><strong>Purpose</strong>: Index available resources for discovery.</p>
<p><strong>Content</strong>:</p>
<ul>
<li>List of all components with metadata (namespace, version, description)</li>
<li>List of all instances with status (running, stopped)</li>
<li>List of available interfaces</li>
<li>Component dependency graph</li>
</ul>
<p><strong>Refresh</strong>: Periodic or on-demand when components added/removed.</p>
<p><strong>Usage</strong>: Clients query catalog views to discover what’s available.</p>
<h3 id="component-views"><a class="header" href="#component-views">Component Views</a></h3>
<p><strong>Purpose</strong>: Denormalized component information for fast access.</p>
<p><strong>Content</strong>:</p>
<ul>
<li>Complete component definition</li>
<li>Inlined interface definitions (rather than just references)</li>
<li>Rendered documentation (HTML from Markdown)</li>
<li>Test result summaries</li>
</ul>
<p><strong>Refresh</strong>: When component is updated.</p>
<p><strong>Usage</strong>: Displaying component details without traversing references.</p>
<h3 id="instance-views"><a class="header" href="#instance-views">Instance Views</a></h3>
<p><strong>Purpose</strong>: Runtime state and observability.</p>
<p><strong>Content</strong>:</p>
<ul>
<li>Current instance state</li>
<li>Recent logs (last N entries)</li>
<li>Performance metrics</li>
<li>Resource utilization</li>
</ul>
<p><strong>Refresh</strong>: Continuous or frequent (real-time view).</p>
<p><strong>Usage</strong>: Monitoring dashboards, debugging, operations.</p>
<h3 id="log-views"><a class="header" href="#log-views">Log Views</a></h3>
<p><strong>Purpose</strong>: Aggregated logs for searching and analysis.</p>
<p><strong>Content</strong>:</p>
<ul>
<li>Log entries grouped by instance/component/time</li>
<li>Indexed by timestamp, level, source</li>
<li>Aggregated statistics (error counts, rates)</li>
</ul>
<p><strong>Refresh</strong>: Continuous as logs emitted, periodic aggregation.</p>
<p><strong>Usage</strong>: Log search, troubleshooting, audit.</p>
<h3 id="dependency-views"><a class="header" href="#dependency-views">Dependency Views</a></h3>
<p><strong>Purpose</strong>: Visualize and analyze component relationships.</p>
<p><strong>Content</strong>:</p>
<ul>
<li>Complete dependency graph</li>
<li>Transitive dependency closure</li>
<li>Reverse dependencies (what depends on this)</li>
<li>Dependency conflict detection</li>
</ul>
<p><strong>Refresh</strong>: When components or dependencies change.</p>
<p><strong>Usage</strong>: Understanding system structure, impact analysis.</p>
<h3 id="documentation-views"><a class="header" href="#documentation-views">Documentation Views</a></h3>
<p><strong>Purpose</strong>: Searchable, navigable documentation.</p>
<p><strong>Content</strong>:</p>
<ul>
<li>All documentation resources indexed by topic/component</li>
<li>Cross-references resolved</li>
<li>Search index for full-text queries</li>
<li>Table of contents and navigation structure</li>
</ul>
<p><strong>Refresh</strong>: When documentation updated.</p>
<p><strong>Usage</strong>: Documentation portals, search interfaces.</p>
<h3 id="spec-views"><a class="header" href="#spec-views">Spec Views</a></h3>
<p><strong>Purpose</strong>: Export component definitions for version control.</p>
<p><strong>Content</strong>:</p>
<ul>
<li>Component definitions in filesystem-friendly format</li>
<li>Directory structure mirroring component namespaces</li>
<li>Human-readable JSON formatting</li>
</ul>
<p><strong>Refresh</strong>: On-demand when user wants to sync to filesystem.</p>
<p><strong>Usage</strong>: Git commits, external tool integration, review.</p>
<h2 id="view-refresh-strategies"><a class="header" href="#view-refresh-strategies">View Refresh Strategies</a></h2>
<p>Views can become stale as underlying resources change. <strong>Refresh strategies</strong> determine when and how to update views.</p>
<h3 id="on-demand-refresh"><a class="header" href="#on-demand-refresh">On-Demand Refresh</a></h3>
<p>View refreshed when explicitly requested by client.</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>No background computation cost</li>
<li>View freshness controlled by client</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>First access after staleness incurs refresh latency</li>
<li>Clients must know when refresh is needed</li>
</ul>
<p><strong>Applicable</strong>: Views where staleness is acceptable (historical snapshots, archived data).</p>
<h3 id="periodic-refresh"><a class="header" href="#periodic-refresh">Periodic Refresh</a></h3>
<p>View refreshed at regular intervals (hourly, daily).</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Bounded staleness (at most one period old)</li>
<li>Simple scheduling</li>
<li>Predictable refresh cost</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>May refresh unnecessarily (if no changes)</li>
<li>Still can be stale between refreshes</li>
</ul>
<p><strong>Applicable</strong>: Catalog views, dashboards, reports.</p>
<h3 id="incremental-refresh"><a class="header" href="#incremental-refresh">Incremental Refresh</a></h3>
<p>View updated with only new/changed resources since last refresh.</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Lower cost than full refresh (only process changes)</li>
<li>Keeps view fresher</li>
<li>Scales better with large views</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>More complex implementation</li>
<li>Requires tracking changes</li>
</ul>
<p><strong>Applicable</strong>: Log views, event streams, time-series data.</p>
<h3 id="invalidation-based-refresh"><a class="header" href="#invalidation-based-refresh">Invalidation-Based Refresh</a></h3>
<p>View refreshed when underlying resources change.</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>View always fresh (no staleness)</li>
<li>No unnecessary refreshes (only when needed)</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Requires change tracking/notification</li>
<li>May refresh too frequently if resources change often</li>
</ul>
<p><strong>Applicable</strong>: Critical views (security, availability), small views with fast refresh.</p>
<h3 id="lazy-refresh"><a class="header" href="#lazy-refresh">Lazy Refresh</a></h3>
<p>View refreshed on first access after invalidation.</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Combines invalidation detection with on-demand refresh</li>
<li>No refresh cost if view not accessed</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>First post-invalidation access has latency</li>
</ul>
<p><strong>Applicable</strong>: Frequently invalidated but infrequently accessed views.</p>
<h2 id="view-versioning"><a class="header" href="#view-versioning">View Versioning</a></h2>
<p>Because views are resources with CIDs, they’re naturally versioned.</p>
<p>Each refresh produces a new view resource with a new CID. The old view remains (immutability).</p>
<p>This enables:</p>
<p><strong>Temporal Queries</strong>: Project the view as it existed at a specific time (by CID or timestamp).</p>
<p><strong>Consistency</strong>: Multiple queries against the same view CID see identical data (no concurrent modifications).</p>
<p><strong>Auditing</strong>: Complete history of view states preserved.</p>
<p><strong>Rollback</strong>: If refresh produces incorrect view, use previous version.</p>
<p>The view catalog tracks view versions, maintaining:</p>
<ul>
<li>Current view CID (latest refresh)</li>
<li>Previous view CIDs (history)</li>
<li>Refresh timestamps</li>
<li>Underlying resource versions</li>
</ul>
<h2 id="view-consistency"><a class="header" href="#view-consistency">View Consistency</a></h2>
<p>Views can have different consistency guarantees.</p>
<h3 id="eventually-consistent-views"><a class="header" href="#eventually-consistent-views">Eventually Consistent Views</a></h3>
<p>View may lag behind store state. Projecting a view might return data from before recent emissions.</p>
<p><strong>Advantages</strong>: Lower refresh cost, better performance.</p>
<p><strong>Disadvantages</strong>: Stale data possible.</p>
<p><strong>Applicable</strong>: Most views (catalogs, dashboards, documentation).</p>
<h3 id="strongly-consistent-views"><a class="header" href="#strongly-consistent-views">Strongly Consistent Views</a></h3>
<p>View reflects all emissions up to query time.</p>
<p><strong>Advantages</strong>: No staleness, accurate data.</p>
<p><strong>Disadvantages</strong>: Higher cost (frequent refresh or projection without materialization).</p>
<p><strong>Applicable</strong>: Critical operational views (instance status, security).</p>
<h3 id="snapshot-consistent-views"><a class="header" href="#snapshot-consistent-views">Snapshot Consistent Views</a></h3>
<p>View reflects store state at specific point in time (consistent snapshot).</p>
<p><strong>Advantages</strong>: Consistent data (all resources from same timepoint).</p>
<p><strong>Disadvantages</strong>: Intentionally stale (snapshot timestamp &lt; current time).</p>
<p><strong>Applicable</strong>: Reports, analytics, historical analysis.</p>
<h2 id="view-queries"><a class="header" href="#view-queries">View Queries</a></h2>
<p>Views are resources, so they can be projected. <strong>View queries</strong> project views to extract information.</p>
<h3 id="direct-view-projection"><a class="header" href="#direct-view-projection">Direct View Projection</a></h3>
<p>Retrieve entire view resource by CID, use contents directly.</p>
<p>Fast (single resource retrieval), but returns entire view.</p>
<h3 id="filtered-view-projection"><a class="header" href="#filtered-view-projection">Filtered View Projection</a></h3>
<p>Project view, apply filters to select subset.</p>
<p>More flexible than direct retrieval, enables searching within view.</p>
<h3 id="view-composition"><a class="header" href="#view-composition">View Composition</a></h3>
<p>Project multiple views, combine results.</p>
<p>Enables answering queries that span view types (components with instances + logs).</p>
<h3 id="parameterized-view-projection"><a class="header" href="#parameterized-view-projection">Parameterized View Projection</a></h3>
<p>Views can be parameterized (by namespace, time range, filters).</p>
<p>Projection binds parameters, retrieves specific view variant.</p>
<p>Enables view families (component view for each namespace) without storing every variant.</p>
<h2 id="view-caching"><a class="header" href="#view-caching">View Caching</a></h2>
<p>Views serve as caches—materialized projections avoid re-computation.</p>
<p><strong>Cache Hit</strong>: Projecting a view retrieves materialized result (fast).</p>
<p><strong>Cache Miss</strong>: View doesn’t exist or is stale, requires refresh (slow).</p>
<p><strong>Cache Invalidation</strong>: Determine when view is stale and needs refresh.</p>
<p>Standard caching challenges apply:</p>
<ul>
<li>How to detect staleness</li>
<li>When to refresh</li>
<li>How to balance freshness vs cost</li>
</ul>
<p>View refresh strategies are cache invalidation policies.</p>
<h2 id="views-and-storage-backend"><a class="header" href="#views-and-storage-backend">Views and Storage Backend</a></h2>
<p>Views can be stored in the same backend as resources or in specialized storage:</p>
<p><strong>Same Backend</strong>: Views are resources like any others (simple, consistent).</p>
<p><strong>Specialized Storage</strong>: Views in database optimized for queries (relational DB, search index).</p>
<p><strong>Hybrid</strong>: Frequently accessed views in fast storage, others in standard storage.</p>
<p>The view model is independent of storage—views are logically resources regardless of physical storage.</p>
<h2 id="view-materialization-cost"><a class="header" href="#view-materialization-cost">View Materialization Cost</a></h2>
<p>Materializing views has costs:</p>
<p><strong>Projection Cost</strong>: Time and resources to execute projection (query, aggregate, transform).</p>
<p><strong>Storage Cost</strong>: Space to store materialized view resources.</p>
<p><strong>Refresh Cost</strong>: Overhead of detecting changes and updating views.</p>
<p><strong>Consistency Cost</strong>: Ensuring view matches store state.</p>
<p>Optimization strategies:</p>
<p><strong>Selective Materialization</strong>: Only materialize frequently accessed views.</p>
<p><strong>Incremental Refresh</strong>: Update rather than rebuild views.</p>
<p><strong>Approximate Views</strong>: Accept approximate results for lower cost (sampling, estimation).</p>
<p><strong>Lazy Materialization</strong>: Defer materialization until first access.</p>
<h2 id="views-as-projections-of-projections"><a class="header" href="#views-as-projections-of-projections">Views as Projections of Projections</a></h2>
<p>Views are resources, so views can project other views—<strong>meta-views</strong>.</p>
<p>A summary view might project detail views:</p>
<ul>
<li>Daily log view projects hourly log views</li>
<li>System overview view projects component and instance views</li>
<li>Dashboard view projects multiple operational views</li>
</ul>
<p>Meta-views enable hierarchical aggregation and composition without accessing underlying resources repeatedly.</p>
<h2 id="view-definition"><a class="header" href="#view-definition">View Definition</a></h2>
<p>View definitions are projection definitions with additional metadata:</p>
<p><strong>Projection Definition</strong>: How to project resources into view.</p>
<p><strong>Refresh Strategy</strong>: When and how to refresh view.</p>
<p><strong>Retention Policy</strong>: How long to keep old view versions.</p>
<p><strong>Indexing Hints</strong>: What fields to index for efficient queries.</p>
<p><strong>Access Patterns</strong>: Expected query patterns (optimize for these).</p>
<p>View definitions are resources in the store, enabling new view types to be added by emitting new view definitions.</p>
<h2 id="views-and-garbage-collection"><a class="header" href="#views-and-garbage-collection">Views and Garbage Collection</a></h2>
<p>Views are derived—they can always be rebuilt from underlying resources.</p>
<p>This makes views candidates for garbage collection:</p>
<ul>
<li>Remove old view versions beyond retention policy</li>
<li>Remove unused views to free storage</li>
<li>Rebuild views from resources if needed</li>
</ul>
<p>Views provide the <strong>denormalization</strong> tradeoff: storage cost vs query performance.</p>
<h2 id="the-spec-view"><a class="header" href="#the-spec-view">The Spec View</a></h2>
<p>The <strong>spec view</strong> deserves special attention—it’s the view of component definitions formatted for filesystem storage and version control.</p>
<p><strong>Purpose</strong>: Enable git-based workflow for component definitions.</p>
<p><strong>Content</strong>: Component definition resources serialized as filesystem hierarchy:</p>
<ul>
<li>Directory per component namespace</li>
<li>Files per resource type (spec, interface, docs, tests)</li>
<li>Human-readable formatting (pretty-printed JSON)</li>
<li>Index files for navigation</li>
</ul>
<p><strong>Refresh</strong>: On-demand when developer wants to commit changes.</p>
<p><strong>Bidirectional</strong>: Resources can be read from spec view (import from git) or written to spec view (export for git).</p>
<p>The spec view bridges Hologram (content-addressed store) with traditional version control systems (filesystem + git).</p>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<p>Views are consumed through operations—projection executions that read resources, potentially materialize views, and emit results.</p>
<p>The next document, <strong>Platform Operations</strong>, describes the operations provided by the platform—how they use projection-emission cycles, what inputs they require, and what outputs they produce.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-operations"><a class="header" href="#platform-operations">Platform Operations</a></h1>
<h2 id="operations-as-projections-that-emit"><a class="header" href="#operations-as-projections-that-emit">Operations as Projections That Emit</a></h2>
<p><strong>Operations</strong> are the platform’s mechanisms for interacting with resources through projection-emission cycles. Every operation follows the pattern: project resources, execute logic, emit results.</p>
<p>This document describes platform operations, their structure, and how they embody the projection-emission cycle.</p>
<h2 id="operation-fundamentals"><a class="header" href="#operation-fundamentals">Operation Fundamentals</a></h2>
<p>An <strong>operation</strong> is a named, executable procedure that:</p>
<p><strong>Projects</strong>: Identifies and aggregates resources from the store based on operation inputs.</p>
<p><strong>Executes</strong>: Performs computation, validation, transformation, or coordination using projected resources.</p>
<p><strong>Emits</strong>: Writes results back to the store as new resources.</p>
<p><strong>Returns</strong>: Provides operation outcome to the caller (success/failure, emitted resource CIDs).</p>
<p>Operations are the <strong>verbs</strong> of the platform—the actions that transform store state.</p>
<h2 id="operation-structure"><a class="header" href="#operation-structure">Operation Structure</a></h2>
<p>Every operation has:</p>
<p><strong>Identity</strong>: Operation name and type (e.g., “component.create”, “instance.start”).</p>
<p><strong>Inputs</strong>: Parameters provided by caller (resource CIDs, values, options).</p>
<p><strong>Projection Phase</strong>: How the operation identifies and aggregates resources from the store.</p>
<p><strong>Execution Phase</strong>: What computation the operation performs on projected resources.</p>
<p><strong>Emission Phase</strong>: What resources the operation writes back to the store.</p>
<p><strong>Outputs</strong>: What the operation returns to caller (status, emitted CIDs, error information).</p>
<p>This structure maps directly to the projection-emission cycle.</p>
<h2 id="component-operations"><a class="header" href="#component-operations">Component Operations</a></h2>
<p>Operations for managing component definitions.</p>
<h3 id="component-create"><a class="header" href="#component-create">Component Create</a></h3>
<p><strong>Purpose</strong>: Define a new component from artifacts.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Artifact resources (spec, interface, docs, tests, etc.)</li>
<li>Component namespace</li>
<li>Version information</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project artifact resources by CID</li>
<li>Project component model (hologram.component definition) to understand conformance requirements</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Validate artifacts against schemas</li>
<li>Check conformance requirements satisfied</li>
<li>Build component definition structure</li>
<li>Assign unique component identifier</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit component definition resource</li>
<li>Emit component index entry (for catalog)</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Component definition CID</li>
<li>Success/failure status</li>
<li>Validation messages</li>
</ul>
<h3 id="component-read"><a class="header" href="#component-read">Component Read</a></h3>
<p><strong>Purpose</strong>: Retrieve component definition and related resources.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Component namespace or CID</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project component definition resource</li>
<li>Project referenced resources (interface, docs, tests per request)</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Assemble complete component container</li>
<li>Resolve references</li>
<li>Apply formatting/transformation if requested</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>None (read-only operation)</li>
<li>May cache projection result for performance</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Component definition</li>
<li>Referenced resources</li>
<li>Metadata</li>
</ul>
<h3 id="component-update"><a class="header" href="#component-update">Component Update</a></h3>
<p><strong>Purpose</strong>: Modify existing component definition.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Component namespace or CID</li>
<li>Updated artifact resources</li>
<li>Change description</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project existing component definition</li>
<li>Project new artifact resources</li>
<li>Project dependents (components depending on this one)</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Validate new artifacts</li>
<li>Check backward compatibility if required</li>
<li>Build updated component definition</li>
<li>Verify dependents not broken</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit new component definition resource (new CID, immutable versioning)</li>
<li>Emit change log entry</li>
<li>Update component index</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>New component definition CID</li>
<li>Change summary</li>
<li>Compatibility status</li>
</ul>
<h3 id="component-delete"><a class="header" href="#component-delete">Component Delete</a></h3>
<p><strong>Purpose</strong>: Remove component from catalog.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Component namespace or CID</li>
<li>Force flag (delete even with dependents)</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project component definition</li>
<li>Project reverse dependencies (what depends on this)</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Check for dependents</li>
<li>If dependents exist and not forced, fail</li>
<li>Mark component as deleted</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit deletion marker resource</li>
<li>Update component index (remove from catalog)</li>
<li>Emit dependency warning if forced deletion</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Deletion status</li>
<li>Affected dependents list</li>
</ul>
<h3 id="component-validate"><a class="header" href="#component-validate">Component Validate</a></h3>
<p><strong>Purpose</strong>: Verify component definition correctness.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Component namespace or CID</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project component definition</li>
<li>Project all referenced resources</li>
<li>Project schemas for validation</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Validate spec against schema</li>
<li>Validate conformance resources</li>
<li>Check reference integrity</li>
<li>Verify dependencies resolvable</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit validation report resource</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Validation result (pass/fail)</li>
<li>Detailed validation messages</li>
<li>Report CID</li>
</ul>
<h2 id="instance-operations"><a class="header" href="#instance-operations">Instance Operations</a></h2>
<p>Operations for managing running instances.</p>
<h3 id="instance-create"><a class="header" href="#instance-create">Instance Create</a></h3>
<p><strong>Purpose</strong>: Instantiate a component definition.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Component definition CID or namespace</li>
<li>Instance configuration</li>
<li>Initial state (optional)</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project component definition</li>
<li>Project dependency components (transitive)</li>
<li>Project runtime context</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Resolve dependencies</li>
<li>Initialize instance state</li>
<li>Allocate resources</li>
<li>Prepare execution environment</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit instance resource (initial state)</li>
<li>Emit instance catalog entry</li>
<li>Emit initialization log</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Instance ID and CID</li>
<li>Initialization status</li>
</ul>
<h3 id="instance-start"><a class="header" href="#instance-start">Instance Start</a></h3>
<p><strong>Purpose</strong>: Begin instance execution.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Instance ID</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project instance resource</li>
<li>Project component definition</li>
<li>Project dependencies</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Load instance state</li>
<li>Begin execution per component definition</li>
<li>Start emission streams (logs, state, data)</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit instance state update (status: running)</li>
<li>Emit startup logs</li>
<li>Begin continuous emission stream</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Start status</li>
<li>Instance runtime information</li>
</ul>
<h3 id="instance-stop"><a class="header" href="#instance-stop">Instance Stop</a></h3>
<p><strong>Purpose</strong>: Halt instance execution.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Instance ID</li>
<li>Graceful timeout (optional)</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project running instance resource</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Signal instance to stop</li>
<li>Wait for graceful shutdown (up to timeout)</li>
<li>Force stop if timeout exceeded</li>
<li>Finalize state</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit final instance state (status: stopped)</li>
<li>Emit shutdown logs</li>
<li>Emit execution summary</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Stop status</li>
<li>Final state CID</li>
</ul>
<h3 id="instance-restart"><a class="header" href="#instance-restart">Instance Restart</a></h3>
<p><strong>Purpose</strong>: Stop and start instance.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Instance ID</li>
<li>Restart options</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project instance resource</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Execute stop operation</li>
<li>Execute start operation</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emissions from stop and start operations</li>
<li>Emit restart log entry</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Restart status</li>
<li>New instance state CID</li>
</ul>
<h3 id="instance-inspect"><a class="header" href="#instance-inspect">Instance Inspect</a></h3>
<p><strong>Purpose</strong>: Retrieve instance state and status.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Instance ID</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project instance resource</li>
<li>Project recent logs</li>
<li>Project component definition</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Assemble current instance state</li>
<li>Gather runtime information</li>
<li>Compute uptime and metrics</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>None (read-only)</li>
<li>May cache inspection result</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Instance state</li>
<li>Status information</li>
<li>Logs and metrics</li>
</ul>
<h2 id="view-operations"><a class="header" href="#view-operations">View Operations</a></h2>
<p>Operations for managing materialized views.</p>
<h3 id="view-materialize"><a class="header" href="#view-materialize">View Materialize</a></h3>
<p><strong>Purpose</strong>: Execute projection and emit result as view resource.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>View definition CID</li>
<li>Projection parameters</li>
<li>Materialization options</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project view definition</li>
<li>Execute view’s projection (project resources per view definition)</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Transform projection result to view format</li>
<li>Apply indexing or optimization</li>
<li>Validate view structure</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit view resource</li>
<li>Emit view catalog entry</li>
<li>Update view index</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>View CID</li>
<li>Materialization timestamp</li>
<li>Statistics (resources processed, view size)</li>
</ul>
<h3 id="view-refresh"><a class="header" href="#view-refresh">View Refresh</a></h3>
<p><strong>Purpose</strong>: Update existing view with current store state.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>View CID or identifier</li>
<li>Refresh strategy (full, incremental)</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project existing view</li>
<li>Project new/changed resources since last refresh</li>
<li>Project view definition</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Determine changes since last materialization</li>
<li>Apply incremental updates or full rebuild</li>
<li>Validate updated view</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit refreshed view resource (new CID)</li>
<li>Update view catalog with new version</li>
<li>Emit refresh log</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>New view CID</li>
<li>Changes applied</li>
<li>Refresh statistics</li>
</ul>
<h3 id="view-query"><a class="header" href="#view-query">View Query</a></h3>
<p><strong>Purpose</strong>: Execute query against materialized view.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>View CID or identifier</li>
<li>Query parameters (filters, search terms)</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project view resource</li>
<li>Apply query filters</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Search or filter within view</li>
<li>Compute results</li>
<li>Apply pagination or limits</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>None (read-only)</li>
<li>May emit query result cache</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Query results</li>
<li>Result metadata (count, timing)</li>
</ul>
<h2 id="artifact-operations"><a class="header" href="#artifact-operations">Artifact Operations</a></h2>
<p>Operations for staging resources before component creation.</p>
<h3 id="artifact-submit"><a class="header" href="#artifact-submit">Artifact Submit</a></h3>
<p><strong>Purpose</strong>: Stage a resource for later use in component creation.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Artifact content</li>
<li>Artifact type (spec, interface, docs, etc.)</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>None (no existing resources needed)</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Validate artifact content</li>
<li>Check artifact type valid</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit artifact resource to store</li>
<li>Record in artifact staging area</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Artifact CID</li>
<li>Staging status</li>
</ul>
<h3 id="manifest-submit"><a class="header" href="#manifest-submit">Manifest Submit</a></h3>
<p><strong>Purpose</strong>: Create component from staged artifacts.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Manifest listing artifact CIDs and types</li>
<li>Component namespace</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project staged artifact resources</li>
<li>Project component model</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Execute component create operation using artifacts</li>
<li>Clear artifact staging area</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emissions from component create</li>
<li>Clear staging artifacts</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Component definition CID</li>
<li>Component creation status</li>
</ul>
<h2 id="validation-operations"><a class="header" href="#validation-operations">Validation Operations</a></h2>
<p>Operations for verifying correctness.</p>
<h3 id="schema-validate"><a class="header" href="#schema-validate">Schema Validate</a></h3>
<p><strong>Purpose</strong>: Validate resource against schema.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Resource CID</li>
<li>Schema CID or type</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project resource to validate</li>
<li>Project schema definition</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Apply schema validation</li>
<li>Collect validation errors/warnings</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit validation report</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Validation result</li>
<li>Error details</li>
</ul>
<h3 id="reference-validate"><a class="header" href="#reference-validate">Reference Validate</a></h3>
<p><strong>Purpose</strong>: Verify reference integrity.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Resource CID</li>
<li>Traversal depth</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project resource</li>
<li>Project all referenced resources (recursively)</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Check all CID references exist</li>
<li>Verify no dangling references</li>
<li>Detect reference cycles if problematic</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit reference validation report</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Integrity status</li>
<li>Missing references</li>
<li>Cycle information</li>
</ul>
<h2 id="catalog-operations"><a class="header" href="#catalog-operations">Catalog Operations</a></h2>
<p>Operations for discovering resources.</p>
<h3 id="catalog-list"><a class="header" href="#catalog-list">Catalog List</a></h3>
<p><strong>Purpose</strong>: List available resources by type.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Resource type (components, instances, views)</li>
<li>Filters (namespace pattern, status)</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project catalog view for resource type</li>
<li>Apply filters</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Extract matching entries</li>
<li>Sort and paginate</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>None (read-only)</li>
<li>May emit query result cache</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Resource list</li>
<li>Metadata</li>
</ul>
<h3 id="catalog-search"><a class="header" href="#catalog-search">Catalog Search</a></h3>
<p><strong>Purpose</strong>: Search resources by content or metadata.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Search query (text, patterns)</li>
<li>Resource types to search</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project search indexes or catalog views</li>
<li>Execute search query</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Rank results by relevance</li>
<li>Apply pagination</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>None (read-only)</li>
<li>May emit search result cache</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Search results</li>
<li>Relevance scores</li>
</ul>
<h2 id="dependency-operations"><a class="header" href="#dependency-operations">Dependency Operations</a></h2>
<p>Operations for managing component relationships.</p>
<h3 id="dependency-resolve"><a class="header" href="#dependency-resolve">Dependency Resolve</a></h3>
<p><strong>Purpose</strong>: Compute transitive dependencies for a component.</p>
<p><strong>Inputs</strong>:</p>
<ul>
<li>Component CID or namespace</li>
</ul>
<p><strong>Projection Phase</strong>:</p>
<ul>
<li>Project component definition</li>
<li>Project dependency view or build graph</li>
</ul>
<p><strong>Execution Phase</strong>:</p>
<ul>
<li>Traverse dependency references</li>
<li>Build transitive closure</li>
<li>Check for conflicts or cycles</li>
</ul>
<p><strong>Emission Phase</strong>:</p>
<ul>
<li>Emit dependency resolution result</li>
<li>Emit dependency graph</li>
</ul>
<p><strong>Outputs</strong>:</p>
<ul>
<li>Resolved dependencies (all required components)</li>
<li>Resolution status</li>
<li>Conflict information</li>
</ul>
<h2 id="operation-composition"><a class="header" href="#operation-composition">Operation Composition</a></h2>
<p>Operations can compose:</p>
<p><strong>Sequential</strong>: Component Create → Instance Create → Instance Start (build workflow).</p>
<p><strong>Parallel</strong>: Multiple Instance Start operations concurrently.</p>
<p><strong>Conditional</strong>: Instance Stop → if graceful failed → Instance Force Stop.</p>
<p><strong>Transactional</strong>: Artifact Submit (multiple) → Manifest Submit (atomic component creation).</p>
<p>Composition enables complex workflows from simple operations.</p>
<h2 id="operation-atomicity"><a class="header" href="#operation-atomicity">Operation Atomicity</a></h2>
<p>Operations are atomic with respect to emissions:</p>
<ul>
<li>All emissions succeed or all fail</li>
<li>Store remains consistent regardless of operation outcome</li>
<li>Partial failures result in complete rollback</li>
</ul>
<p>This enables reliable operations even with concurrent access.</p>
<h2 id="operation-idempotence"><a class="header" href="#operation-idempotence">Operation Idempotence</a></h2>
<p>Many operations are idempotent:</p>
<ul>
<li>Repeating with same inputs produces same result</li>
<li>Component Create with identical artifacts produces same CID</li>
<li>View Materialize with same parameters produces same view</li>
</ul>
<p>Idempotence enables safe retries after failures.</p>
<h2 id="operation-observability"><a class="header" href="#operation-observability">Operation Observability</a></h2>
<p>All operations emit logs and metadata:</p>
<ul>
<li>Operation start/end timestamps</li>
<li>Resources projected</li>
<li>Execution duration</li>
<li>Success/failure status</li>
<li>Emitted resource CIDs</li>
</ul>
<p>This provides complete audit trail and debugging information.</p>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<p>Operations are invoked through the <strong>Platform API</strong>—the client interface for interacting with the platform. The next document describes the API model, request/response patterns, and how clients use the API to perform operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-api"><a class="header" href="#platform-api">Platform API</a></h1>
<h2 id="client-interaction-model"><a class="header" href="#client-interaction-model">Client Interaction Model</a></h2>
<p>The <strong>Platform API</strong> is how clients interact with the Hologram platform—submitting operations, retrieving results, subscribing to emissions, and querying resources. The API provides a uniform interface across different client implementations.</p>
<p>This document describes the API model, request/response patterns, and client interaction principles.</p>
<h2 id="api-principles"><a class="header" href="#api-principles">API Principles</a></h2>
<h3 id="protocol-independence"><a class="header" href="#protocol-independence">Protocol Independence</a></h3>
<p>The API model is abstract—not tied to specific protocols (HTTP, gRPC, MCP, CLI).</p>
<p>Different client implementations provide different protocol bindings:</p>
<ul>
<li><strong>MCP Server</strong>: Model Context Protocol for AI tool integration</li>
<li><strong>HTTP API</strong>: RESTful or GraphQL over HTTP</li>
<li><strong>CLI Client</strong>: Command-line interface</li>
<li><strong>SDK Libraries</strong>: Language-specific client libraries</li>
</ul>
<p>All bindings map to the same underlying API model.</p>
<h3 id="operation-centric"><a class="header" href="#operation-centric">Operation-Centric</a></h3>
<p>The API is organized around <strong>operations</strong> (component.create, instance.start, view.materialize).</p>
<p>Each operation is a distinct API endpoint or command with specific:</p>
<ul>
<li>Input parameters</li>
<li>Execution semantics</li>
<li>Output format</li>
<li>Error conditions</li>
</ul>
<p>Clients invoke operations and receive results.</p>
<h3 id="resource-oriented"><a class="header" href="#resource-oriented">Resource-Oriented</a></h3>
<p>Operations manipulate <strong>resources</strong> identified by CID or namespace.</p>
<p>The API provides:</p>
<ul>
<li>Resource submission (emit new resources)</li>
<li>Resource retrieval (project existing resources)</li>
<li>Resource querying (identify resources matching criteria)</li>
</ul>
<p>Resources are the nouns, operations are the verbs.</p>
<h3 id="asynchronous-by-default"><a class="header" href="#asynchronous-by-default">Asynchronous by Default</a></h3>
<p>Many operations (instance start, view materialization) have non-trivial duration.</p>
<p>The API supports <strong>asynchronous execution</strong>:</p>
<ul>
<li>Submit operation request, receive operation ID</li>
<li>Poll or subscribe to operation status</li>
<li>Retrieve results when complete</li>
</ul>
<p>Short operations can complete synchronously, but async is always available.</p>
<h2 id="request-model"><a class="header" href="#request-model">Request Model</a></h2>
<h3 id="operation-requests"><a class="header" href="#operation-requests">Operation Requests</a></h3>
<p>All operation requests have common structure:</p>
<p><strong>Operation Identifier</strong>: Which operation to execute (e.g., “component.create”).</p>
<p><strong>Parameters</strong>: Operation-specific inputs:</p>
<ul>
<li>Resource CIDs (references to existing resources)</li>
<li>Values (strings, numbers, structured data)</li>
<li>Options (flags, preferences)</li>
</ul>
<p><strong>Context</strong>: Metadata about the request:</p>
<ul>
<li>Client identity (user, service account)</li>
<li>Request ID (for tracing)</li>
<li>Timeout preferences</li>
<li>Priority hints</li>
</ul>
<p><strong>Idempotency Token</strong>: Optional token ensuring repeated requests don’t duplicate operations.</p>
<h3 id="resource-submission"><a class="header" href="#resource-submission">Resource Submission</a></h3>
<p>Submitting resources for emission:</p>
<p><strong>Content</strong>: The resource data (bytes or structured data).</p>
<p><strong>Metadata</strong>: Optional metadata:</p>
<ul>
<li>Content type (JSON, binary, text)</li>
<li>Description</li>
<li>Tags for categorization</li>
</ul>
<p><strong>Validation Options</strong>: Whether to validate before emission, what schema to use.</p>
<p>The API computes CID, validates (if requested), and emits to store.</p>
<h3 id="projection-requests"><a class="header" href="#projection-requests">Projection Requests</a></h3>
<p>Requesting projection without performing full operation:</p>
<p><strong>Projection Definition</strong>: Which projection to execute (by CID or type).</p>
<p><strong>Parameters</strong>: Projection parameters (namespace filter, depth limit, etc.).</p>
<p><strong>Format</strong>: Desired output format (structured data, human-readable, binary).</p>
<p>The API executes projection, returns container without emitting.</p>
<h2 id="response-model"><a class="header" href="#response-model">Response Model</a></h2>
<h3 id="synchronous-responses"><a class="header" href="#synchronous-responses">Synchronous Responses</a></h3>
<p>For operations that complete quickly:</p>
<p><strong>Status</strong>: Success or failure indicator.</p>
<p><strong>Result</strong>: Operation output:</p>
<ul>
<li>Emitted resource CIDs</li>
<li>Projected resource content</li>
<li>Computed values</li>
</ul>
<p><strong>Metadata</strong>: Execution information:</p>
<ul>
<li>Duration</li>
<li>Resources accessed</li>
<li>Warnings</li>
</ul>
<p><strong>Errors</strong>: If failure, detailed error information.</p>
<h3 id="asynchronous-responses"><a class="header" href="#asynchronous-responses">Asynchronous Responses</a></h3>
<p>For long-running operations:</p>
<p><strong>Operation ID</strong>: Unique identifier for tracking operation.</p>
<p><strong>Status Endpoint</strong>: Where to check operation status.</p>
<p><strong>Estimated Duration</strong>: If known, expected completion time.</p>
<p>Clients poll status endpoint or subscribe to status updates:</p>
<p><strong>Status Updates</strong>: Periodic messages indicating progress:</p>
<ul>
<li>State (pending, running, completed, failed)</li>
<li>Progress percentage (if computable)</li>
<li>Intermediate results</li>
</ul>
<p><strong>Completion</strong>: Final message with full results or error.</p>
<h3 id="streaming-responses"><a class="header" href="#streaming-responses">Streaming Responses</a></h3>
<p>For operations producing continuous output (instance logs, event streams):</p>
<p><strong>Stream Handle</strong>: Identifier for the stream.</p>
<p><strong>Stream Endpoint</strong>: Where to receive stream data.</p>
<p><strong>Stream Control</strong>: Operations to pause, resume, or close stream.</p>
<p>Stream delivers items as they’re emitted:</p>
<ul>
<li>Log entries</li>
<li>State updates</li>
<li>Events</li>
</ul>
<p>Stream terminates on completion or explicit close.</p>
<h2 id="error-model"><a class="header" href="#error-model">Error Model</a></h2>
<h3 id="error-structure"><a class="header" href="#error-structure">Error Structure</a></h3>
<p>Errors provide detailed information:</p>
<p><strong>Error Code</strong>: Machine-readable identifier (RESOURCE_NOT_FOUND, VALIDATION_FAILED).</p>
<p><strong>Error Message</strong>: Human-readable description.</p>
<p><strong>Context</strong>: Where error occurred:</p>
<ul>
<li>Operation phase (projection, execution, emission)</li>
<li>Resource CID that caused error</li>
<li>Stack trace (if applicable)</li>
</ul>
<p><strong>Recovery Suggestions</strong>: Possible remediation (fix schema, provide missing resource).</p>
<p><strong>Related Resources</strong>: CIDs of resources involved in error.</p>
<h3 id="error-categories"><a class="header" href="#error-categories">Error Categories</a></h3>
<p><strong>Client Errors</strong>: Invalid input, malformed request, unauthorized access.</p>
<ul>
<li>HTTP 4xx equivalent</li>
<li>Client should fix request and retry</li>
</ul>
<p><strong>Server Errors</strong>: Platform failure, store unavailable, internal error.</p>
<ul>
<li>HTTP 5xx equivalent</li>
<li>Client should retry (possibly with backoff)</li>
</ul>
<p><strong>Resource Errors</strong>: Resource not found, validation failed, reference broken.</p>
<ul>
<li>Specific to Hologram model</li>
<li>May require emitting new/different resources</li>
</ul>
<p><strong>Operation Errors</strong>: Operation-specific failures (can’t start instance, dependency conflict).</p>
<ul>
<li>Varies by operation</li>
<li>Check operation documentation for possible errors</li>
</ul>
<h2 id="authentication-and-authorization"><a class="header" href="#authentication-and-authorization">Authentication and Authorization</a></h2>
<h3 id="identity"><a class="header" href="#identity">Identity</a></h3>
<p>Clients authenticate, establishing identity:</p>
<ul>
<li>User identity (human user)</li>
<li>Service identity (automated client)</li>
<li>Anonymous (if platform allows)</li>
</ul>
<p>Identity is provided in request context.</p>
<h3 id="permissions"><a class="header" href="#permissions">Permissions</a></h3>
<p>The platform enforces access control:</p>
<ul>
<li>Read permissions (project resources)</li>
<li>Write permissions (emit resources)</li>
<li>Operation permissions (execute specific operations)</li>
</ul>
<p>Permission model is flexible:</p>
<ul>
<li>Resource-based (permissions per resource namespace)</li>
<li>Role-based (roles grant permission sets)</li>
<li>Attribute-based (contextual permissions)</li>
</ul>
<p>Unauthorized operations return permission denied error.</p>
<h2 id="client-patterns"><a class="header" href="#client-patterns">Client Patterns</a></h2>
<p>Common interaction patterns.</p>
<h3 id="submit-retrieve-pattern"><a class="header" href="#submit-retrieve-pattern">Submit-Retrieve Pattern</a></h3>
<p>For two-phase operations (artifact/manifest):</p>
<ol>
<li>Client submits multiple resources (artifacts)</li>
<li>API returns CIDs</li>
<li>Client submits manifest referencing CIDs</li>
<li>API executes operation (component create)</li>
<li>Client retrieves result</li>
</ol>
<p>This pattern enables staging and validation before final operation.</p>
<h3 id="subscribe-process-pattern"><a class="header" href="#subscribe-process-pattern">Subscribe-Process Pattern</a></h3>
<p>For monitoring running instances:</p>
<ol>
<li>Client starts instance</li>
<li>Client subscribes to instance emission stream</li>
<li>API delivers logs, state, data as emitted</li>
<li>Client processes items as received</li>
<li>Client closes stream when done</li>
</ol>
<p>This pattern enables real-time monitoring.</p>
<h3 id="query-refine-pattern"><a class="header" href="#query-refine-pattern">Query-Refine Pattern</a></h3>
<p>For discovery:</p>
<ol>
<li>Client queries catalog (broad search)</li>
<li>API returns initial results</li>
<li>Client refines query (add filters)</li>
<li>API returns refined results</li>
<li>Repeat until desired resources found</li>
</ol>
<p>This pattern supports interactive exploration.</p>
<h3 id="batch-process-pattern"><a class="header" href="#batch-process-pattern">Batch-Process Pattern</a></h3>
<p>For high-volume operations:</p>
<ol>
<li>Client submits batch of operations</li>
<li>API processes concurrently</li>
<li>API returns batch results</li>
<li>Client checks each result</li>
</ol>
<p>This pattern optimizes throughput.</p>
<h2 id="api-versioning"><a class="header" href="#api-versioning">API Versioning</a></h2>
<h3 id="projection-versioning"><a class="header" href="#projection-versioning">Projection Versioning</a></h3>
<p>Since operations are defined by projections in the store, API evolution is natural:</p>
<p><strong>New Operations</strong>: Emit new projection definitions to store.</p>
<p><strong>Operation Changes</strong>: Emit new version of projection definition (new CID).</p>
<p><strong>Deprecation</strong>: Mark old projection versions as deprecated (still available).</p>
<p>The API surface evolves through the same projection-emission mechanism.</p>
<h3 id="protocol-versioning"><a class="header" href="#protocol-versioning">Protocol Versioning</a></h3>
<p>Protocol bindings (HTTP, MCP) have independent versions:</p>
<ul>
<li>Protocol version indicates what features are available</li>
<li>Older clients use older protocol versions</li>
<li>Platform supports multiple protocol versions</li>
</ul>
<h2 id="implementation-examples"><a class="header" href="#implementation-examples">Implementation Examples</a></h2>
<p>How different client types interact:</p>
<h3 id="mcp-server-client"><a class="header" href="#mcp-server-client">MCP Server Client</a></h3>
<p>MCP (Model Context Protocol) client for AI tools:</p>
<p><strong>Request</strong>: AI tool invokes MCP tool (listComponents, validate, create).</p>
<p><strong>Mapping</strong>: MCP tool maps to platform operation.</p>
<p><strong>Execution</strong>: Platform executes operation.</p>
<p><strong>Response</strong>: Platform returns result formatted per MCP.</p>
<p><strong>Streaming</strong>: MCP server events for long operations.</p>
<h3 id="http-api-client"><a class="header" href="#http-api-client">HTTP API Client</a></h3>
<p>HTTP client for web applications:</p>
<p><strong>Request</strong>: HTTP POST to operation endpoint with JSON body.</p>
<p><strong>Mapping</strong>: URL path + method indicate operation, body contains parameters.</p>
<p><strong>Execution</strong>: Platform executes operation.</p>
<p><strong>Response</strong>: HTTP response with JSON result.</p>
<p><strong>Streaming</strong>: Server-Sent Events or WebSocket for streams.</p>
<h3 id="cli-client"><a class="header" href="#cli-client">CLI Client</a></h3>
<p>Command-line client for operators:</p>
<p><strong>Request</strong>: CLI command with arguments and flags.</p>
<p><strong>Mapping</strong>: Command name maps to operation, arguments to parameters.</p>
<p><strong>Execution</strong>: Platform executes operation.</p>
<p><strong>Response</strong>: Formatted text output, exit code indicates success/failure.</p>
<p><strong>Streaming</strong>: Line-by-line output for streams.</p>
<h3 id="sdk-library-client"><a class="header" href="#sdk-library-client">SDK Library Client</a></h3>
<p>Programming language library for applications:</p>
<p><strong>Request</strong>: Function call with typed parameters.</p>
<p><strong>Mapping</strong>: Function name maps to operation.</p>
<p><strong>Execution</strong>: Library serializes request, sends to platform, deserializes response.</p>
<p><strong>Response</strong>: Typed result objects.</p>
<p><strong>Streaming</strong>: Iterator or observable pattern for streams.</p>
<h2 id="api-discovery"><a class="header" href="#api-discovery">API Discovery</a></h2>
<p>Clients can discover available operations:</p>
<p><strong>List Operations</strong>: API endpoint returns available operations with descriptions.</p>
<p><strong>Operation Schema</strong>: Each operation provides input/output schema.</p>
<p><strong>Examples</strong>: Operations include usage examples.</p>
<p><strong>Documentation</strong>: API provides links to detailed documentation.</p>
<p>Discovery enables dynamic clients that adapt to platform capabilities.</p>
<h2 id="rate-limiting-and-quotas"><a class="header" href="#rate-limiting-and-quotas">Rate Limiting and Quotas</a></h2>
<p>Platforms may enforce limits:</p>
<p><strong>Rate Limits</strong>: Maximum requests per time period (per client, per operation type).</p>
<p><strong>Quotas</strong>: Maximum resource consumption (storage, compute, emissions).</p>
<p><strong>Throttling</strong>: Slowing requests when approaching limits.</p>
<p>Clients receive feedback about limits:</p>
<ul>
<li>Current usage</li>
<li>Remaining quota</li>
<li>Reset time</li>
<li>Throttle status</li>
</ul>
<h2 id="caching-and-etags"><a class="header" href="#caching-and-etags">Caching and ETags</a></h2>
<p>For read operations, caching improves performance:</p>
<p><strong>Resource ETags</strong>: CID serves as natural ETag (content-based).</p>
<p><strong>Conditional Requests</strong>: “If-None-Match: CID” returns 304 Not Modified if unchanged.</p>
<p><strong>Cache Headers</strong>: Platform provides cache duration hints.</p>
<p>Content addressing makes caching reliable—CID guarantees content identity.</p>
<h2 id="bulk-operations"><a class="header" href="#bulk-operations">Bulk Operations</a></h2>
<p>For efficiency, API supports bulk operations:</p>
<p><strong>Batch Submission</strong>: Submit multiple resources in one request.</p>
<p><strong>Batch Retrieval</strong>: Retrieve multiple resources by CID list.</p>
<p><strong>Batch Operations</strong>: Execute multiple operations atomically.</p>
<p>Bulk operations reduce round-trips and enable atomic multi-resource transactions.</p>
<h2 id="websocketstreaming-support"><a class="header" href="#websocketstreaming-support">WebSocket/Streaming Support</a></h2>
<p>For real-time interaction:</p>
<p><strong>Persistent Connection</strong>: WebSocket or similar for bidirectional communication.</p>
<p><strong>Operation Streaming</strong>: Submit operations, receive results over same connection.</p>
<p><strong>Emission Subscription</strong>: Subscribe to emission streams, receive items as emitted.</p>
<p><strong>Multiplexing</strong>: Multiple operations/streams over one connection.</p>
<p>Streaming enables responsive interactive applications.</p>
<h2 id="api-observability"><a class="header" href="#api-observability">API Observability</a></h2>
<p>The API provides visibility into platform behavior:</p>
<p><strong>Operation Logs</strong>: Record of API operations performed.</p>
<p><strong>Performance Metrics</strong>: Latency, throughput, error rates per operation.</p>
<p><strong>Resource Metrics</strong>: Store size, emission rate, projection frequency.</p>
<p><strong>Client Metrics</strong>: Per-client usage patterns.</p>
<p>Observability helps clients understand platform health and optimize usage.</p>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<p>The platform API enables clients to interact with the system, but the platform itself must bootstrap from minimal primitives. The next section, Part IV: System Architecture, begins with <strong>Bootstrap Architecture</strong>—how the platform initializes itself from a minimal content-addressed store to a fully functional projection-emission system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootstrap-architecture"><a class="header" href="#bootstrap-architecture">Bootstrap Architecture</a></h1>
<h2 id="from-minimal-store-to-self-describing-platform"><a class="header" href="#from-minimal-store-to-self-describing-platform">From Minimal Store to Self-Describing Platform</a></h2>
<p>The Hologram platform is <strong>self-describing</strong>—it contains its own definition as projections in the store. But this creates a bootstrapping challenge: how does the platform initialize when it needs projections to understand projections?</p>
<p>This document describes the bootstrap sequence—how the platform cold-starts from minimal primitives and builds up to full self-describing operation.</p>
<h2 id="the-bootstrap-problem"><a class="header" href="#the-bootstrap-problem">The Bootstrap Problem</a></h2>
<p>The platform requires:</p>
<ul>
<li>Projection definitions to understand how to project</li>
<li>Container store to hold projection definitions</li>
<li>Projection engine to execute projection definitions</li>
</ul>
<p>But:</p>
<ul>
<li>Projection definitions are resources in the store</li>
<li>The engine needs projection definitions to project resources</li>
<li>Projecting projection definitions requires the engine</li>
</ul>
<p>This is the <strong>bootstrap paradox</strong>: the system needs itself to start itself.</p>
<h2 id="bootstrap-solution-staged-initialization"><a class="header" href="#bootstrap-solution-staged-initialization">Bootstrap Solution: Staged Initialization</a></h2>
<p>The solution is <strong>staged initialization</strong>—starting with minimal hard-coded capabilities and progressively replacing them with projected capabilities.</p>
<p>Each stage builds on the previous, until the platform is fully self-describing and no hard-coded logic remains (or only fundamental primitives remain).</p>
<h2 id="bootstrap-layers"><a class="header" href="#bootstrap-layers">Bootstrap Layers</a></h2>
<h3 id="layer-0-minimal-content-addressed-store"><a class="header" href="#layer-0-minimal-content-addressed-store">Layer 0: Minimal Content-Addressed Store</a></h3>
<p><strong>What Exists</strong>: A content-addressed storage implementation providing the four core capabilities:</p>
<ul>
<li>Store (write resource, get CID)</li>
<li>Retrieve (read resource by CID)</li>
<li>Reference (extract CIDs from resource)</li>
<li>Query (identify resources by basic criteria)</li>
</ul>
<p><strong>What’s Hard-Coded</strong>: The store implementation itself (filesystem, database, memory).</p>
<p><strong>What’s Not Present</strong>: Projection engine, projection definitions, container types, operations.</p>
<p>This is the <strong>axiom layer</strong>—the minimal foundation assumed to exist.</p>
<h3 id="layer-1-store-definition-hologramstore"><a class="header" href="#layer-1-store-definition-hologramstore">Layer 1: Store Definition (hologram.store)</a></h3>
<p><strong>What Happens</strong>: Emit the store’s own definition as a resource.</p>
<p><strong>Resource Content</strong>: JSON document describing:</p>
<ul>
<li>Store capabilities (store, retrieve, reference, query)</li>
<li>Store properties (immutability, content addressing, deduplication)</li>
<li>Store interface (how to interact with store)</li>
</ul>
<p><strong>Process</strong>:</p>
<ol>
<li>Hard-coded bootstrap code creates store definition resource</li>
<li>Computes CID</li>
<li>Stores resource in the store</li>
<li>The store now contains its own definition</li>
</ol>
<p><strong>Result</strong>: The store is <strong>introspectable</strong>—its definition exists as a resource.</p>
<p><strong>What’s Still Hard-Coded</strong>: Projection engine (doesn’t exist yet).</p>
<h3 id="layer-2-projection-language-hologramprojection"><a class="header" href="#layer-2-projection-language-hologramprojection">Layer 2: Projection Language (hologram.projection)</a></h3>
<p><strong>What Happens</strong>: Emit the projection language definition as resources.</p>
<p><strong>Resource Content</strong>:</p>
<ul>
<li>Projection definition schema (what fields projection definitions have)</li>
<li>Conformance requirement schema (how to specify conformance)</li>
<li>Query language schema (how to express queries)</li>
<li>Transformation rule schema (how to define transformations)</li>
</ul>
<p><strong>Process</strong>:</p>
<ol>
<li>Hard-coded bootstrap code creates projection language definition</li>
<li>Stores as resources in the store</li>
<li>Hard-coded minimal projection engine loads these definitions</li>
<li>Engine can now interpret projection definitions</li>
</ol>
<p><strong>Result</strong>: The projection language is <strong>self-defined</strong>—its schema exists as resources.</p>
<p><strong>What’s Still Hard-Coded</strong>: Minimal projection engine (can interpret but is hard-coded).</p>
<h3 id="layer-3-base-container-schemas"><a class="header" href="#layer-3-base-container-schemas">Layer 3: Base Container Schemas</a></h3>
<p><strong>What Happens</strong>: Emit schemas for base container types.</p>
<p><strong>Resource Content</strong>:</p>
<ul>
<li>hologram.component schema</li>
<li>hologram.instance schema</li>
<li>hologram.interface schema</li>
<li>hologram.documentation schema</li>
<li>hologram.test schema</li>
<li>hologram.manager schema</li>
<li>hologram.view schema</li>
<li>hologram.dependency schema</li>
<li>hologram.build schema</li>
<li>hologram.log schema</li>
</ul>
<p><strong>Process</strong>:</p>
<ol>
<li>Bootstrap code creates JSON Schema definitions for each container type</li>
<li>Stores schemas as resources</li>
<li>Engine can now validate resources against these schemas</li>
</ol>
<p><strong>Result</strong>: Container types are <strong>schema-defined</strong> rather than hard-coded.</p>
<p><strong>What’s Still Hard-Coded</strong>: Operation implementations (projection engine can validate but not execute operations).</p>
<h3 id="layer-4-projection-definitions"><a class="header" href="#layer-4-projection-definitions">Layer 4: Projection Definitions</a></h3>
<p><strong>What Happens</strong>: Emit projection definitions for each container type.</p>
<p><strong>Resource Content</strong>: For each container type, a projection definition specifying:</p>
<ul>
<li>Query to identify resources</li>
<li>Conformance requirements (what resources must be present)</li>
<li>Aggregation rules (how to follow references)</li>
<li>Transformation rules (how to structure container)</li>
<li>Schema references (what schemas apply)</li>
</ul>
<p><strong>Process</strong>:</p>
<ol>
<li>Bootstrap code creates projection definitions using projection language from Layer 2</li>
<li>Stores projection definitions as resources</li>
<li>Engine loads projection definitions</li>
<li>Engine can now project resources into containers per definitions</li>
</ol>
<p><strong>Result</strong>: Container types are <strong>projection-defined</strong> rather than hard-coded.</p>
<p><strong>What’s Still Hard-Coded</strong>: Basic projection engine logic (query evaluation, reference traversal, transformation application).</p>
<h3 id="layer-5-engine-definition-hologramengine"><a class="header" href="#layer-5-engine-definition-hologramengine">Layer 5: Engine Definition (hologram.engine)</a></h3>
<p><strong>What Happens</strong>: Emit the projection engine’s own definition as resources.</p>
<p><strong>Resource Content</strong>:</p>
<ul>
<li>Engine capabilities (query execution, traversal, transformation)</li>
<li>Engine algorithm descriptions (how it processes projections)</li>
<li>Engine extension points (how to add custom query types, validators, transformations)</li>
</ul>
<p><strong>Process</strong>:</p>
<ol>
<li>Bootstrap code creates engine definition</li>
<li>Stores as resources in the store</li>
<li>Advanced implementations could use this to build engines (compilation, optimization)</li>
</ol>
<p><strong>Result</strong>: The engine is <strong>self-described</strong>—its behavior is documented in resources.</p>
<p><strong>What’s Still Hard-Coded</strong>: Actual engine implementation (but its behavior is defined in resources).</p>
<h3 id="layer-6-operation-definitions"><a class="header" href="#layer-6-operation-definitions">Layer 6: Operation Definitions</a></h3>
<p><strong>What Happens</strong>: Emit operation definitions as projection definitions.</p>
<p><strong>Resource Content</strong>: For each operation (component.create, instance.start, etc.):</p>
<ul>
<li>Input schema</li>
<li>Projection phase specification</li>
<li>Execution logic description</li>
<li>Emission pattern</li>
<li>Output schema</li>
</ul>
<p><strong>Process</strong>:</p>
<ol>
<li>Bootstrap code creates operation definitions</li>
<li>Stores as resources</li>
<li>Platform can now execute operations per definitions</li>
</ol>
<p><strong>Result</strong>: Operations are <strong>definition-driven</strong> rather than hard-coded.</p>
<p><strong>What’s Still Hard-Coded</strong>: Execution logic for operations (projections define what to do, but implementation executes it).</p>
<h3 id="layer-7-complete-self-description"><a class="header" href="#layer-7-complete-self-description">Layer 7: Complete Self-Description</a></h3>
<p><strong>What Happens</strong>: The platform contains complete definition of itself.</p>
<p><strong>What’s in Store</strong>:</p>
<ul>
<li>Store definition</li>
<li>Projection language definition</li>
<li>All container type schemas and projection definitions</li>
<li>Engine definition</li>
<li>Operation definitions</li>
<li>Platform API definition</li>
<li>Bootstrap process definition (this document as a resource!)</li>
</ul>
<p><strong>Result</strong>: The platform is <strong>fully self-describing</strong>—everything about its behavior exists as resources.</p>
<p><strong>What’s Still Hard-Coded</strong>: Only Layer 0 (minimal CAS store) and basic projection engine execution. Everything else is defined in resources.</p>
<h2 id="bootstrap-sequence"><a class="header" href="#bootstrap-sequence">Bootstrap Sequence</a></h2>
<p>The actual initialization sequence when starting a Hologram platform:</p>
<h3 id="step-1-initialize-store"><a class="header" href="#step-1-initialize-store">Step 1: Initialize Store</a></h3>
<p>Start with empty or existing content-addressed store.</p>
<p>If empty: create minimal store implementation.</p>
<p>If existing: load store and check for bootstrap resources.</p>
<h3 id="step-2-check-bootstrap-state"><a class="header" href="#step-2-check-bootstrap-state">Step 2: Check Bootstrap State</a></h3>
<p>Query store for bootstrap marker resource.</p>
<p>If not present: platform is uninitialized, proceed with bootstrap.</p>
<p>If present: platform is already bootstrapped, load existing definitions.</p>
<h3 id="step-3-emit-foundation-resources-if-bootstrapping"><a class="header" href="#step-3-emit-foundation-resources-if-bootstrapping">Step 3: Emit Foundation Resources (if bootstrapping)</a></h3>
<p>Execute Layer 0-2 bootstrap:</p>
<ol>
<li>Emit hologram.store definition</li>
<li>Emit hologram.projection definition</li>
<li>Emit projection language schemas</li>
</ol>
<h3 id="step-4-initialize-minimal-engine"><a class="header" href="#step-4-initialize-minimal-engine">Step 4: Initialize Minimal Engine</a></h3>
<p>Create minimal projection engine with hard-coded logic:</p>
<ul>
<li>Basic query evaluation</li>
<li>Reference traversal</li>
<li>Schema validation</li>
<li>Simple transformations</li>
</ul>
<p>Engine loads projection language definitions from store.</p>
<h3 id="step-5-emit-container-definitions"><a class="header" href="#step-5-emit-container-definitions">Step 5: Emit Container Definitions</a></h3>
<p>Execute Layer 3-4 bootstrap:</p>
<ol>
<li>Emit base container type schemas</li>
<li>Emit projection definitions for each container type</li>
</ol>
<p>Engine can now project these container types.</p>
<h3 id="step-6-emit-operation-definitions"><a class="header" href="#step-6-emit-operation-definitions">Step 6: Emit Operation Definitions</a></h3>
<p>Execute Layer 6 bootstrap:</p>
<ol>
<li>Emit operation definitions for all platform operations</li>
</ol>
<p>Platform can now execute operations per definitions.</p>
<h3 id="step-7-emit-bootstrap-marker"><a class="header" href="#step-7-emit-bootstrap-marker">Step 7: Emit Bootstrap Marker</a></h3>
<p>Create bootstrap marker resource indicating:</p>
<ul>
<li>Bootstrap completion timestamp</li>
<li>Platform version</li>
<li>Definitions emitted</li>
</ul>
<p>Emit marker to store.</p>
<h3 id="step-8-verify-bootstrap"><a class="header" href="#step-8-verify-bootstrap">Step 8: Verify Bootstrap</a></h3>
<p>Execute validation projection:</p>
<ol>
<li>Project all bootstrap resources</li>
<li>Verify schemas valid</li>
<li>Verify projection definitions valid</li>
<li>Verify operations defined</li>
</ol>
<p>If validation passes: bootstrap complete.</p>
<p>If validation fails: abort, report errors.</p>
<h3 id="step-9-enter-normal-operation"><a class="header" href="#step-9-enter-normal-operation">Step 9: Enter Normal Operation</a></h3>
<p>Platform is now fully bootstrapped and operational.</p>
<p>All operations use projection-emission cycle.</p>
<p>Platform is self-describing and can introspect its own definitions.</p>
<h2 id="bootstrap-resources"><a class="header" href="#bootstrap-resources">Bootstrap Resources</a></h2>
<p>The bootstrap resources are the <strong>platform kernel</strong>—minimal set of resources required for self-describing operation.</p>
<p>These resources form the <strong>base projection set</strong> that all other projections build upon.</p>
<p>Bootstrap resources should be:</p>
<ul>
<li>Minimal (only essential definitions)</li>
<li>Stable (rarely change, only for platform evolution)</li>
<li>Well-documented (critical to platform understanding)</li>
<li>Versioned (enable platform upgrades)</li>
</ul>
<h2 id="incremental-bootstrap"><a class="header" href="#incremental-bootstrap">Incremental Bootstrap</a></h2>
<p>For large platforms, bootstrap can be incremental:</p>
<p><strong>Phase 1</strong>: Core projection system (Layers 0-4).</p>
<p><strong>Phase 2</strong>: Base operations (component CRUD, instance lifecycle).</p>
<p><strong>Phase 3</strong>: Extended container types (dependency, build, log).</p>
<p><strong>Phase 4</strong>: Views and optimization (catalog, materialized views).</p>
<p><strong>Phase 5</strong>: Advanced features (distributed execution, federation).</p>
<p>Each phase emits resources, expands platform capabilities, enables next phase.</p>
<h2 id="bootstrap-from-import"><a class="header" href="#bootstrap-from-import">Bootstrap from Import</a></h2>
<p>Instead of hard-coded bootstrap, platform can bootstrap from resource import:</p>
<p><strong>Step 1</strong>: Start with minimal store + engine.</p>
<p><strong>Step 2</strong>: Import bootstrap resources from external source:</p>
<ul>
<li>File bundle</li>
<li>Remote repository</li>
<li>Another Hologram instance</li>
</ul>
<p><strong>Step 3</strong>: Engine loads imported definitions.</p>
<p><strong>Step 4</strong>: Platform operational.</p>
<p>This enables platform distribution as resource bundles.</p>
<h2 id="bootstrap-verification"><a class="header" href="#bootstrap-verification">Bootstrap Verification</a></h2>
<p>After bootstrap, verify platform consistency:</p>
<p><strong>Definition Consistency</strong>: All projection definitions reference valid schemas.</p>
<p><strong>Schema Validity</strong>: All schemas are well-formed JSON Schema.</p>
<p><strong>Reference Integrity</strong>: All CID references in bootstrap resources exist.</p>
<p><strong>Operation Completeness</strong>: All required operations are defined.</p>
<p><strong>Engine Capability</strong>: Engine can execute all projection types defined.</p>
<p>Verification ensures bootstrap produced valid platform state.</p>
<h2 id="evolution-after-bootstrap"><a class="header" href="#evolution-after-bootstrap">Evolution After Bootstrap</a></h2>
<p>Once bootstrapped, the platform evolves through normal projection-emission:</p>
<p><strong>New Container Types</strong>: Emit new projection definitions → new container types available.</p>
<p><strong>New Operations</strong>: Emit new operation definitions → new operations executable.</p>
<p><strong>Improved Schemas</strong>: Emit updated schemas → refined validation.</p>
<p><strong>Platform Updates</strong>: Emit updated bootstrap resources → platform evolves.</p>
<p>Evolution uses the same mechanisms as application development.</p>
<h2 id="the-minimal-kernel"><a class="header" href="#the-minimal-kernel">The Minimal Kernel</a></h2>
<p>What must remain hard-coded (cannot be bootstrapped away)?</p>
<p><strong>Content-Addressed Storage</strong>: The fundamental primitive (store, retrieve, reference, query).</p>
<p><strong>Projection Execution</strong>: The ability to evaluate projections (though projection definitions can describe how).</p>
<p><strong>Resource Serialization</strong>: Converting between in-memory and byte representations.</p>
<p>These form the <strong>irreducible kernel</strong>—the minimal hard-coded logic required.</p>
<p>Everything else can be defined as resources through projections.</p>
<h2 id="bootstrap-reproducibility"><a class="header" href="#bootstrap-reproducibility">Bootstrap Reproducibility</a></h2>
<p>Bootstrap should be reproducible:</p>
<ul>
<li>Same bootstrap code produces same resources</li>
<li>Same resources produce same CIDs</li>
<li>Same CIDs produce identical platform state</li>
</ul>
<p>Reproducibility enables:</p>
<ul>
<li>Deterministic platform creation</li>
<li>Verification of platform integrity</li>
<li>Consistency across distributed instances</li>
</ul>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<p>With bootstrap complete, the platform exhibits key properties that make it robust and evolvable. The next document, <strong>Platform Properties</strong>, describes the guarantees, characteristics, and emergent properties that result from the projection-emission model.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-properties"><a class="header" href="#platform-properties">Platform Properties</a></h1>
<h2 id="guarantees-and-emergent-characteristics"><a class="header" href="#guarantees-and-emergent-characteristics">Guarantees and Emergent Characteristics</a></h2>
<p>The Hologram platform exhibits fundamental properties that emerge from its projection-emission architecture. These properties provide guarantees about platform behavior and enable powerful capabilities.</p>
<p>This document catalogs the platform’s key properties—both guaranteed invariants and emergent characteristics.</p>
<h2 id="immutability-2"><a class="header" href="#immutability-2">Immutability</a></h2>
<h3 id="property"><a class="header" href="#property">Property</a></h3>
<p>Resources in the container store <strong>never change</strong> after emission. Once a resource is stored with a CID, that CID always refers to the same content.</p>
<h3 id="guarantees"><a class="header" href="#guarantees">Guarantees</a></h3>
<p><strong>Stable References</strong>: A CID reference is永permanent and reliable—it will always retrieve the same content.</p>
<p><strong>Historical Completeness</strong>: All versions of evolving data persist as distinct resources. No information is lost through updates.</p>
<p><strong>Concurrent Safety</strong>: Multiple readers can access the same resource without coordination—it will never change under them.</p>
<p><strong>Verifiable Integrity</strong>: Retrieved content can be hashed and verified against the CID cryptographically.</p>
<h3 id="implications"><a class="header" href="#implications">Implications</a></h3>
<p><strong>Versioning is Natural</strong>: Updates create new resources with new CIDs, automatically creating version history.</p>
<p><strong>Caching is Simple</strong>: Immutable resources can be cached indefinitely without invalidation concerns.</p>
<p><strong>Distribution is Safe</strong>: Resources can be copied between stores without synchronization—content identity is preserved.</p>
<p><strong>Audit Trails are Built-In</strong>: Complete operation history exists as immutable resources.</p>
<h2 id="content-addressing"><a class="header" href="#content-addressing">Content Addressing</a></h2>
<h3 id="property-1"><a class="header" href="#property-1">Property</a></h3>
<p>Resources are identified by <strong>cryptographic hash of their content</strong>, not by location or assigned identifiers.</p>
<h3 id="guarantees-1"><a class="header" href="#guarantees-1">Guarantees</a></h3>
<p><strong>Identity from Content</strong>: Identical content produces identical CID regardless of when, where, or by whom it was created.</p>
<p><strong>Collision Resistance</strong>: Different content produces different CIDs with cryptographic probability.</p>
<p><strong>Deduplication</strong>: Identical content stored multiple times occupies space once.</p>
<p><strong>Location Independence</strong>: CID is valid across stores, networks, time—content can move freely.</p>
<h3 id="implications-1"><a class="header" href="#implications-1">Implications</a></h3>
<p><strong>Global Namespace</strong>: CIDs are globally unique without coordination or central registry.</p>
<p><strong>Trustless Verification</strong>: Content authenticity verifiable without trusting the source.</p>
<p><strong>Efficient Storage</strong>: No redundant copies of shared resources (common dependencies, standard libraries).</p>
<p><strong>Portable References</strong>: CID references work across platform instances and implementations.</p>
<h2 id="projection-purity-1"><a class="header" href="#projection-purity-1">Projection Purity</a></h2>
<h3 id="property-2"><a class="header" href="#property-2">Property</a></h3>
<p>Projections are <strong>pure queries</strong> that do not modify the store or produce side effects.</p>
<h3 id="guarantees-2"><a class="header" href="#guarantees-2">Guarantees</a></h3>
<p><strong>Determinism</strong>: Same store state and parameters always produce same projection result.</p>
<p><strong>Repeatability</strong>: Projections can be executed multiple times without affecting results.</p>
<p><strong>Concurrency</strong>: Multiple projections execute safely in parallel without interference.</p>
<p><strong>Reproducibility</strong>: Historical projections can be re-executed against historical store state.</p>
<h3 id="implications-2"><a class="header" href="#implications-2">Implications</a></h3>
<p><strong>Testing is Straightforward</strong>: Projections testable with known resource sets and expected results.</p>
<p><strong>Debugging is Possible</strong>: Projection failures reproducible with same inputs.</p>
<p><strong>Optimization is Safe</strong>: Caching, parallelization, reordering don’t affect semantics.</p>
<p><strong>Temporal Queries Work</strong>: Projecting historical state produces accurate historical views.</p>
<h2 id="emission-atomicity-1"><a class="header" href="#emission-atomicity-1">Emission Atomicity</a></h2>
<h3 id="property-3"><a class="header" href="#property-3">Property</a></h3>
<p>Emissions are <strong>atomic operations</strong>—resources are either fully stored and indexed, or not stored at all.</p>
<h3 id="guarantees-3"><a class="header" href="#guarantees-3">Guarantees</a></h3>
<p><strong>No Partial Writes</strong>: Resources are complete and valid or don’t exist.</p>
<p><strong>Consistent State</strong>: Store remains consistent regardless of emission success or failure.</p>
<p><strong>Transaction Support</strong>: Multiple related emissions succeed or fail together.</p>
<p><strong>Recovery from Failure</strong>: Failed emissions leave no partial state requiring cleanup.</p>
<h3 id="implications-3"><a class="header" href="#implications-3">Implications</a></h3>
<p><strong>Operations are Reliable</strong>: Operations either complete successfully or fail cleanly.</p>
<p><strong>Concurrent Emissions Safe</strong>: Multiple clients emitting concurrently maintain consistency.</p>
<p><strong>Error Recovery Simple</strong>: Failed operations can be retried without cleanup.</p>
<p><strong>Multi-Resource Consistency</strong>: Component definitions with multiple resources appear atomically.</p>
<h2 id="extensibility"><a class="header" href="#extensibility">Extensibility</a></h2>
<h3 id="property-4"><a class="header" href="#property-4">Property</a></h3>
<p>New container types, operations, and capabilities can be added by <strong>emitting new projection definitions</strong>.</p>
<h3 id="guarantees-4"><a class="header" href="#guarantees-4">Guarantees</a></h3>
<p><strong>No Platform Modification Required</strong>: Extension through resource emission, not code changes.</p>
<p><strong>Backward Compatibility</strong>: Existing projections continue working when new projections added.</p>
<p><strong>Composition Supported</strong>: New projections can compose existing projections.</p>
<p><strong>Version Coexistence</strong>: Multiple versions of projections can exist simultaneously.</p>
<h3 id="implications-4"><a class="header" href="#implications-4">Implications</a></h3>
<p><strong>Platform Evolves Continuously</strong>: New capabilities added without platform downtime.</p>
<p><strong>Domain-Specific Extensions</strong>: Applications can define custom container types for their needs.</p>
<p><strong>Experimentation is Safe</strong>: New projections can be tested without affecting existing system.</p>
<p><strong>Migration is Gradual</strong>: Old and new projection versions coexist during transitions.</p>
<h2 id="self-description"><a class="header" href="#self-description">Self-Description</a></h2>
<h3 id="property-5"><a class="header" href="#property-5">Property</a></h3>
<p>The platform <strong>contains its own definition</strong> as resources in the store.</p>
<h3 id="guarantees-5"><a class="header" href="#guarantees-5">Guarantees</a></h3>
<p><strong>Introspectable</strong>: Platform behavior is documented in resources, accessible via projections.</p>
<p><strong>Evolvable</strong>: Platform definition can be updated by emitting new definition resources.</p>
<p><strong>Bootstrappable</strong>: New platform instances can initialize from definition resources.</p>
<p><strong>Documentable</strong>: Platform documentation exists as resources, version-controlled with platform.</p>
<h3 id="implications-5"><a class="header" href="#implications-5">Implications</a></h3>
<p><strong>Understanding is Accessible</strong>: Projecting platform definitions reveals how platform works.</p>
<p><strong>Meta-Operations Possible</strong>: Operations that analyze or transform platform definitions.</p>
<p><strong>Migration is Defined</strong>: Platform upgrades are resource updates, trackable and reversible.</p>
<p><strong>Consistency Verifiable</strong>: Platform definition consistency checkable via projections.</p>
<h2 id="auditability-1"><a class="header" href="#auditability-1">Auditability</a></h2>
<h3 id="property-6"><a class="header" href="#property-6">Property</a></h3>
<p>All operations leave <strong>immutable audit trails</strong> as emitted resources.</p>
<h3 id="guarantees-6"><a class="header" href="#guarantees-6">Guarantees</a></h3>
<p><strong>Complete History</strong>: Every operation, emission, and state change recorded.</p>
<p><strong>Tamper-Evident</strong>: Immutable resources and content addressing prevent undetectable modification.</p>
<p><strong>Traceable</strong>: Resource reference graph shows relationships and provenance.</p>
<p><strong>Queryable</strong>: Audit data is projectable like any resources.</p>
<h3 id="implications-6"><a class="header" href="#implications-6">Implications</a></h3>
<p><strong>Compliance Enabled</strong>: Regulatory audit requirements satisfiable from store content.</p>
<p><strong>Debugging Informed</strong>: Complete history available for investigating issues.</p>
<p><strong>Attribution Clear</strong>: Who emitted what resources when is recorded.</p>
<p><strong>Reproducibility Supported</strong>: Historical operations reproducible from audit data.</p>
<h2 id="composability-2"><a class="header" href="#composability-2">Composability</a></h2>
<h3 id="property-7"><a class="header" href="#property-7">Property</a></h3>
<p>Projections, operations, and containers <strong>compose cleanly</strong> without tight coupling.</p>
<h3 id="guarantees-7"><a class="header" href="#guarantees-7">Guarantees</a></h3>
<p><strong>Hierarchical Composition</strong>: Projections can project other projections.</p>
<p><strong>Operation Chaining</strong>: Operations compose into workflows.</p>
<p><strong>Container Reuse</strong>: Containers participate in multiple projections.</p>
<p><strong>Independent Evolution</strong>: Composed elements evolve independently.</p>
<h3 id="implications-7"><a class="header" href="#implications-7">Implications</a></h3>
<p><strong>Complex from Simple</strong>: Sophisticated capabilities built from basic projections.</p>
<p><strong>Reusability High</strong>: Components, projections, operations reused across contexts.</p>
<p><strong>Coupling Low</strong>: Changes to one projection don’t require changes to others.</p>
<p><strong>Modularity Maintained</strong>: System organized as composable modules, not monolith.</p>
<h2 id="consistency-models"><a class="header" href="#consistency-models">Consistency Models</a></h2>
<h3 id="property-8"><a class="header" href="#property-8">Property</a></h3>
<p>The platform supports <strong>multiple consistency models</strong> appropriate to different use cases.</p>
<h3 id="guarantees-8"><a class="header" href="#guarantees-8">Guarantees</a></h3>
<p><strong>Strong Consistency Available</strong>: Operations can require immediate consistency when critical.</p>
<p><strong>Eventual Consistency Supported</strong>: Operations can accept eventual consistency for performance.</p>
<p><strong>Snapshot Consistency Provided</strong>: Projections can use consistent historical snapshots.</p>
<p><strong>Client Choice</strong>: Consistency level selected per operation.</p>
<h3 id="implications-8"><a class="header" href="#implications-8">Implications</a></h3>
<p><strong>Flexibility</strong>: Applications choose appropriate tradeoffs between consistency and performance.</p>
<p><strong>Scalability</strong>: Eventual consistency enables distributed, high-throughput scenarios.</p>
<p><strong>Correctness</strong>: Strong consistency ensures critical operations maintain invariants.</p>
<p><strong>Optimization</strong>: Views and caches use eventual consistency without compromising safety.</p>
<h2 id="distribution"><a class="header" href="#distribution">Distribution</a></h2>
<h3 id="property-9"><a class="header" href="#property-9">Property</a></h3>
<p>Resources and projections are <strong>location-independent</strong> and distributable.</p>
<h3 id="guarantees-9"><a class="header" href="#guarantees-9">Guarantees</a></h3>
<p><strong>CID Portability</strong>: CIDs valid across distributed stores.</p>
<p><strong>Content Synchronization</strong>: Resources copyable between stores with identity preserved.</p>
<p><strong>Projection Mobility</strong>: Projections executable on any store containing required resources.</p>
<p><strong>Decentralization Possible</strong>: No required central coordinator or master.</p>
<h3 id="implications-9"><a class="header" href="#implications-9">Implications</a></h3>
<p><strong>Federation Enabled</strong>: Multiple Hologram instances can federate, sharing resources.</p>
<p><strong>Edge Computing Supported</strong>: Projections executable at edge with local resource subset.</p>
<p><strong>Disaster Recovery Simple</strong>: Stores replicable for redundancy and recovery.</p>
<p><strong>Geographic Distribution</strong>: Resources locatable near users for performance.</p>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<h3 id="property-10"><a class="header" href="#property-10">Property</a></h3>
<p>The platform exhibits predictable <strong>performance characteristics</strong> based on resource access patterns.</p>
<h3 id="guarantees-10"><a class="header" href="#guarantees-10">Guarantees</a></h3>
<p><strong>Content Retrieval O(1)</strong>: Direct CID retrieval is constant time (hash table lookup).</p>
<p><strong>Deduplication Automatic</strong>: Storage scales with unique content, not total references.</p>
<p><strong>Projection Cost Proportional</strong>: Projection cost scales with resources accessed, not store size.</p>
<p><strong>Caching Effective</strong>: Immutability enables aggressive caching without invalidation complexity.</p>
<h3 id="implications-10"><a class="header" href="#implications-10">Implications</a></h3>
<p><strong>Scalability Predictable</strong>: Performance behavior understood and plannable.</p>
<p><strong>Optimization Opportunities</strong>: Materialized views, indexes, caching optimize common patterns.</p>
<p><strong>Resource Planning</strong>: Storage and compute requirements estimable from usage patterns.</p>
<p><strong>Bottleneck Identification</strong>: Performance issues traceable to specific projection or emission patterns.</p>
<h2 id="backward-compatibility"><a class="header" href="#backward-compatibility">Backward Compatibility</a></h2>
<h3 id="property-11"><a class="header" href="#property-11">Property</a></h3>
<p>Platform evolution maintains <strong>backward compatibility</strong> through projection versioning.</p>
<h3 id="guarantees-11"><a class="header" href="#guarantees-11">Guarantees</a></h3>
<p><strong>Old Projections Work</strong>: Existing projection definitions continue functioning after platform updates.</p>
<p><strong>Old Resources Accessible</strong>: Historical resources remain retrievable and projectable.</p>
<p><strong>Version Coexistence</strong>: Multiple projection versions available simultaneously.</p>
<p><strong>Gradual Migration</strong>: Systems transition from old to new projections at their own pace.</p>
<h3 id="implications-11"><a class="header" href="#implications-11">Implications</a></h3>
<p><strong>Breaking Changes Avoidable</strong>: New projection versions published alongside old versions.</p>
<p><strong>Deprecation Gradual</strong>: Old projections marked deprecated but remain functional.</p>
<p><strong>Migration Risk Low</strong>: New versions testable before switching production systems.</p>
<p><strong>Long-Term Stability</strong>: Systems built on Hologram remain functional through platform evolution.</p>
<h2 id="resource-efficiency"><a class="header" href="#resource-efficiency">Resource Efficiency</a></h2>
<h3 id="property-12"><a class="header" href="#property-12">Property</a></h3>
<p>The platform minimizes <strong>resource consumption</strong> through deduplication and structural sharing.</p>
<h3 id="guarantees-12"><a class="header" href="#guarantees-12">Guarantees</a></h3>
<p><strong>No Redundant Storage</strong>: Identical content stored once regardless of reference count.</p>
<p><strong>Efficient Updates</strong>: Updates share unchanged resources, storing only differences.</p>
<p><strong>Lazy Loading</strong>: Resources retrieved only when projected, not preemptively.</p>
<p><strong>Garbage Collection</strong>: Unreferenced resources reclaimable to free storage.</p>
<h3 id="implications-12"><a class="header" href="#implications-12">Implications</a></h3>
<p><strong>Storage Costs Bounded</strong>: Storage grows with unique content, deduplicating redundancy.</p>
<p><strong>Network Efficiency</strong>: Only missing resources transferred between stores.</p>
<p><strong>Memory Efficiency</strong>: Projection engine loads only required resources.</p>
<p><strong>Cost Optimization</strong>: Storage and transfer costs minimized through structural sharing.</p>
<h2 id="temporal-capabilities"><a class="header" href="#temporal-capabilities">Temporal Capabilities</a></h2>
<h3 id="property-13"><a class="header" href="#property-13">Property</a></h3>
<p>Immutability enables <strong>time-travel queries</strong> and historical projections.</p>
<h3 id="guarantees-13"><a class="header" href="#guarantees-13">Guarantees</a></h3>
<p><strong>Historical State Preserved</strong>: All resource versions remain in store.</p>
<p><strong>Temporal Projections Valid</strong>: Projections can target specific points in time.</p>
<p><strong>Consistency Across Time</strong>: Historical projections produce consistent views of past state.</p>
<p><strong>Provenance Trackable</strong>: Resource creation and modification timeline reconstructable.</p>
<h3 id="implications-13"><a class="header" href="#implications-13">Implications</a></h3>
<p><strong>Debugging Simplified</strong>: Issues reproducible by projecting historical state.</p>
<p><strong>Compliance Supported</strong>: Historical compliance queries answerable.</p>
<p><strong>Analytics Enabled</strong>: Time-series analysis of platform state and resources.</p>
<p><strong>Undo Possible</strong>: Reverting to previous state means projecting historical resources.</p>
<h2 id="security-properties"><a class="header" href="#security-properties">Security Properties</a></h2>
<h3 id="property-14"><a class="header" href="#property-14">Property</a></h3>
<p>Content addressing and immutability provide <strong>security foundations</strong>.</p>
<h3 id="guarantees-14"><a class="header" href="#guarantees-14">Guarantees</a></h3>
<p><strong>Integrity Verification</strong>: Content authenticity cryptographically verifiable.</p>
<p><strong>Tamper Detection</strong>: Any modification changes CID, making tampering evident.</p>
<p><strong>Access Control Enforcement</strong>: Store can enforce read/write permissions per resource or namespace.</p>
<p><strong>Audit Trail Immutable</strong>: Audit resources cannot be altered retroactively.</p>
<h3 id="implications-14"><a class="header" href="#implications-14">Implications</a></h3>
<p><strong>Trust Minimized</strong>: Verify content cryptographically rather than trusting source.</p>
<p><strong>Compliance Enhanced</strong>: Immutable audit trails satisfy regulatory requirements.</p>
<p><strong>Attack Surface Reduced</strong>: Immutability eliminates modification attacks.</p>
<p><strong>Provenance Verifiable</strong>: Resource origin and modification history checkable.</p>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<p>These properties emerge from the platform’s architecture, but realizing them requires implementation decisions. The next document, <strong>Implementation Considerations</strong>, discusses how to implement the platform—architectural patterns, technology choices, performance optimization, and practical tradeoffs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation-considerations"><a class="header" href="#implementation-considerations">Implementation Considerations</a></h1>
<h2 id="architectural-patterns-and-practical-tradeoffs"><a class="header" href="#architectural-patterns-and-practical-tradeoffs">Architectural Patterns and Practical Tradeoffs</a></h2>
<p>Implementing the Hologram platform requires translating the conceptual model into running systems. This document provides guidance on implementation architecture, technology choices, optimization strategies, and practical tradeoffs—without prescribing specific implementations.</p>
<h2 id="implementation-principles"><a class="header" href="#implementation-principles">Implementation Principles</a></h2>
<h3 id="separation-of-concerns"><a class="header" href="#separation-of-concerns">Separation of Concerns</a></h3>
<p>Implementations should separate:</p>
<p><strong>Store Backend</strong>: Content-addressed storage implementation (filesystem, database, object storage).</p>
<p><strong>Projection Engine</strong>: Interprets projection definitions and executes projections.</p>
<p><strong>API Layer</strong>: Protocol bindings (HTTP, MCP, CLI) that expose operations to clients.</p>
<p><strong>Operation Logic</strong>: Implements execution phase of operations.</p>
<p><strong>Client Libraries</strong>: Language-specific wrappers for API consumption.</p>
<p>Clean separation enables:</p>
<ul>
<li>Independent evolution of each component</li>
<li>Multiple backend options without changing engine</li>
<li>Multiple API protocols without changing operations</li>
<li>Testing components in isolation</li>
</ul>
<h3 id="implementation-independence-1"><a class="header" href="#implementation-independence-1">Implementation Independence</a></h3>
<p>The platform model is abstract—multiple valid implementations exist:</p>
<p><strong>Language Choices</strong>: TypeScript, Go, Rust, Python, Java, or any language with serialization and hashing.</p>
<p><strong>Store Backends</strong>: Filesystem, PostgreSQL, SQLite, MongoDB, S3, IPFS, or custom.</p>
<p><strong>Engine Strategies</strong>: Interpreted, compiled, JIT, or distributed execution.</p>
<p><strong>API Protocols</strong>: HTTP/REST, gRPC, GraphQL, MCP, or custom protocols.</p>
<p>The model’s semantics remain consistent across implementations.</p>
<h2 id="store-implementation-patterns"><a class="header" href="#store-implementation-patterns">Store Implementation Patterns</a></h2>
<h3 id="filesystem-backend"><a class="header" href="#filesystem-backend">Filesystem Backend</a></h3>
<p><strong>Structure</strong>: Content-addressed files in directory hierarchy.</p>
<p><strong>CID to Path Mapping</strong>: Typically first N hex digits as subdirectories for distribution (e.g., <code>ab/cd/abcd123...</code>).</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Simple implementation</li>
<li>Works with standard filesystem tools</li>
<li>Git-compatible (if using predictable formatting)</li>
<li>Easy backup and replication</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Poor query performance (requires scanning)</li>
<li>Limited concurrent write scalability</li>
<li>No built-in indexing</li>
</ul>
<p><strong>Best For</strong>: Small to medium stores, development, git-integrated workflows.</p>
<h3 id="relational-database-backend"><a class="header" href="#relational-database-backend">Relational Database Backend</a></h3>
<p><strong>Structure</strong>: Resources as BLOBs in tables, CIDs as primary keys.</p>
<p><strong>Schema</strong>:</p>
<ul>
<li>Resources table: (CID, content, content_type, timestamp, size)</li>
<li>References table: (source_CID, target_CID) for edges</li>
<li>Metadata tables: indexes for queries</li>
</ul>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Efficient queries via SQL</li>
<li>ACID transactions for atomicity</li>
<li>Mature tooling and operations</li>
<li>Scalable with proper indexing</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Schema somewhat rigid</li>
<li>Large BLOBs can stress database</li>
<li>More complex setup than filesystem</li>
</ul>
<p><strong>Best For</strong>: Medium to large stores, production systems, complex queries.</p>
<h3 id="object-storage-backend"><a class="header" href="#object-storage-backend">Object Storage Backend</a></h3>
<p><strong>Structure</strong>: Resources as objects in cloud storage (S3, Azure Blob, GCS).</p>
<p><strong>Key Scheme</strong>: CID as object key.</p>
<p><strong>Metadata</strong>: Object metadata stores content type, timestamps.</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Massive scalability</li>
<li>High durability and availability</li>
<li>Cost-effective for large stores</li>
<li>Geographic distribution</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Higher latency than local storage</li>
<li>Query requires external index</li>
<li>Cost per API call</li>
<li>Network dependency</li>
</ul>
<p><strong>Best For</strong>: Large-scale, distributed, cloud-native deployments.</p>
<h3 id="hybrid-architectures"><a class="header" href="#hybrid-architectures">Hybrid Architectures</a></h3>
<p><strong>Local + Remote</strong>: Local filesystem cache, remote object storage for persistence.</p>
<p><strong>Database + Object Storage</strong>: Database for metadata and small resources, object storage for large artifacts.</p>
<p><strong>Tiered Storage</strong>: Hot data in fast storage (SSD, database), cold data in cheap storage (object storage, archive).</p>
<p>Hybrid architectures balance performance, scalability, and cost.</p>
<h2 id="indexing-strategies"><a class="header" href="#indexing-strategies">Indexing Strategies</a></h2>
<h3 id="content-indexing"><a class="header" href="#content-indexing">Content Indexing</a></h3>
<p>For efficient queries, index resource content:</p>
<p><strong>Full-Text Search</strong>: Index textual content for search queries (Elasticsearch, PostgreSQL FTS).</p>
<p><strong>Field Indexing</strong>: Extract and index specific JSON fields (namespace, version, tags).</p>
<p><strong>Spatial Indexing</strong>: For geographic or geometric data (PostGIS).</p>
<p>Indexing trades storage and indexing cost for query performance.</p>
<h3 id="reference-indexing"><a class="header" href="#reference-indexing">Reference Indexing</a></h3>
<p>Index the resource reference graph:</p>
<p><strong>Forward References</strong>: Given a resource, what does it reference (adjacency list).</p>
<p><strong>Reverse References</strong>: What resources reference this one (reverse index).</p>
<p><strong>Graph Database</strong>: Specialized graph databases (Neo4j) for complex graph queries.</p>
<p>Reference indexes enable efficient dependency resolution and graph traversal.</p>
<h3 id="metadata-indexing"><a class="header" href="#metadata-indexing">Metadata Indexing</a></h3>
<p>Index store metadata:</p>
<p><strong>Timestamp Indexes</strong>: Query resources by emission time.</p>
<p><strong>Size Indexes</strong>: Find large resources, compute storage statistics.</p>
<p><strong>Access Indexes</strong>: Track access patterns for cache optimization.</p>
<p>Metadata indexes support operations beyond content queries.</p>
<h2 id="projection-engine-architecture"><a class="header" href="#projection-engine-architecture">Projection Engine Architecture</a></h2>
<h3 id="interpreter-pattern"><a class="header" href="#interpreter-pattern">Interpreter Pattern</a></h3>
<p>Engine interprets projection definitions at runtime:</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Simple implementation</li>
<li>No compilation step</li>
<li>Dynamic projection definitions</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Slower execution than compiled</li>
<li>Less optimization opportunity</li>
</ul>
<p><strong>Best For</strong>: Prototypes, small scales, frequently changing projections.</p>
<h3 id="compiler-pattern"><a class="header" href="#compiler-pattern">Compiler Pattern</a></h3>
<p>Engine compiles projection definitions to native code:</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Faster execution</li>
<li>Optimization opportunities (inlining, loop unrolling)</li>
<li>Better resource utilization</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Complex implementation</li>
<li>Compilation overhead</li>
<li>Requires compilation infrastructure</li>
</ul>
<p><strong>Best For</strong>: Production systems, performance-critical, stable projections.</p>
<h3 id="hybrid-pattern"><a class="header" href="#hybrid-pattern">Hybrid Pattern</a></h3>
<p>Interpret initially, compile hot projections:</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Fast startup (no compilation wait)</li>
<li>Optimized steady-state (compiled hot paths)</li>
<li>Adaptive to workload</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Most complex implementation</li>
<li>Profiling and monitoring overhead</li>
</ul>
<p><strong>Best For</strong>: Large-scale production with varied workloads.</p>
<h2 id="caching-strategies"><a class="header" href="#caching-strategies">Caching Strategies</a></h2>
<h3 id="resource-content-caching"><a class="header" href="#resource-content-caching">Resource Content Caching</a></h3>
<p>Cache retrieved resource content:</p>
<p><strong>LRU Cache</strong>: Evict least recently used resources when cache full.</p>
<p><strong>Size-Aware Cache</strong>: Evict based on resource size and access patterns.</p>
<p><strong>Tiered Cache</strong>: Memory cache for hot resources, disk cache for warm resources.</p>
<p>Content caching dramatically reduces store access for repeated retrievals.</p>
<h3 id="projection-result-caching"><a class="header" href="#projection-result-caching">Projection Result Caching</a></h3>
<p>Cache projected containers:</p>
<p><strong>Key</strong>: (Projection definition CID, parameters, store version).</p>
<p><strong>Invalidation</strong>: Invalidate when underlying resources change.</p>
<p><strong>TTL</strong>: Time-to-live for eventual consistency.</p>
<p>Result caching avoids re-executing expensive projections.</p>
<h3 id="index-caching"><a class="header" href="#index-caching">Index Caching</a></h3>
<p>Cache query results and indexes:</p>
<p><strong>Query Result Cache</strong>: Cache results of common queries.</p>
<p><strong>Materialized Views</strong>: Pre-compute and cache complex projections as view resources.</p>
<p>Index caching optimizes read-heavy workloads.</p>
<h2 id="concurrency-and-parallelism"><a class="header" href="#concurrency-and-parallelism">Concurrency and Parallelism</a></h2>
<h3 id="concurrent-projections"><a class="header" href="#concurrent-projections">Concurrent Projections</a></h3>
<p>Multiple projections can execute concurrently:</p>
<p><strong>Read Parallelism</strong>: Projections are pure queries, safe to parallelize.</p>
<p><strong>Resource Pooling</strong>: Share resource retrieval across concurrent projections.</p>
<p><strong>Batch Optimization</strong>: Group resource retrievals from concurrent projections.</p>
<p>Concurrent projection execution scales with available cores.</p>
<h3 id="concurrent-emissions"><a class="header" href="#concurrent-emissions">Concurrent Emissions</a></h3>
<p>Multiple emissions require coordination:</p>
<p><strong>Optimistic Concurrency</strong>: Emit independently, rely on content addressing for deduplication.</p>
<p><strong>Transactional Emissions</strong>: Use store backend transactions for atomic multi-resource emissions.</p>
<p><strong>Partition by Namespace</strong>: Partition store by namespace for independent emission streams.</p>
<p>Emission concurrency balances consistency and throughput.</p>
<h3 id="distributed-execution"><a class="header" href="#distributed-execution">Distributed Execution</a></h3>
<p>For large-scale systems, distribute work:</p>
<p><strong>Partition Store</strong>: Distribute resources across nodes by CID range.</p>
<p><strong>Projection Routing</strong>: Route projection requests to nodes holding required resources.</p>
<p><strong>Result Aggregation</strong>: Gather partial results from multiple nodes.</p>
<p>Distribution enables horizontal scalability beyond single-node limits.</p>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="query-optimization"><a class="header" href="#query-optimization">Query Optimization</a></h3>
<p>Optimize projection query evaluation:</p>
<p><strong>Index Selection</strong>: Use indexes for selective queries.</p>
<p><strong>Query Planning</strong>: Analyze projection definition, choose optimal execution plan.</p>
<p><strong>Predicate Pushdown</strong>: Evaluate filters early to reduce data scanned.</p>
<p>Query optimization is critical for large stores with complex projections.</p>
<h3 id="traversal-optimization"><a class="header" href="#traversal-optimization">Traversal Optimization</a></h3>
<p>Optimize reference traversal:</p>
<p><strong>Breadth-First vs Depth-First</strong>: Choose based on projection pattern and cache characteristics.</p>
<p><strong>Lazy Loading</strong>: Retrieve referenced resources only when needed.</p>
<p><strong>Prefetching</strong>: Predict and prefetch likely-needed resources.</p>
<p><strong>Parallel Traversal</strong>: Follow multiple references concurrently.</p>
<p>Traversal optimization reduces latency for deep or wide reference graphs.</p>
<h3 id="serialization-optimization"><a class="header" href="#serialization-optimization">Serialization Optimization</a></h3>
<p>Optimize resource serialization/deserialization:</p>
<p><strong>Binary Formats</strong>: Use efficient binary formats (Protocol Buffers, MessagePack) over JSON where appropriate.</p>
<p><strong>Compression</strong>: Compress resources at rest and in transit.</p>
<p><strong>Streaming</strong>: Stream large resources rather than loading entirely into memory.</p>
<p>Serialization efficiency impacts both storage and transmission costs.</p>
<h2 id="scalability-patterns"><a class="header" href="#scalability-patterns">Scalability Patterns</a></h2>
<h3 id="vertical-scaling"><a class="header" href="#vertical-scaling">Vertical Scaling</a></h3>
<p>Single-node optimization:</p>
<p><strong>Memory</strong>: More RAM for larger caches, holding more resources.</p>
<p><strong>CPU</strong>: More cores for concurrent projection execution.</p>
<p><strong>Storage</strong>: Faster storage (NVMe SSD) for quicker resource access.</p>
<p>Vertical scaling is simpler but has hard limits.</p>
<h3 id="horizontal-scaling"><a class="header" href="#horizontal-scaling">Horizontal Scaling</a></h3>
<p>Multi-node distribution:</p>
<p><strong>Replication</strong>: Replicate entire store across nodes (read scaling).</p>
<p><strong>Sharding</strong>: Partition store across nodes (write scaling, storage scaling).</p>
<p><strong>Load Balancing</strong>: Distribute requests across nodes.</p>
<p>Horizontal scaling enables near-unlimited capacity but increases complexity.</p>
<h3 id="caching-tiers"><a class="header" href="#caching-tiers">Caching Tiers</a></h3>
<p>Multi-level caching:</p>
<p><strong>L1: In-Process Memory</strong>: Fastest, smallest, per-node.</p>
<p><strong>L2: Distributed Cache</strong>: Fast, larger, shared (Redis, Memcached).</p>
<p><strong>L3: Store Backend</strong>: Slower, largest, durable.</p>
<p>Tiered caching balances speed, capacity, and cost.</p>
<h2 id="error-handling-and-resilience"><a class="header" href="#error-handling-and-resilience">Error Handling and Resilience</a></h2>
<h3 id="failure-modes"><a class="header" href="#failure-modes">Failure Modes</a></h3>
<p>Handle common failures:</p>
<p><strong>Store Unavailable</strong>: Retry with exponential backoff, fail request if timeout exceeded.</p>
<p><strong>Resource Not Found</strong>: Return clear error, suggest checking CID or dependencies.</p>
<p><strong>Validation Failure</strong>: Return detailed validation errors for fixing.</p>
<p><strong>Timeout</strong>: For long operations, support cancellation and resume.</p>
<p>Graceful failure handling improves user experience.</p>
<h3 id="recovery-strategies"><a class="header" href="#recovery-strategies">Recovery Strategies</a></h3>
<p>Recover from failures:</p>
<p><strong>Idempotent Retries</strong>: Operations are idempotent, safe to retry.</p>
<p><strong>Transaction Rollback</strong>: Roll back partial emissions on failure.</p>
<p><strong>Checkpointing</strong>: For long operations, checkpoint progress for resume.</p>
<p>Recovery strategies enable robust operations despite failures.</p>
<h3 id="consistency-maintenance"><a class="header" href="#consistency-maintenance">Consistency Maintenance</a></h3>
<p>Ensure store consistency:</p>
<p><strong>Validation on Emit</strong>: Validate resources before emission, reject invalid.</p>
<p><strong>Reference Checking</strong>: Ensure referenced CIDs exist (or defer to projection time).</p>
<p><strong>Garbage Collection</strong>: Periodically remove unreferenced resources to reclaim space.</p>
<p>Consistency maintenance prevents store corruption.</p>
<h2 id="monitoring-and-observability"><a class="header" href="#monitoring-and-observability">Monitoring and Observability</a></h2>
<h3 id="metrics"><a class="header" href="#metrics">Metrics</a></h3>
<p>Track platform health:</p>
<p><strong>Store Metrics</strong>: Size, growth rate, resource count, retrieval latency.</p>
<p><strong>Projection Metrics</strong>: Execution count, latency, cache hit rate, failure rate.</p>
<p><strong>Emission Metrics</strong>: Emission rate, validation failure rate, transaction rollback rate.</p>
<p><strong>API Metrics</strong>: Request rate, latency, error rate per operation.</p>
<p>Metrics enable proactive issue detection and capacity planning.</p>
<h3 id="tracing"><a class="header" href="#tracing">Tracing</a></h3>
<p>Trace requests through system:</p>
<p><strong>Distributed Tracing</strong>: Track projection execution across components (OpenTelemetry).</p>
<p><strong>Resource Access Tracing</strong>: Record which resources are accessed during projections.</p>
<p><strong>Emission Tracing</strong>: Track emission flows from operation to store.</p>
<p>Tracing enables debugging complex distributed operations.</p>
<h3 id="logging"><a class="header" href="#logging">Logging</a></h3>
<p>Log platform activity:</p>
<p><strong>Operation Logs</strong>: Record operations executed, parameters, results.</p>
<p><strong>Error Logs</strong>: Detailed error information for troubleshooting.</p>
<p><strong>Audit Logs</strong>: Security-relevant events (authentication, authorization, sensitive operations).</p>
<p>Structured logging enables searching and analysis.</p>
<h2 id="security-implementation"><a class="header" href="#security-implementation">Security Implementation</a></h2>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<p>Verify client identity:</p>
<p><strong>API Keys</strong>: Simple, suitable for service-to-service.</p>
<p><strong>OAuth/OIDC</strong>: Standard for user authentication.</p>
<p><strong>Mutual TLS</strong>: Certificate-based for high-security scenarios.</p>
<p>Authentication establishes who is making requests.</p>
<h3 id="authorization"><a class="header" href="#authorization">Authorization</a></h3>
<p>Enforce access control:</p>
<p><strong>RBAC</strong>: Role-based access control (roles grant permissions).</p>
<p><strong>ABAC</strong>: Attribute-based access control (context-dependent permissions).</p>
<p><strong>Resource-Level ACLs</strong>: Permissions per resource or namespace.</p>
<p>Authorization determines what authenticated clients can do.</p>
<h3 id="encryption"><a class="header" href="#encryption">Encryption</a></h3>
<p>Protect data:</p>
<p><strong>At Rest</strong>: Encrypt resources in store backend.</p>
<p><strong>In Transit</strong>: TLS for all network communication.</p>
<p><strong>End-to-End</strong>: Clients encrypt before emission, decrypt after projection (for sensitive data).</p>
<p>Encryption protects confidentiality.</p>
<h2 id="testing-strategies"><a class="header" href="#testing-strategies">Testing Strategies</a></h2>
<h3 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h3>
<p>Test components in isolation:</p>
<p><strong>Store Interface</strong>: Test CRUD operations, CID generation, deduplication.</p>
<p><strong>Projection Engine</strong>: Test query evaluation, traversal, transformation with mock store.</p>
<p><strong>Operations</strong>: Test operation logic with mock projections and emissions.</p>
<p>Unit tests validate individual components.</p>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<p>Test components together:</p>
<p><strong>Operation End-to-End</strong>: Submit artifacts, create component, validate, retrieve.</p>
<p><strong>Projection Composition</strong>: Test nested and sequential projections.</p>
<p><strong>Failure Scenarios</strong>: Test error handling, recovery, rollback.</p>
<p>Integration tests validate component interactions.</p>
<h3 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h3>
<p>Measure performance characteristics:</p>
<p><strong>Load Testing</strong>: Measure throughput and latency under load.</p>
<p><strong>Stress Testing</strong>: Find breaking points and failure modes.</p>
<p><strong>Scalability Testing</strong>: Verify horizontal and vertical scaling behavior.</p>
<p>Performance tests validate scalability and identify bottlenecks.</p>
<h2 id="deployment-patterns"><a class="header" href="#deployment-patterns">Deployment Patterns</a></h2>
<h3 id="single-node-deployment"><a class="header" href="#single-node-deployment">Single-Node Deployment</a></h3>
<p>Simple deployment:</p>
<p><strong>Components</strong>: Store backend, engine, API server on one node.</p>
<p><strong>Suitable For</strong>: Development, small deployments, proof-of-concept.</p>
<p><strong>Advantages</strong>: Simple, low cost, easy to manage.</p>
<p><strong>Disadvantages</strong>: Limited scale, single point of failure.</p>
<h3 id="distributed-deployment"><a class="header" href="#distributed-deployment">Distributed Deployment</a></h3>
<p>Multi-node deployment:</p>
<p><strong>Components</strong>: Store backend distributed/replicated, multiple engine nodes, load balancer.</p>
<p><strong>Suitable For</strong>: Production, large scale, high availability.</p>
<p><strong>Advantages</strong>: Scalable, resilient, high performance.</p>
<p><strong>Disadvantages</strong>: Complex, higher cost, requires orchestration.</p>
<h3 id="cloud-native-deployment"><a class="header" href="#cloud-native-deployment">Cloud-Native Deployment</a></h3>
<p>Containerized, orchestrated deployment:</p>
<p><strong>Technologies</strong>: Docker containers, Kubernetes orchestration, cloud-managed storage.</p>
<p><strong>Suitable For</strong>: Cloud environments, microservices architectures, elastic scaling.</p>
<p><strong>Advantages</strong>: Portable, scalable, declarative configuration.</p>
<p><strong>Disadvantages</strong>: Complexity, cloud dependency, learning curve.</p>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<p>This document provides implementation guidance without prescribing specific technologies. The final document, <strong>Terminology</strong>, provides a glossary of terms used throughout the documentation and maps Hologram concepts to established computer science terminology.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<h2 id="glossary-and-cross-references"><a class="header" href="#glossary-and-cross-references">Glossary and Cross-References</a></h2>
<p>This document defines key terms used throughout the Hologram documentation and maps them to established computer science concepts.</p>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="container-store"><a class="header" href="#container-store">Container Store</a></h3>
<p>The universal storage system where all resources exist as immutable, content-addressed data.</p>
<p><strong>Related CS Concepts</strong>: Content-addressable storage (CAS), content-addressable memory, immutable data stores, append-only logs.</p>
<p><strong>See</strong>: Document 02 - The Container Store</p>
<h3 id="resource"><a class="header" href="#resource">Resource</a></h3>
<p>Any sequence of bytes stored in the container store. Resources have no inherent type or structure—meaning emerges through projection.</p>
<p><strong>Related CS Concepts</strong>: Blob (Binary Large Object), untyped data, raw data, resource (REST).</p>
<p><strong>See</strong>: Document 02 - The Container Store</p>
<h3 id="content-identifier-cid"><a class="header" href="#content-identifier-cid">Content Identifier (CID)</a></h3>
<p>A cryptographic hash of a resource’s content, used as the resource’s identifier. Identical content produces identical CIDs.</p>
<p><strong>Related CS Concepts</strong>: Content hash, cryptographic hash, checksum, digest, content addressing, self-certifying identifier.</p>
<p><strong>See</strong>: Document 02 - The Container Store</p>
<h3 id="immutability-3"><a class="header" href="#immutability-3">Immutability</a></h3>
<p>Resources never change after emission. Once stored, a resource’s content is permanent. Updates create new resources with new CIDs.</p>
<p><strong>Related CS Concepts</strong>: Immutable data structures, persistent data structures, write-once storage, append-only.</p>
<p><strong>See</strong>: Document 02 - The Container Store, Document 13 - Platform Properties</p>
<h2 id="projection-concepts"><a class="header" href="#projection-concepts">Projection Concepts</a></h2>
<h3 id="projection"><a class="header" href="#projection">Projection</a></h3>
<p>A query-based definition that identifies, aggregates, and transforms resources into a container. Projections are pure queries without side effects.</p>
<p><strong>Related CS Concepts</strong>: View (database), query, transformation, lens (functional programming), map/reduce, query language.</p>
<p><strong>See</strong>: Document 04 - Container Projections</p>
<h3 id="container"><a class="header" href="#container">Container</a></h3>
<p>A structured collection of resources produced by projecting resources from the store. Containers have defined purpose and relationships.</p>
<p><strong>Related CS Concepts</strong>: View (database), aggregate (DDD), composite object, container (general programming).</p>
<p><strong>See</strong>: Document 04 - Container Projections</p>
<h3 id="projection-definition"><a class="header" href="#projection-definition">Projection Definition</a></h3>
<p>A resource that specifies how to project resources into containers, including query criteria, aggregation rules, and transformations.</p>
<p><strong>Related CS Concepts</strong>: View definition, query definition, schema, specification, declarative program.</p>
<p><strong>See</strong>: Document 06 - The Projection Language</p>
<h3 id="conformance-requirements-1"><a class="header" href="#conformance-requirements-1">Conformance Requirements</a></h3>
<p>Instructions within projection definitions specifying what resources must be present and how they should be structured. Conformance defines projection, not just validation.</p>
<p><strong>Related CS Concepts</strong>: Constraints, schema, type specification, contract, invariant.</p>
<p><strong>See</strong>: Document 06 - The Projection Language</p>
<h3 id="projection-engine"><a class="header" href="#projection-engine">Projection Engine</a></h3>
<p>The component that interprets projection definitions and executes them against the container store to produce containers.</p>
<p><strong>Related CS Concepts</strong>: Query engine, interpreter, virtual machine, execution engine, runtime.</p>
<p><strong>See</strong>: Document 05 - The Projection Engine</p>
<h2 id="emission-concepts"><a class="header" href="#emission-concepts">Emission Concepts</a></h2>
<h3 id="emission"><a class="header" href="#emission">Emission</a></h3>
<p>The process of writing execution results back to the container store as new resources. Emissions make ephemeral results durable.</p>
<p><strong>Related CS Concepts</strong>: Write operation, persistence, materialization, output, side effect (though emissions are structured).</p>
<p><strong>See</strong>: Document 07 - The Emission Model</p>
<h3 id="projection-emission-cycle"><a class="header" href="#projection-emission-cycle">Projection-Emission Cycle</a></h3>
<p>The fundamental operating principle: Project resources → Execute operations → Emit results → Store resources → Repeat.</p>
<p><strong>Related CS Concepts</strong>: Read-compute-write cycle, ETL (Extract-Transform-Load), data pipeline, event loop.</p>
<p><strong>See</strong>: Document 03 - The Projection-Emission Cycle</p>
<h3 id="emission-stream"><a class="header" href="#emission-stream">Emission Stream</a></h3>
<p>A sequence of emissions produced continuously over time, such as logs or state snapshots from a running instance.</p>
<p><strong>Related CS Concepts</strong>: Event stream, log stream, observable, reactive stream, data stream.</p>
<p><strong>See</strong>: Document 07 - The Emission Model</p>
<h2 id="container-types-1"><a class="header" href="#container-types-1">Container Types</a></h2>
<h3 id="component-container"><a class="header" href="#component-container">Component Container</a></h3>
<p>A container defining a reusable capability through specifications, interfaces, documentation, tests, and dependencies.</p>
<p><strong>Related CS Concepts</strong>: Module, package, library, service definition, component (software engineering).</p>
<p><strong>See</strong>: Document 08 - Container Types</p>
<h3 id="instance-container"><a class="header" href="#instance-container">Instance Container</a></h3>
<p>A container representing a running execution of a component definition with runtime state.</p>
<p><strong>Related CS Concepts</strong>: Process, object instance, runtime instance, container instance (Docker), actor (actor model).</p>
<p><strong>See</strong>: Document 08 - Container Types</p>
<h3 id="interface-container"><a class="header" href="#interface-container">Interface Container</a></h3>
<p>A container specifying contracts between components through method signatures and type definitions.</p>
<p><strong>Related CS Concepts</strong>: Interface (OOP), API specification, contract, protocol, abstract base class.</p>
<p><strong>See</strong>: Document 08 - Container Types</p>
<h3 id="view-container"><a class="header" href="#view-container">View Container</a></h3>
<p>A materialized projection stored as a resource for efficient repeated access.</p>
<p><strong>Related CS Concepts</strong>: Materialized view (database), cached result, denormalized data, index, summary table.</p>
<p><strong>See</strong>: Document 08 - Container Types, Document 09 - Platform Views</p>
<h3 id="documentation-container"><a class="header" href="#documentation-container">Documentation Container</a></h3>
<p>A container providing human-readable explanations, guides, and examples.</p>
<p><strong>Related CS Concepts</strong>: Documentation, readme, manual, help text, javadoc/docstring.</p>
<p><strong>See</strong>: Document 08 - Container Types</p>
<h3 id="test-container"><a class="header" href="#test-container">Test Container</a></h3>
<p>A container defining validation logic for verifying component behavior.</p>
<p><strong>Related CS Concepts</strong>: Test suite, test case, test spec, unit test, integration test.</p>
<p><strong>See</strong>: Document 08 - Container Types</p>
<h2 id="platform-architecture"><a class="header" href="#platform-architecture">Platform Architecture</a></h2>
<h3 id="bootstrap"><a class="header" href="#bootstrap">Bootstrap</a></h3>
<p>The process of initializing the platform from minimal primitives to a fully self-describing system.</p>
<p><strong>Related CS Concepts</strong>: Bootstrapping, cold start, system initialization, self-hosting compiler.</p>
<p><strong>See</strong>: Document 12 - Bootstrap Architecture</p>
<h3 id="operation"><a class="header" href="#operation">Operation</a></h3>
<p>A named procedure that projects resources, executes logic, and emits results. Operations are the platform’s verbs.</p>
<p><strong>Related CS Concepts</strong>: Command (CQRS), action, method, procedure, RPC call, API endpoint.</p>
<p><strong>See</strong>: Document 10 - Platform Operations</p>
<h3 id="platform-api-1"><a class="header" href="#platform-api-1">Platform API</a></h3>
<p>The client interface for interacting with the platform—submitting operations, retrieving resources, subscribing to emissions.</p>
<p><strong>Related CS Concepts</strong>: API, SDK, client library, REST API, RPC interface.</p>
<p><strong>See</strong>: Document 11 - Platform API</p>
<h2 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced Concepts</a></h2>
<h3 id="self-description-1"><a class="header" href="#self-description-1">Self-Description</a></h3>
<p>The property that the platform contains its own definition as resources in the store. The platform can introspect and evolve itself.</p>
<p><strong>Related CS Concepts</strong>: Reflection, introspection, self-hosting, metacircular evaluation, reflective architecture.</p>
<p><strong>See</strong>: Document 13 - Platform Properties</p>
<h3 id="meta-projection"><a class="header" href="#meta-projection">Meta-Projection</a></h3>
<p>A projection that projects other projection definitions. Projections analyzing or transforming projections.</p>
<p><strong>Related CS Concepts</strong>: Meta-programming, reflection, higher-order function, metaobject protocol.</p>
<p><strong>See</strong>: Document 05 - The Projection Engine</p>
<h3 id="temporal-projection"><a class="header" href="#temporal-projection">Temporal Projection</a></h3>
<p>A projection targeting resources as they existed at a specific point in time. Time-travel queries.</p>
<p><strong>Related CS Concepts</strong>: Temporal database, time-travel query, historical query, version control, snapshot.</p>
<p><strong>See</strong>: Document 04 - Container Projections</p>
<h3 id="reference-graph"><a class="header" href="#reference-graph">Reference Graph</a></h3>
<p>The directed graph formed by CID references between resources. Nodes are resources, edges are references.</p>
<p><strong>Related CS Concepts</strong>: Directed graph, object graph, reference graph, dependency graph, DAG (if acyclic).</p>
<p><strong>See</strong>: Document 02 - The Container Store</p>
<h3 id="garbage-collection-1"><a class="header" href="#garbage-collection-1">Garbage Collection</a></h3>
<p>The process of identifying and removing unreferenced resources to reclaim storage space.</p>
<p><strong>Related CS Concepts</strong>: Garbage collection, reference counting, mark-and-sweep, reachability analysis.</p>
<p><strong>See</strong>: Document 02 - The Container Store</p>
<h2 id="established-cs-mappings"><a class="header" href="#established-cs-mappings">Established CS Mappings</a></h2>
<h3 id="hologram--database-systems"><a class="header" href="#hologram--database-systems">Hologram → Database Systems</a></h3>
<ul>
<li><strong>Container Store</strong> ↔ Database</li>
<li><strong>Resource</strong> ↔ Row/Document</li>
<li><strong>CID</strong> ↔ Primary Key (content-derived)</li>
<li><strong>Projection</strong> ↔ Query/View</li>
<li><strong>Emission</strong> ↔ INSERT/UPDATE</li>
<li><strong>View</strong> ↔ Materialized View</li>
<li><strong>Reference Graph</strong> ↔ Foreign Keys/Relationships</li>
</ul>
<h3 id="hologram--functional-programming"><a class="header" href="#hologram--functional-programming">Hologram → Functional Programming</a></h3>
<ul>
<li><strong>Projection</strong> ↔ Pure Function</li>
<li><strong>Container</strong> ↔ Product Type/Record</li>
<li><strong>Projection Definition</strong> ↔ Function Definition</li>
<li><strong>Projection Composition</strong> ↔ Function Composition</li>
<li><strong>Immutability</strong> ↔ Immutable Data Structures</li>
<li><strong>Conformance</strong> ↔ Type Constraint</li>
</ul>
<h3 id="hologram--content-addressed-storage"><a class="header" href="#hologram--content-addressed-storage">Hologram → Content-Addressed Storage</a></h3>
<ul>
<li><strong>Container Store</strong> ↔ CAS (Git, IPFS, Merkle DAG)</li>
<li><strong>CID</strong> ↔ SHA hash, Content Address</li>
<li><strong>Resource</strong> ↔ Object, Blob</li>
<li><strong>Reference</strong> ↔ Pointer, Link</li>
<li><strong>Immutability</strong> ↔ Content Addressing Property</li>
</ul>
<h3 id="hologram--version-control"><a class="header" href="#hologram--version-control">Hologram → Version Control</a></h3>
<ul>
<li><strong>Emission</strong> ↔ Commit</li>
<li><strong>CID</strong> ↔ Commit Hash</li>
<li><strong>Reference Graph</strong> ↔ Commit Graph</li>
<li><strong>View</strong> ↔ Working Directory</li>
<li><strong>Temporal Projection</strong> ↔ Checkout Historical Commit</li>
</ul>
<h3 id="hologram--container-orchestration"><a class="header" href="#hologram--container-orchestration">Hologram → Container Orchestration</a></h3>
<ul>
<li><strong>Component</strong> ↔ Container Image</li>
<li><strong>Instance</strong> ↔ Running Container</li>
<li><strong>Manager</strong> ↔ Orchestrator (Kubernetes)</li>
<li><strong>Operation</strong> ↔ Controller Action</li>
<li><strong>Platform</strong> ↔ Container Runtime</li>
</ul>
<h3 id="hologram--object-oriented-programming"><a class="header" href="#hologram--object-oriented-programming">Hologram → Object-Oriented Programming</a></h3>
<ul>
<li><strong>Component</strong> ↔ Class</li>
<li><strong>Instance</strong> ↔ Object Instance</li>
<li><strong>Interface</strong> ↔ Interface/Abstract Class</li>
<li><strong>Operation</strong> ↔ Method</li>
<li><strong>Conformance</strong> ↔ Type Constraint/Contract</li>
</ul>
<h2 id="document-cross-references"><a class="header" href="#document-cross-references">Document Cross-References</a></h2>
<h3 id="foundation-concepts"><a class="header" href="#foundation-concepts">Foundation Concepts</a></h3>
<ul>
<li>Container Store: Document 02</li>
<li>Projection-Emission Cycle: Document 03</li>
<li>Container Projections: Document 04</li>
</ul>
<h3 id="engine-and-language"><a class="header" href="#engine-and-language">Engine and Language</a></h3>
<ul>
<li>Projection Engine: Document 05</li>
<li>Projection Language: Document 06</li>
<li>Emission Model: Document 07</li>
</ul>
<h3 id="platform-components"><a class="header" href="#platform-components">Platform Components</a></h3>
<ul>
<li>Container Types: Document 08</li>
<li>Platform Views: Document 09</li>
<li>Platform Operations: Document 10</li>
<li>Platform API: Document 11</li>
</ul>
<h3 id="system-architecture"><a class="header" href="#system-architecture">System Architecture</a></h3>
<ul>
<li>Bootstrap: Document 12</li>
<li>Properties: Document 13</li>
<li>Implementation: Document 14</li>
</ul>
<h2 id="acronyms-and-abbreviations"><a class="header" href="#acronyms-and-abbreviations">Acronyms and Abbreviations</a></h2>
<p><strong>API</strong>: Application Programming Interface</p>
<p><strong>CAS</strong>: Content-Addressed Storage</p>
<p><strong>CID</strong>: Content Identifier</p>
<p><strong>CRUD</strong>: Create, Read, Update, Delete</p>
<p><strong>DAG</strong>: Directed Acyclic Graph</p>
<p><strong>JSON</strong>: JavaScript Object Notation</p>
<p><strong>MCP</strong>: Model Context Protocol</p>
<p><strong>REST</strong>: Representational State Transfer</p>
<p><strong>SHA</strong>: Secure Hash Algorithm</p>
<p><strong>TTL</strong>: Time To Live</p>
<h2 id="conventions"><a class="header" href="#conventions">Conventions</a></h2>
<h3 id="naming-patterns"><a class="header" href="#naming-patterns">Naming Patterns</a></h3>
<p><strong>hologram.{type}</strong>: Platform-provided base container types (hologram.component, hologram.instance).</p>
<p><strong>{namespace}.{name}</strong>: Application-defined resources following namespace pattern.</p>
<p><strong>{operation}.{action}</strong>: Operation naming (component.create, instance.start).</p>
<h3 id="cid-format"><a class="header" href="#cid-format">CID Format</a></h3>
<p>CIDs are typically represented as:</p>
<ul>
<li>Prefix: “cid:” (optional, implementation-dependent)</li>
<li>Hash: Hexadecimal digest of content</li>
<li>Example: “cid:abc123def456…” or “abc123def456…”</li>
</ul>
<h3 id="resource-references"><a class="header" href="#resource-references">Resource References</a></h3>
<p>Resources reference other resources by embedding CIDs in their content, typically as string values in JSON fields.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This terminology document provides definitions for key concepts and maps them to established computer science concepts. Understanding these mappings helps situate Hologram within the broader context of computing systems while appreciating its unique architectural approach.</p>
<hr />
<h2 id="the-complete-documentation"><a class="header" href="#the-complete-documentation">The Complete Documentation</a></h2>
<p>This completes the 15-document series on the Hologram Container Engine and Platform:</p>
<p><strong>Part I: Foundation</strong> - Documents 1-4 establish the core model from first principles.</p>
<p><strong>Part II: The Engine</strong> - Documents 5-7 detail the projection engine and emission mechanisms.</p>
<p><strong>Part III: The Platform</strong> - Documents 8-11 describe container types, views, operations, and API.</p>
<p><strong>Part IV: System Architecture</strong> - Documents 12-15 cover bootstrap, properties, implementation, and terminology.</p>
<p>Together, these documents define the conceptual model that hologram.spec implementations will realize.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
