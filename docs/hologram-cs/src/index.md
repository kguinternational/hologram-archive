# Index

## A

**Action functional** 122-125, 208-212, 315-320, 412-418
- density 125, 210
- landscape 418-420
- minimization 123, 209, 316-319
- sectors 124, 210-211

**Active window** 89-92, 156-159, 289-292
- management 291-292
- size optimization 290, 421
- verification 289-290

**Address map (H)** 62-65, 94-97
- collision-free property 64, 96-97
- computation 63, 95
- perfect hashing 62-65, 94-97

**Algorithmic reification** 105-110
- program as proof 106-107
- witness chains 107-109

## B

**Budget** 45-48, 78-81
- arithmetic 47, 80
- conservation 81, 294-295
- crush function 48, 81
- ledger 47-48, 80-81
- semiring (C‚Çâ‚ÇÜ) 46, 79

**Byzantine fault tolerance** 326-328
- detection 327
- receipt-based 326-327
- threshold 328, 422

## C

**C768 (Cycle structure)** 42-44, 76-78
- fairness invariants 43-44, 77-78
- schedule rotation 42-43, 76
- verification 296

**CAM (Content-Addressable Memory)** 58-65, 94-99
- deduplication 338-339
- perfect hash 62-65, 94-97
- storage implementation 408-409

**Category theory** 198-202, 421
- functors 200-201
- lawful configurations 199
- morphisms 199-200
- monoidal structure 201

**Compilation** 122-127, 208-215, 348-362
- as action minimization 123, 209, 349
- as stationarity 125-126, 212-213
- gauge alignment 356-357
- universal optimizer 348-350

**Configuration** 25-28, 55-58
- gauge equivalence 57-58
- lawful 58, 88
- space Œ£^ùïã 26, 56

**Consensus** 325-328
- Byzantine fault tolerance 326-328
- pipelined 328
- receipt-based 325-326

**Content addressing** 58-65, 94-99, 322-324
- deduplication 324, 338-339
- routing 323-324
- universal address space 322-323

**Convergence** 373-376
- certificates 373-374
- Lyapunov functions 374-375
- PAC bounds 375-376

**Crush function (‚ü®¬∑‚ü©)** 48, 81

## D

**Database systems** 336-347
- index-free architecture 336-337
- MVCC 343-344
- perfect hash tables 338
- query optimization 344-345

**Denotational semantics** 100-104
- budget calculus 102-103
- equational theory 103-104
- process objects 101-102

**Distributed systems** 322-335
- consensus 325-328
- content-addressed storage 322-324
- network protocols 329-331
- state machine replication 333
- transactions 332

## E

**Equational theory** 103-104, 136-137

**Expressivity** 196-197, 420
- characterizing functions 196
- embedding Œª-calculus 197

## F

**Fairness** 43-44, 77-78, 296

## G

**Gauge** 36-38, 69-71
- alignment (linking) 356-357
- classification problem 420
- fixing 60-61, 95-96
- invariance 37, 70
- transformations 37, 70

**Gradient-free optimization** 370-372
- evolutionary strategies 372
- quantum-inspired 371
- receipt-guided 370-371

## H

**Hardware acceleration** 423

## I

**Implementation** 402-417
- core structures 402-407
- example usage 416-417
- minimal kernel 311-314

**Incremental verification** 300

**Information objects** 24-25, 54-55
- intrinsic semantics 25, 55
- poly-ontological 85-87, 134-136

## J

**JIT compilation** 361-362
- action-guided 361
- adaptive recompilation 362

## L

**Lattice (ùïã)** 30-34, 66-69
- 12,288 structure 31, 67
- coordinates 32, 68
- memory layout 291
- neighborhoods 33, 68
- toroidal topology 31, 67

**Lawfulness** 28-29, 58-59, 82-89
- as type system 82-87
- domain 58-59
- verification 88-89

**Learning** see Machine learning

**Linear-time verification** 288-290
- active window 289-290
- streaming 289

**Lift operator (lift_Œ¶)** 44-45, 78-79

## M

**Machine learning** 366-382
- action flow 380-381
- convergence 373-376
- gradient-free 370-372
- neural networks 377-379
- single loss function 366-369
- task encoding 367-368

**Memory management** 290-292
- lattice layout 291
- window management 291-292

**Morphisms** 100-102, 272-273
- class-local 101, 272
- composition 102, 273
- identity 101, 272
- primitive types 272

**MVCC (Multi-Version Concurrency)** 343-344

## N

**Neural networks** 377-379
- attention mechanisms 379
- lattice networks 377-378

**Normal form (NF)** 60-61, 95-96
- canonicalization 61, 96
- uniqueness 61, 96

**Normalization** 198, 421

## O

**Observational equivalence** 104, 137

**Optimization** 122-127, 208-215, 358-360
- dead code elimination 359
- loop optimization 360
- passes 358-359
- universal framework 358

## P

**PAC learning** 375-376, 422

**Parallel execution** 283, 298-299
- lock-free operations 283
- verification 298-299
- work distribution 298

**Perfect hash** see Address map

**Phase transitions** 381-382, 423

**Œ¶ operator** 44-45, 78-79
- coherence verification 297
- lift 44, 78
- projection 45, 79
- round-trip 45, 79

**Poly-ontological** 85-87, 134-136
- coherence 421
- objects 85-86, 134-135
- type system 86-87, 135-136

**Process objects** 100-102, 409-411
- composition 102
- denotation 101
- grammar 100

**Projection operator (proj_Œ¶)** 45, 79

**Proof generation** 299-300
- succinct proofs 299
- zero-knowledge 300, 422

## Q

**Quantum** 371, 423
- implementation 423
- optimization 371

**Query** 337, 344-345
- as proof 337
- optimization 344-345

## R

**R96 (Resonance classes)** 40-42, 74-76
- checksum 41-42, 75-76
- digest computation 295
- verification 295-296

**Receipt** 45-48, 78-81, 275-277, 406-408
- authentication 330-331
- building 275-277
- chain validation 293-294
- components 46, 79, 275
- compression 277, 294
- consensus 325-326
- verification 295-297

**Research problems** 420-424
- categorization 420-423
- collaboration opportunities 424
- timeline 424

**Resonance** see R96

**Runtime architecture** 272-287
- concurrency control 283
- error handling 284
- morphism engine 272-274
- performance 283-284
- type checking 274-275

## S

**Schedule rotation (œÉ)** 42-43, 76
- C768 structure 42, 76
- fairness 43, 77

**Security** 142-145, 240-243
- collision resistance 144, 242
- integrity 143, 241
- memory safety 143, 241
- type safety 142, 240

**State machine replication** 333

**Storage engines** 346-347
- column-oriented 347
- LSM trees 346

## T

**Transactions** 332, 342-343
- ACID properties 342-343
- distributed 332
- receipt-coordinated 332

**Type checking** 274-275, 411-412
- budgeted 83-84, 132-133
- pipeline 274-275
- three-phase 274

**Type system** 82-89, 130-139
- budgeted judgments 83, 132
- constructors 84-85, 133-134
- poly-ontological 85-87, 134-136
- subtyping 85, 134

## U

**Universal optimizer** 348-350

## V

**Verification** 288-303
- budget conservation 294-295
- caching 301
- incremental 300
- linear-time 288-290
- parallel 298-299
- receipt 295-297
- witness chains 293-294

## W

**Window** see Active window

**Windowed resource classes** 108-109
- CC (Conservation-Checkable) 108
- HC (High-commutative) 109
- RC (Resonance-commutative) 108
- WC (Window-constrained) 109

**Witness** 107-109, 293-294, 413-414
- chain validation 293-294
- compression 294
- structure 293

## Z

**Zero-knowledge** 300, 422
- proofs 300
- receipts 422

**‚Ñ§/96** see Budget semiring

**12,288** 30-34, 66-69
- lattice structure 31, 67
- optimality 423
- = 48 √ó 256 factorization 31, 67

---

*Page numbers refer to chapter sections. Bold entries indicate primary definitions or main discussions of topics.*