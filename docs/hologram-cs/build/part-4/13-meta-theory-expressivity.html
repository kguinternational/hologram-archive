<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 13: Meta-Theory &amp; Expressivity - The Hologram (12,288): A Complete Computer Science Formalization</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A comprehensive computer science formalization of the 12,288 Hologram model of computation using mainstream CS formalisms">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title-page.html">Title Page</a></li><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="../readers-guide.html">Reader's Guide & Conventions</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part I: Mathematical Foundations</li><li class="chapter-item expanded "><a href="../part-1/01-information-as-lawful-structure.html"><strong aria-hidden="true">1.</strong> Chapter 1: Information as Lawful Structure</a></li><li class="chapter-item expanded "><a href="../part-1/02-universal-automaton.html"><strong aria-hidden="true">2.</strong> Chapter 2: The Universal Automaton</a></li><li class="chapter-item expanded "><a href="../part-1/03-labels-schedules-receipts.html"><strong aria-hidden="true">3.</strong> Chapter 3: Intrinsic Labels, Schedules, and Receipts</a></li><li class="chapter-item expanded "><a href="../part-1/04-content-addressable-memory.html"><strong aria-hidden="true">4.</strong> Chapter 4: Content-Addressable Memory</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part II: Algebraic Structure</li><li class="chapter-item expanded "><a href="../part-2/05-lawfulness-as-type-system.html"><strong aria-hidden="true">5.</strong> Chapter 5: Lawfulness as a Type System</a></li><li class="chapter-item expanded "><a href="../part-2/06-programs-as-geometry.html"><strong aria-hidden="true">6.</strong> Chapter 6: Programs as Geometry</a></li><li class="chapter-item expanded "><a href="../part-2/07-algorithmic-reification.html"><strong aria-hidden="true">7.</strong> Chapter 7: Algorithmic Reification</a></li><li class="chapter-item expanded "><a href="../part-2/08-universal-cost.html"><strong aria-hidden="true">8.</strong> Chapter 8: The Universal Cost</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part III: System Architecture</li><li class="chapter-item expanded "><a href="../part-3/09-security-safety-correctness.html"><strong aria-hidden="true">9.</strong> Chapter 9: Security, Safety, and Correctness</a></li><li class="chapter-item expanded "><a href="../part-3/10-worked-micro-examples.html"><strong aria-hidden="true">10.</strong> Chapter 10: Worked Micro-Examples</a></li><li class="chapter-item expanded "><a href="../part-3/11-interfaces-to-mainstream-cs.html"><strong aria-hidden="true">11.</strong> Chapter 11: Interfaces to Mainstream CS</a></li><li class="chapter-item expanded "><a href="../part-3/12-minimal-core.html"><strong aria-hidden="true">12.</strong> Chapter 12: Minimal Core</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part IV: Protocol Design</li><li class="chapter-item expanded "><a href="../part-4/13-meta-theory-expressivity.html" class="active"><strong aria-hidden="true">13.</strong> Chapter 13: Meta-Theory & Expressivity</a></li><li class="chapter-item expanded "><a href="../part-4/14-normalization-confluence.html"><strong aria-hidden="true">14.</strong> Chapter 14: Normalization & Confluence</a></li><li class="chapter-item expanded "><a href="../part-4/15-categorical-semantics.html"><strong aria-hidden="true">15.</strong> Chapter 15: Categorical Semantics</a></li><li class="chapter-item expanded "><a href="../part-4/16-security-proofs.html"><strong aria-hidden="true">16.</strong> Chapter 16: Security Proofs</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part V: Implementation</li><li class="chapter-item expanded "><a href="../part-5/17-optimization-landscape.html"><strong aria-hidden="true">17.</strong> Chapter 17: Optimization Landscape</a></li><li class="chapter-item expanded "><a href="../part-5/18-data-structure-implementation.html"><strong aria-hidden="true">18.</strong> Chapter 18: Data Structure Implementation</a></li><li class="chapter-item expanded "><a href="../part-5/19-runtime-architecture.html"><strong aria-hidden="true">19.</strong> Chapter 19: Runtime Architecture</a></li><li class="chapter-item expanded "><a href="../part-5/20-verification-system.html"><strong aria-hidden="true">20.</strong> Chapter 20: Verification System</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part VI: Applications</li><li class="chapter-item expanded "><a href="../part-6/21-distributed-systems.html"><strong aria-hidden="true">21.</strong> Chapter 21: Distributed Systems</a></li><li class="chapter-item expanded "><a href="../part-6/22-database-systems.html"><strong aria-hidden="true">22.</strong> Chapter 22: Database Systems</a></li><li class="chapter-item expanded "><a href="../part-6/23-compiler-construction.html"><strong aria-hidden="true">23.</strong> Chapter 23: Compiler Construction</a></li><li class="chapter-item expanded "><a href="../part-6/24-machine-learning-integration.html"><strong aria-hidden="true">24.</strong> Chapter 24: Machine Learning Integration</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="../appendices/A-glossary.html"><strong aria-hidden="true">25.</strong> Appendix A: Glossary</a></li><li class="chapter-item expanded "><a href="../appendices/B-mathematical-notation.html"><strong aria-hidden="true">26.</strong> Appendix B: Mathematical Notation</a></li><li class="chapter-item expanded "><a href="../appendices/C-cs-mappings.html"><strong aria-hidden="true">27.</strong> Appendix C: Side-by-Side CS Mappings</a></li><li class="chapter-item expanded "><a href="../appendices/D-exercise-solutions.html"><strong aria-hidden="true">28.</strong> Appendix D: Exercise Solutions</a></li><li class="chapter-item expanded "><a href="../appendices/E-implementation-code.html"><strong aria-hidden="true">29.</strong> Appendix E: Implementation Code</a></li><li class="chapter-item expanded "><a href="../appendices/F-research-problems.html"><strong aria-hidden="true">30.</strong> Appendix F: Research Problems</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../bibliography.html">Bibliography</a></li><li class="chapter-item expanded affix "><a href="../index.html">Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hologram (12,288): A Complete Computer Science Formalization</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/uor-foundation/hologram-cs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-13-meta-theory--expressivity"><a class="header" href="#chapter-13-meta-theory--expressivity">Chapter 13: Meta-Theory &amp; Expressivity</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>What can the 12,288 Hologram model actually compute? How does it relate to Church-Turing thesis? Can we embed lambda calculus or linear logic? This chapter characterizes the model’s expressivity, establishing both its power and its limits. We’ll prove that while the finite lattice seems restrictive, careful use of gauge freedom, content addressing, and temporal multiplexing yields surprising computational universality.</p>
<h2 id="characterizing-denotable-functions"><a class="header" href="#characterizing-denotable-functions">Characterizing Denotable Functions</a></h2>
<h3 id="the-space-of-lawful-functions"><a class="header" href="#the-space-of-lawful-functions">The Space of Lawful Functions</a></h3>
<p><strong>Definition 13.1 (Denotable Function)</strong>:
A function f: A → B is denotable in the Hologram model if there exists a process object P such that:</p>
<pre><code>[[P]](encode(a)) = encode(f(a)) for all a ∈ A
</code></pre>
<p>where encode maps external values to lawful configurations.</p>
<h3 id="finite-but-universal"><a class="header" href="#finite-but-universal">Finite but Universal</a></h3>
<p><strong>Theorem 13.1 (Bounded Universality)</strong>:
The class of denotable functions includes all computable functions whose space complexity is bounded by 12,288.</p>
<p><em>Proof</em>:
We construct a universal interpreter U on the lattice:</p>
<pre><code class="language-python">def universal_interpreter(program: Configuration, input: Configuration) -&gt; Configuration:
    # Allocate lattice regions
    PROGRAM_REGION = range(0, 4096)       # Pages 0-15
    DATA_REGION = range(4096, 8192)       # Pages 16-31
    STACK_REGION = range(8192, 10240)     # Pages 32-39
    HEAP_REGION = range(10240, 12288)     # Pages 40-47

    # Initialize
    lattice = Lattice()
    lattice.write_region(PROGRAM_REGION, program)
    lattice.write_region(DATA_REGION, input)

    # Interpretation loop
    pc = 0  # Program counter
    sp = 0  # Stack pointer

    while pc &lt; len(PROGRAM_REGION):
        # Fetch instruction
        instr = lattice.read(PROGRAM_REGION[pc])

        # Decode via R96 class
        opcode = R(instr)

        # Execute
        if opcode == 0:  # HALT
            break
        elif opcode == 1:  # PUSH
            value = lattice.read(DATA_REGION[instr % len(DATA_REGION)])
            lattice.write(STACK_REGION[sp], value)
            sp = (sp + 1) % len(STACK_REGION)
        elif opcode == 2:  # POP
            sp = (sp - 1) % len(STACK_REGION)
            value = lattice.read(STACK_REGION[sp])
        elif opcode == 3:  # ADD
            a = lattice.read(STACK_REGION[(sp-2) % len(STACK_REGION)])
            b = lattice.read(STACK_REGION[(sp-1) % len(STACK_REGION)])
            lattice.write(STACK_REGION[(sp-2) % len(STACK_REGION)], (a + b) % 256)
            sp = (sp - 1) % len(STACK_REGION)
        # ... more opcodes ...

        pc += 1

    # Extract result
    result = Configuration()
    for i in range(len(DATA_REGION)):
        result.set(Site.from_linear(i), lattice.read(DATA_REGION[i]))

    return result
</code></pre>
<p>This interpreter can simulate any Turing machine using ≤12,288 space. □</p>
<h3 id="characterization-via-resource-classes"><a class="header" href="#characterization-via-resource-classes">Characterization via Resource Classes</a></h3>
<p><strong>Theorem 13.2 (Expressivity Hierarchy)</strong>:</p>
<pre><code>CONST ⊂ CC ⊂ RC ⊂ HC ⊂ WC(log n) ⊂ WC(n) ⊂ ALL
</code></pre>
<p>where:</p>
<ul>
<li>CONST: Constant-space functions</li>
<li>CC: Conservation-checkable functions</li>
<li>RC: Resonance-commutative functions</li>
<li>HC: Height-commutative functions</li>
<li>WC(k): Window-k verifiable functions</li>
</ul>
<p>Each class corresponds to a verification complexity:</p>
<pre><code class="language-python">def classify_function(f):
    # Test if constant space
    if verify_with_receipts_only(f):
        return "CC"

    # Test if resonance-commutative
    if all_ops_within_r96_classes(f):
        return "RC"

    # Test if height-commutative
    if all_ops_within_pages(f):
        return "HC"

    # Test window size needed
    k = min_verification_window(f)
    return f"WC({k})"
</code></pre>
<h2 id="lambda-calculus-embeddings"><a class="header" href="#lambda-calculus-embeddings">Lambda Calculus Embeddings</a></h2>
<h3 id="encoding-lambda-terms"><a class="header" href="#encoding-lambda-terms">Encoding Lambda Terms</a></h3>
<p>We can embed untyped lambda calculus into the Hologram model:</p>
<p><strong>Definition 13.2 (Lambda Encoding)</strong>:</p>
<pre><code class="language-python">def encode_lambda_term(term):
    if isinstance(term, Variable):
        # Variables encoded as R96 class 0-31
        return Configuration(
            r96_class=term.index % 32,
            data=[term.index]
        )

    elif isinstance(term, Abstraction):
        # Lambda encoded as R96 class 32-63
        param = encode_lambda_term(term.param)
        body = encode_lambda_term(term.body)
        return Configuration(
            r96_class=32 + hash(term) % 32,
            data=[LAMBDA_MARKER, param, body]
        )

    elif isinstance(term, Application):
        # Application encoded as R96 class 64-95
        func = encode_lambda_term(term.func)
        arg = encode_lambda_term(term.arg)
        return Configuration(
            r96_class=64 + hash(term) % 32,
            data=[APP_MARKER, func, arg]
        )
</code></pre>
<h3 id="beta-reduction-as-morphism"><a class="header" href="#beta-reduction-as-morphism">Beta Reduction as Morphism</a></h3>
<pre><code class="language-python">class BetaReduction(Morphism):
    """Implement β-reduction as a Hologram morphism."""

    def apply(self, config: Configuration) -&gt; Configuration:
        term = decode_lambda_term(config)

        if is_redex(term):
            # (λx.e) v → e[x:=v]
            reduced = substitute(term.body, term.param, term.arg)
            return encode_lambda_term(reduced)

        # Search for redex in subterms
        if isinstance(term, Application):
            new_func = BetaReduction().apply(encode_lambda_term(term.func))
            new_arg = BetaReduction().apply(encode_lambda_term(term.arg))
            return encode_lambda_term(Application(
                decode_lambda_term(new_func),
                decode_lambda_term(new_arg)
            ))

        return config  # No reduction possible
</code></pre>
<h3 id="church-numerals"><a class="header" href="#church-numerals">Church Numerals</a></h3>
<pre><code class="language-python">def church_numeral(n: int) -&gt; Configuration:
    """Encode Church numeral n."""
    # n = λf.λx.f^n(x)
    if n == 0:
        # λf.λx.x
        return encode_lambda_term(
            Lambda("f", Lambda("x", Var("x")))
        )
    else:
        # λf.λx.f(...f(x)...)
        body = Var("x")
        for _ in range(n):
            body = App(Var("f"), body)
        return encode_lambda_term(
            Lambda("f", Lambda("x", body))
        )

# Arithmetic on Church numerals
def church_add():
    # λm.λn.λf.λx.m f (n f x)
    return encode_lambda_term(
        Lambda("m", Lambda("n", Lambda("f", Lambda("x",
            App(App(Var("m"), Var("f")),
                App(App(Var("n"), Var("f")), Var("x")))
        ))))
    )
</code></pre>
<h3 id="y-combinator-and-recursion"><a class="header" href="#y-combinator-and-recursion">Y Combinator and Recursion</a></h3>
<pre><code class="language-python">def y_combinator() -&gt; Configuration:
    """The Y combinator for recursion."""
    # Y = λf.(λx.f (x x)) (λx.f (x x))
    inner = Lambda("x", App(Var("f"), App(Var("x"), Var("x"))))
    return encode_lambda_term(
        Lambda("f", App(inner, inner))
    )

def factorial_generator():
    """Generator for factorial function."""
    # F = λf.λn. if n=0 then 1 else n * f(n-1)
    return encode_lambda_term(
        Lambda("f", Lambda("n",
            IfZero(Var("n"),
                   church_numeral(1),
                   Mult(Var("n"), App(Var("f"), Pred(Var("n")))))
        ))
    )

# Factorial = Y F
factorial = apply_morphism(
    y_combinator(),
    factorial_generator()
)
</code></pre>
<h2 id="linear-logic-via-budgets"><a class="header" href="#linear-logic-via-budgets">Linear Logic via Budgets</a></h2>
<h3 id="linear-types-as-budgeted-types"><a class="header" href="#linear-types-as-budgeted-types">Linear Types as Budgeted Types</a></h3>
<p>Linear logic’s “use exactly once” constraint maps perfectly to budget accounting:</p>
<p><strong>Definition 13.3 (Linear Type Encoding)</strong>:</p>
<pre><code class="language-python">class LinearType:
    def __init__(self, base_type, usage_budget=1):
        self.base_type = base_type
        self.usage_budget = usage_budget

    def check(self, term, context):
        # Count uses of each variable
        usage_counts = count_variable_uses(term)

        for var, count in usage_counts.items():
            if var in context:
                linear_type = context[var]
                if isinstance(linear_type, LinearType):
                    if count != linear_type.usage_budget:
                        raise LinearityViolation(f"{var} used {count} times, expected {linear_type.usage_budget}")

        return True
</code></pre>
<h3 id="linear-lambda-calculus"><a class="header" href="#linear-lambda-calculus">Linear Lambda Calculus</a></h3>
<pre><code class="language-python">def encode_linear_lambda(term, context):
    """Encode linear lambda calculus with budget tracking."""
    config = encode_lambda_term(term)

    # Add budget constraints
    for var in free_variables(term):
        if var in context and isinstance(context[var], LinearType):
            # Charge budget for variable use
            config.budget_used += context[var].usage_budget

    # Verify linearity
    if not verify_linear_usage(term, context):
        config.budget_used = float('inf')  # Mark as illegal

    return config
</code></pre>
<h3 id="resource-aware-computation"><a class="header" href="#resource-aware-computation">Resource-Aware Computation</a></h3>
<pre><code class="language-python">class ResourcedComputation:
    """Computation with explicit resource bounds."""

    def __init__(self, budget: int):
        self.total_budget = budget
        self.used_budget = 0

    def compute(self, term):
        if self.used_budget &gt;= self.total_budget:
            raise BudgetExhausted()

        # Each reduction costs budget
        while is_reducible(term):
            term = reduce_once(term)
            self.used_budget += 1

            if self.used_budget &gt;= self.total_budget:
                return PartialResult(term, self.used_budget)

        return CompleteResult(term, self.used_budget)
</code></pre>
<h3 id="proof-nets-as-process-objects"><a class="header" href="#proof-nets-as-process-objects">Proof Nets as Process Objects</a></h3>
<p>Linear logic proof nets map to process objects:</p>
<pre><code class="language-python">def proof_net_to_process(net):
    """Convert linear logic proof net to process object."""
    process = Process.Identity()

    # Each link becomes a morphism
    for link in net.links:
        if link.type == "axiom":
            # A ⊸ A^⊥
            morph = AxiomMorphism(link.formula)
        elif link.type == "cut":
            # Connect A and A^⊥
            morph = CutMorphism(link.formula)
        elif link.type == "tensor":
            # A ⊗ B
            morph = TensorMorphism(link.left, link.right)
        elif link.type == "par":
            # A ⅋ B
            morph = ParMorphism(link.left, link.right)

        process = process.compose(morph)

    return process
</code></pre>
<h2 id="embedding-recursion-schemes"><a class="header" href="#embedding-recursion-schemes">Embedding Recursion Schemes</a></h2>
<h3 id="primitive-recursion"><a class="header" href="#primitive-recursion">Primitive Recursion</a></h3>
<pre><code class="language-python">def primitive_recursion(base_case, recursive_case):
    """Implement primitive recursion on the lattice."""

    def rec(n):
        if n == 0:
            return base_case
        else:
            # Use content addressing for memoization
            address = H(encode_int(n))

            # Check if already computed
            if lattice.get(address) != 0:
                return lattice.get(address)

            # Compute recursively
            prev = rec(n - 1)
            result = recursive_case(n, prev)

            # Store for reuse
            lattice.set(address, result)
            return result

    return rec
</code></pre>
<h3 id="structural-recursion"><a class="header" href="#structural-recursion">Structural Recursion</a></h3>
<pre><code class="language-python">def structural_recursion(structure):
    """Recursion following data structure."""

    def process(config: Configuration) -&gt; Configuration:
        structure_type = get_structure_type(config)

        if structure_type == "leaf":
            return base_morphism.apply(config)

        elif structure_type == "node":
            # Process children
            left = extract_left(config)
            right = extract_right(config)

            # Recursive calls (via content addressing!)
            left_result = process(left)
            right_result = process(right)

            # Combine results
            return combine_morphism.apply(left_result, right_result)

    return process
</code></pre>
<h3 id="corecursion-and-streams"><a class="header" href="#corecursion-and-streams">Corecursion and Streams</a></h3>
<pre><code class="language-python">class Stream:
    """Infinite streams via corecursion."""

    def __init__(self, head, tail_generator):
        self.head = head
        self.tail_generator = tail_generator
        self._tail_cache = None

    @property
    def tail(self):
        if self._tail_cache is None:
            # Generate tail lazily
            self._tail_cache = self.tail_generator()
        return self._tail_cache

def fibonacci_stream():
    """Infinite Fibonacci sequence."""

    def fib_gen(a, b):
        return Stream(a, lambda: fib_gen(b, a + b))

    return fib_gen(0, 1)

# Take first n elements
def take(stream, n):
    result = []
    current = stream
    for _ in range(n):
        result.append(current.head)
        current = current.tail
    return result
</code></pre>
<h2 id="expressivity-limits"><a class="header" href="#expressivity-limits">Expressivity Limits</a></h2>
<h3 id="what-cannot-be-expressed"><a class="header" href="#what-cannot-be-expressed">What Cannot Be Expressed</a></h3>
<p><strong>Theorem 13.3 (Expressivity Limits)</strong>:
The following cannot be directly expressed in the Hologram model:</p>
<ol>
<li><strong>Unbounded space computation</strong>: Any computation requiring &gt;12,288 sites</li>
<li><strong>True randomness</strong>: All operations are deterministic</li>
<li><strong>Unverifiable computation</strong>: Every operation must produce receipts</li>
<li><strong>Non-lawful states</strong>: Configurations violating conservation laws</li>
</ol>
<h3 id="encoding-strategies-for-limits"><a class="header" href="#encoding-strategies-for-limits">Encoding Strategies for Limits</a></h3>
<p>Despite limits, we can approximate:</p>
<pre><code class="language-python">def handle_unbounded_computation(big_computation):
    """Handle computation exceeding lattice size."""

    # Strategy 1: Temporal multiplexing
    def chunk_computation():
        chunk_size = 12288 // 2  # Half lattice for data
        for chunk in partition(big_computation, chunk_size):
            result = process_chunk(chunk)
            # Store result via CAM
            address = H(result)
            store_external(address, result)

    # Strategy 2: Streaming with witnesses
    def stream_computation():
        stream = create_stream(big_computation)
        while not stream.done():
            chunk = stream.next_chunk()
            witness = process_with_witness(chunk)
            emit_witness(witness)

    # Strategy 3: Hierarchical decomposition
    def hierarchical_computation():
        if size(big_computation) &lt;= LATTICE_SIZE:
            return direct_compute(big_computation)
        else:
            # Recursive decomposition
            parts = decompose(big_computation)
            results = [hierarchical_computation(p) for p in parts]
            return merge_results(results)
</code></pre>
<h3 id="pseudo-randomness-via-chaos"><a class="header" href="#pseudo-randomness-via-chaos">Pseudo-Randomness via Chaos</a></h3>
<pre><code class="language-python">def pseudo_random_generator(seed: Configuration) -&gt; Configuration:
    """Generate pseudo-randomness via chaotic dynamics."""

    # Use sensitive dependence on initial conditions
    current = seed
    for _ in range(1000):  # Many iterations
        # Apply chaotic map
        current = chaotic_morphism(current)

    # Extract "random" bits from final state
    return extract_random_bits(current)

def chaotic_morphism(config: Configuration) -&gt; Configuration:
    """A morphism with chaotic dynamics."""
    new_config = Configuration(lattice=Lattice())

    for i in range(LATTICE_SIZE):
        site = Site.from_linear(i)
        value = config.lattice.get(site)

        # Logistic map in discrete form
        new_value = (4 * value * (255 - value) // 255) % 256
        new_config.lattice.set(site, new_value)

    return new_config
</code></pre>
<h2 id="completeness-results"><a class="header" href="#completeness-results">Completeness Results</a></h2>
<h3 id="computational-completeness"><a class="header" href="#computational-completeness">Computational Completeness</a></h3>
<p><strong>Theorem 13.4 (Bounded Turing Completeness)</strong>:
For any Turing machine M and input x, if M halts on x using space S ≤ 12,288, then there exists a process object P such that <a href="encode(x)">[P]</a> = encode(M(x)).</p>
<h3 id="logical-completeness"><a class="header" href="#logical-completeness">Logical Completeness</a></h3>
<p><strong>Theorem 13.5 (Proof-Theoretic Completeness)</strong>:
For any proof in intuitionistic logic that fits in 12,288 sites, there exists a corresponding witness chain in the Hologram model.</p>
<h3 id="type-theoretic-completeness"><a class="header" href="#type-theoretic-completeness">Type-Theoretic Completeness</a></h3>
<p><strong>Theorem 13.6 (Type System Embedding)</strong>:
Any decidable type system can be embedded as conservation law checking in the Hologram model.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p><strong>Exercise 13.1</strong>: Prove that the halting problem is decidable for Hologram programs (hint: finite state space).</p>
<p><strong>Exercise 13.2</strong>: Implement the SK combinator calculus in the Hologram model.</p>
<p><strong>Exercise 13.3</strong>: Show that every primitive recursive function is denotable.</p>
<p><strong>Exercise 13.4</strong>: Encode System F types using conservation laws.</p>
<p><strong>Exercise 13.5</strong>: Prove that gauge quotient doesn’t reduce expressivity.</p>
<h2 id="takeaways"><a class="header" href="#takeaways">Takeaways</a></h2>
<ol>
<li><strong>Bounded but universal</strong>: Can compute anything that fits in 12,288 space</li>
<li><strong>Lambda calculus embeds naturally</strong>: Variables, abstractions, applications as configurations</li>
<li><strong>Linear logic via budgets</strong>: Resource tracking built into the model</li>
<li><strong>Recursion through content addressing</strong>: Automatic memoization</li>
<li><strong>Limits are physical</strong>: Cannot exceed lattice size or violate conservation</li>
<li><strong>Completeness for bounded computation</strong>: Turing-complete within space bounds</li>
</ol>
<p>The Hologram model achieves surprising expressivity despite—or perhaps because of—its finite, lawful structure.</p>
<hr />
<p><em>Next: Chapter 14 explores normalization and confluence properties.</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part-3/12-minimal-core.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part-4/14-normalization-confluence.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part-3/12-minimal-core.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part-4/14-normalization-confluence.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
