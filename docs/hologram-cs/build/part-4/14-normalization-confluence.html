<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 14: Normalization &amp; Confluence - The Hologram (12,288): A Complete Computer Science Formalization</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A comprehensive computer science formalization of the 12,288 Hologram model of computation using mainstream CS formalisms">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title-page.html">Title Page</a></li><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="../readers-guide.html">Reader's Guide & Conventions</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part I: Mathematical Foundations</li><li class="chapter-item expanded "><a href="../part-1/01-information-as-lawful-structure.html"><strong aria-hidden="true">1.</strong> Chapter 1: Information as Lawful Structure</a></li><li class="chapter-item expanded "><a href="../part-1/02-universal-automaton.html"><strong aria-hidden="true">2.</strong> Chapter 2: The Universal Automaton</a></li><li class="chapter-item expanded "><a href="../part-1/03-labels-schedules-receipts.html"><strong aria-hidden="true">3.</strong> Chapter 3: Intrinsic Labels, Schedules, and Receipts</a></li><li class="chapter-item expanded "><a href="../part-1/04-content-addressable-memory.html"><strong aria-hidden="true">4.</strong> Chapter 4: Content-Addressable Memory</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part II: Algebraic Structure</li><li class="chapter-item expanded "><a href="../part-2/05-lawfulness-as-type-system.html"><strong aria-hidden="true">5.</strong> Chapter 5: Lawfulness as a Type System</a></li><li class="chapter-item expanded "><a href="../part-2/06-programs-as-geometry.html"><strong aria-hidden="true">6.</strong> Chapter 6: Programs as Geometry</a></li><li class="chapter-item expanded "><a href="../part-2/07-algorithmic-reification.html"><strong aria-hidden="true">7.</strong> Chapter 7: Algorithmic Reification</a></li><li class="chapter-item expanded "><a href="../part-2/08-universal-cost.html"><strong aria-hidden="true">8.</strong> Chapter 8: The Universal Cost</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part III: System Architecture</li><li class="chapter-item expanded "><a href="../part-3/09-security-safety-correctness.html"><strong aria-hidden="true">9.</strong> Chapter 9: Security, Safety, and Correctness</a></li><li class="chapter-item expanded "><a href="../part-3/10-worked-micro-examples.html"><strong aria-hidden="true">10.</strong> Chapter 10: Worked Micro-Examples</a></li><li class="chapter-item expanded "><a href="../part-3/11-interfaces-to-mainstream-cs.html"><strong aria-hidden="true">11.</strong> Chapter 11: Interfaces to Mainstream CS</a></li><li class="chapter-item expanded "><a href="../part-3/12-minimal-core.html"><strong aria-hidden="true">12.</strong> Chapter 12: Minimal Core</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part IV: Protocol Design</li><li class="chapter-item expanded "><a href="../part-4/13-meta-theory-expressivity.html"><strong aria-hidden="true">13.</strong> Chapter 13: Meta-Theory & Expressivity</a></li><li class="chapter-item expanded "><a href="../part-4/14-normalization-confluence.html" class="active"><strong aria-hidden="true">14.</strong> Chapter 14: Normalization & Confluence</a></li><li class="chapter-item expanded "><a href="../part-4/15-categorical-semantics.html"><strong aria-hidden="true">15.</strong> Chapter 15: Categorical Semantics</a></li><li class="chapter-item expanded "><a href="../part-4/16-security-proofs.html"><strong aria-hidden="true">16.</strong> Chapter 16: Security Proofs</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part V: Implementation</li><li class="chapter-item expanded "><a href="../part-5/17-optimization-landscape.html"><strong aria-hidden="true">17.</strong> Chapter 17: Optimization Landscape</a></li><li class="chapter-item expanded "><a href="../part-5/18-data-structure-implementation.html"><strong aria-hidden="true">18.</strong> Chapter 18: Data Structure Implementation</a></li><li class="chapter-item expanded "><a href="../part-5/19-runtime-architecture.html"><strong aria-hidden="true">19.</strong> Chapter 19: Runtime Architecture</a></li><li class="chapter-item expanded "><a href="../part-5/20-verification-system.html"><strong aria-hidden="true">20.</strong> Chapter 20: Verification System</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part VI: Applications</li><li class="chapter-item expanded "><a href="../part-6/21-distributed-systems.html"><strong aria-hidden="true">21.</strong> Chapter 21: Distributed Systems</a></li><li class="chapter-item expanded "><a href="../part-6/22-database-systems.html"><strong aria-hidden="true">22.</strong> Chapter 22: Database Systems</a></li><li class="chapter-item expanded "><a href="../part-6/23-compiler-construction.html"><strong aria-hidden="true">23.</strong> Chapter 23: Compiler Construction</a></li><li class="chapter-item expanded "><a href="../part-6/24-machine-learning-integration.html"><strong aria-hidden="true">24.</strong> Chapter 24: Machine Learning Integration</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="../appendices/A-glossary.html"><strong aria-hidden="true">25.</strong> Appendix A: Glossary</a></li><li class="chapter-item expanded "><a href="../appendices/B-mathematical-notation.html"><strong aria-hidden="true">26.</strong> Appendix B: Mathematical Notation</a></li><li class="chapter-item expanded "><a href="../appendices/C-cs-mappings.html"><strong aria-hidden="true">27.</strong> Appendix C: Side-by-Side CS Mappings</a></li><li class="chapter-item expanded "><a href="../appendices/D-exercise-solutions.html"><strong aria-hidden="true">28.</strong> Appendix D: Exercise Solutions</a></li><li class="chapter-item expanded "><a href="../appendices/E-implementation-code.html"><strong aria-hidden="true">29.</strong> Appendix E: Implementation Code</a></li><li class="chapter-item expanded "><a href="../appendices/F-research-problems.html"><strong aria-hidden="true">30.</strong> Appendix F: Research Problems</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../bibliography.html">Bibliography</a></li><li class="chapter-item expanded affix "><a href="../index.html">Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hologram (12,288): A Complete Computer Science Formalization</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/uor-foundation/hologram-cs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-14-normalization--confluence"><a class="header" href="#chapter-14-normalization--confluence">Chapter 14: Normalization &amp; Confluence</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>In traditional rewriting systems, a crucial question is whether different reduction sequences lead to the same result. The Hologram model adds a twist: reductions must respect conservation laws, and “sameness” is defined up to gauge equivalence. This chapter establishes when process objects have unique normal forms, when different evaluation strategies converge, and how conservation laws actually simplify the confluence problem by eliminating many potential reduction paths.</p>
<h2 id="confluence-up-to-gauge"><a class="header" href="#confluence-up-to-gauge">Confluence up to Gauge</a></h2>
<h3 id="gauge-aware-confluence"><a class="header" href="#gauge-aware-confluence">Gauge-Aware Confluence</a></h3>
<p>Traditional confluence: If a →* b and a →* c, then ∃d such that b →* d and c →* d.</p>
<p>Hologram confluence: If a →* b and a →* c, then ∃d such that b →* d’ and c →* d’’ where d’ ≡ᵍ d’’.</p>
<p><strong>Definition 14.1 (Gauge Confluence)</strong>:
A reduction system is gauge-confluent if all diverging reduction paths reconverge up to gauge equivalence.</p>
<pre><code class="language-python">def is_gauge_confluent(reduction_system):
    """Check if system is confluent up to gauge."""
    for term in generate_test_terms():
        # Find all possible reductions
        reductions = []
        for strategy in [leftmost, rightmost, parallel, random]:
            reduced = reduce_with_strategy(term, strategy)
            reductions.append(normalize(reduced))  # Apply gauge fixing

        # Check all reduce to same normal form
        normal_forms = [r.normal_form for r in reductions]
        if not all(nf.gauge_equivalent(normal_forms[0]) for nf in normal_forms):
            return False, term  # Counterexample

    return True, None
</code></pre>
<h3 id="the-diamond-lemma-for-gauge-systems"><a class="header" href="#the-diamond-lemma-for-gauge-systems">The Diamond Lemma for Gauge Systems</a></h3>
<p><strong>Lemma 14.1 (Gauge Diamond)</strong>:
If → satisfies the gauge diamond property, then →* is gauge-confluent.</p>
<p>The gauge diamond property states:</p>
<pre><code>    a
   / \
  b   c
  |   |
  d'  d''

where d' ≡ᵍ d''
</code></pre>
<p><strong>Proof</strong>:</p>
<pre><code class="language-python">def prove_gauge_diamond():
    """Constructive proof of gauge diamond lemma."""

    def diamond_step(a):
        # All one-step reductions from a
        b = reduce_left(a)
        c = reduce_right(a)

        # Show they reconverge (up to gauge)
        d_from_b = reduce_right(b)
        d_from_c = reduce_left(c)

        # Apply gauge normalization
        d_from_b_normal = fix_gauge(d_from_b)
        d_from_c_normal = fix_gauge(d_from_c)

        assert d_from_b_normal == d_from_c_normal
        return d_from_b_normal

    # Extend to multi-step by induction
    def diamond_multi(a, n):
        if n == 0:
            return a
        else:
            # Use diamond for single step
            b = diamond_step(a)
            # Inductively apply to result
            return diamond_multi(b, n-1)
</code></pre>
<h3 id="critical-pairs-in-conservation-systems"><a class="header" href="#critical-pairs-in-conservation-systems">Critical Pairs in Conservation Systems</a></h3>
<p><strong>Definition 14.2 (Conservation-Respecting Critical Pair)</strong>:
A critical pair (t₁, t₂) where both reductions preserve conservation laws.</p>
<pre><code class="language-python">def find_critical_pairs(rules):
    """Find critical pairs that respect conservation."""
    critical_pairs = []

    for rule1 in rules:
        for rule2 in rules:
            overlaps = find_overlaps(rule1.lhs, rule2.lhs)

            for overlap in overlaps:
                # Create critical pair
                t1 = apply_rule(overlap, rule1)
                t2 = apply_rule(overlap, rule2)

                # Check both preserve conservation
                if (preserves_conservation(t1, overlap) and
                    preserves_conservation(t2, overlap)):
                    critical_pairs.append((t1, t2, overlap))

    return critical_pairs

def resolve_critical_pair(t1, t2):
    """Show critical pair converges."""
    # Reduce both sides to normal form
    nf1 = reduce_to_normal_form(t1)
    nf2 = reduce_to_normal_form(t2)

    # Check gauge equivalence
    return nf1.gauge_equivalent(nf2)
</code></pre>
<h2 id="strong-normalization"><a class="header" href="#strong-normalization">Strong Normalization</a></h2>
<h3 id="budget-bounded-normalization"><a class="header" href="#budget-bounded-normalization">Budget-Bounded Normalization</a></h3>
<p><strong>Theorem 14.1 (Strong Normalization with Budget)</strong>:
Every reduction sequence in the Hologram model terminates when budget is finite.</p>
<p><em>Proof</em>:</p>
<pre><code class="language-python">def prove_strong_normalization():
    """Budget ensures termination."""

    class BudgetedReduction:
        def __init__(self, initial_budget):
            self.budget = initial_budget
            self.steps = 0

        def reduce(self, term):
            while is_reducible(term) and self.budget &gt; 0:
                # Each reduction costs budget
                term, cost = reduce_once_with_cost(term)
                self.budget -= cost
                self.steps += 1

                # Budget exhaustion = termination
                if self.budget &lt;= 0:
                    return term, "BUDGET_EXHAUSTED"

            return term, "NORMAL_FORM"

    # For any finite budget B, reduction terminates in ≤ B steps
    MAX_BUDGET = 12288  # Lattice size
    reducer = BudgetedReduction(MAX_BUDGET)
    result, reason = reducer.reduce(any_term)

    assert reducer.steps &lt;= MAX_BUDGET
    return True
</code></pre>
<h3 id="decreasing-metrics"><a class="header" href="#decreasing-metrics">Decreasing Metrics</a></h3>
<p><strong>Definition 14.3 (Conservation Metric)</strong>:
A metric that decreases with each reduction while preserving conservation.</p>
<pre><code class="language-python">def conservation_metric(config: Configuration) -&gt; int:
    """Metric that decreases during reduction."""
    # Combination of factors
    m1 = sum(1 for i in range(LATTICE_SIZE)
             if config.lattice.data[i] != 0)  # Non-zero sites

    m2 = action_functional(config)  # Action always decreases

    m3 = disorder_measure(config)  # Entropy-like measure

    return m1 + int(m2 * 1000) + m3

def verify_decreasing():
    """Verify metric decreases."""
    config = random_configuration()
    metric_before = conservation_metric(config)

    # Apply any lawful reduction
    reduced = apply_reduction(config)
    metric_after = conservation_metric(reduced)

    assert metric_after &lt; metric_before
</code></pre>
<h3 id="normalization-strategy"><a class="header" href="#normalization-strategy">Normalization Strategy</a></h3>
<p><strong>Algorithm 14.1 (Optimal Normalization)</strong>:</p>
<pre><code class="language-python">def optimal_normalize(config: Configuration) -&gt; Configuration:
    """Normalize using optimal strategy."""

    # Priority queue by estimated cost
    from heapq import heappush, heappop
    queue = [(0, config)]
    visited = set()

    while queue:
        cost, current = heappop(queue)

        if is_normal_form(current):
            return current

        config_hash = current.hash()
        if config_hash in visited:
            continue
        visited.add(config_hash)

        # Generate all possible reductions
        for reduction in possible_reductions(current):
            new_config = apply_reduction(current, reduction)
            new_cost = cost + reduction.cost()

            # A* heuristic: estimated remaining cost
            heuristic = estimate_distance_to_normal(new_config)
            priority = new_cost + heuristic

            heappush(queue, (priority, new_config))

    raise ValueError("No normal form found")
</code></pre>
<h2 id="church-rosser-results"><a class="header" href="#church-rosser-results">Church-Rosser Results</a></h2>
<h3 id="classical-church-rosser"><a class="header" href="#classical-church-rosser">Classical Church-Rosser</a></h3>
<p><strong>Theorem 14.2 (Church-Rosser for Lawful Reductions)</strong>:
The subset of reductions that preserve conservation laws satisfies Church-Rosser.</p>
<p><em>Proof</em>:</p>
<pre><code class="language-python">def prove_church_rosser():
    """Prove Church-Rosser property."""

    def all_reductions_converge(term):
        """All reduction paths from term converge."""
        # Collect all possible reduction sequences
        sequences = []

        def explore(current, path):
            if is_normal_form(current):
                sequences.append(path)
                return

            for next_term in one_step_reductions(current):
                if preserves_conservation(next_term, current):
                    explore(next_term, path + [next_term])

        explore(term, [term])

        # Extract normal forms
        normal_forms = [seq[-1] for seq in sequences]

        # All should be gauge-equivalent
        first_nf = normalize(normal_forms[0])
        for nf in normal_forms[1:]:
            assert normalize(nf).gauge_equivalent(first_nf)

        return True

    # Test on sample terms
    for term in generate_test_terms():
        assert all_reductions_converge(term)
</code></pre>
<h3 id="parallel-reductions"><a class="header" href="#parallel-reductions">Parallel Reductions</a></h3>
<p><strong>Definition 14.4 (Parallel Reduction)</strong>:
Simultaneous reduction of independent redexes.</p>
<pre><code class="language-python">class ParallelReducer:
    """Reduce independent redexes simultaneously."""

    def find_independent_redexes(self, config):
        """Find redexes that don't interfere."""
        redexes = find_all_redexes(config)
        independent_sets = []

        # Greedy algorithm for independence
        for redex in redexes:
            # Find a set this redex can join
            placed = False
            for ind_set in independent_sets:
                if all(self.are_independent(redex, other) for other in ind_set):
                    ind_set.append(redex)
                    placed = True
                    break

            if not placed:
                independent_sets.append([redex])

        return independent_sets

    def are_independent(self, redex1, redex2):
        """Check if two redexes can be reduced in parallel."""
        # Disjoint locations
        if redex1.sites.isdisjoint(redex2.sites):
            return True

        # Different R96 classes
        if redex1.r96_class != redex2.r96_class:
            return True

        # Different pages (height-independence)
        if all(s1.page != s2.page for s1 in redex1.sites for s2 in redex2.sites):
            return True

        return False

    def parallel_reduce(self, config):
        """Perform parallel reduction."""
        independent_sets = self.find_independent_redexes(config)

        # Reduce largest independent set
        if independent_sets:
            largest_set = max(independent_sets, key=len)
            new_config = config.copy()

            # Apply all reductions in parallel
            for redex in largest_set:
                new_config = apply_redex(new_config, redex)

            return new_config

        return config  # No redexes
</code></pre>
<h3 id="unique-normal-forms"><a class="header" href="#unique-normal-forms">Unique Normal Forms</a></h3>
<p><strong>Theorem 14.3 (Uniqueness of Normal Forms)</strong>:
If a configuration has a normal form, it is unique up to gauge.</p>
<p><em>Proof</em>:</p>
<pre><code class="language-python">def prove_unique_normal_form():
    """Prove uniqueness of normal forms."""

    def reduce_to_normal(config, strategy):
        """Reduce using given strategy."""
        current = config
        while is_reducible(current):
            current = strategy(current)
        return normalize(current)  # Apply gauge fixing

    # Test different strategies
    config = random_lawful_configuration()

    nf_leftmost = reduce_to_normal(config, leftmost_reduction)
    nf_rightmost = reduce_to_normal(config, rightmost_reduction)
    nf_parallel = reduce_to_normal(config, parallel_reduction)
    nf_random = reduce_to_normal(config, random_reduction)

    # All should be gauge-equivalent
    assert nf_leftmost.gauge_equivalent(nf_rightmost)
    assert nf_leftmost.gauge_equivalent(nf_parallel)
    assert nf_leftmost.gauge_equivalent(nf_random)

    print("✓ Normal form is unique up to gauge")
    return True
</code></pre>
<h2 id="conservation-preserving-reductions"><a class="header" href="#conservation-preserving-reductions">Conservation-Preserving Reductions</a></h2>
<h3 id="the-conservation-constraint"><a class="header" href="#the-conservation-constraint">The Conservation Constraint</a></h3>
<p><strong>Definition 14.5 (Conservation-Preserving Reduction)</strong>:
A reduction → that maintains all conservation laws.</p>
<pre><code class="language-python">def is_conservation_preserving(reduction):
    """Check if reduction preserves conservation laws."""

    def check_single_step(before, after):
        # R96 conservation
        if compute_r96_digest(before) != compute_r96_digest(after):
            return False, "R96 violated"

        # C768 fairness
        if not maintains_fairness(before, after):
            return False, "C768 fairness violated"

        # Φ coherence
        if not maintains_phi_coherence(before, after):
            return False, "Φ coherence violated"

        # Budget non-increase
        if after.budget_used &gt; before.budget_used + reduction.cost:
            return False, "Budget increased illegally"

        return True, "Conservation preserved"

    # Test on sample reductions
    for _ in range(100):
        before = random_configuration()
        after = reduction(before)
        preserved, reason = check_single_step(before, after)
        if not preserved:
            return False, reason

    return True, "All conservation laws preserved"
</code></pre>
<h3 id="lawful-reduction-strategies"><a class="header" href="#lawful-reduction-strategies">Lawful Reduction Strategies</a></h3>
<pre><code class="language-python">class LawfulReducer:
    """Reduction strategies that preserve conservation."""

    def innermost_lawful(self, config):
        """Reduce innermost redex that preserves conservation."""
        redexes = find_redexes_innermost_first(config)

        for redex in redexes:
            trial = apply_redex(config, redex)
            if preserves_all_conservation(trial, config):
                return trial

        return config  # No lawful reduction possible

    def outermost_lawful(self, config):
        """Reduce outermost redex that preserves conservation."""
        redexes = find_redexes_outermost_first(config)

        for redex in redexes:
            trial = apply_redex(config, redex)
            if preserves_all_conservation(trial, config):
                return trial

        return config

    def minimize_action(self, config):
        """Choose reduction that minimally increases action."""
        redexes = find_all_redexes(config)
        best_config = config
        best_action = action_functional(config)

        for redex in redexes:
            trial = apply_redex(config, redex)
            if preserves_all_conservation(trial, config):
                trial_action = action_functional(trial)
                if trial_action &lt; best_action:
                    best_action = trial_action
                    best_config = trial

        return best_config
</code></pre>
<h2 id="normalization-algorithms"><a class="header" href="#normalization-algorithms">Normalization Algorithms</a></h2>
<h3 id="efficient-normal-form-computation"><a class="header" href="#efficient-normal-form-computation">Efficient Normal Form Computation</a></h3>
<pre><code class="language-python">def efficient_normalize(config: Configuration) -&gt; Configuration:
    """Efficiently compute normal form."""

    # Phase 1: Gauge fixing
    config = fix_gauge_efficient(config)

    # Phase 2: Local reductions (R96 class-local)
    for r_class in range(96):
        config = reduce_class_local(config, r_class)

    # Phase 3: Global reductions
    config = reduce_global(config)

    # Phase 4: Final gauge fixing
    config = fix_gauge_final(config)

    return config

def fix_gauge_efficient(config):
    """Efficient gauge fixing."""
    # Use incremental updates instead of full recomputation
    changes = detect_gauge_changes(config)

    for change in changes:
        if change.type == "translation":
            config = translate_incremental(config, change.delta)
        elif change.type == "rotation":
            config = rotate_incremental(config, change.angle)
        elif change.type == "boundary":
            config = fix_boundary_incremental(config, change.sites)

    return config
</code></pre>
<h3 id="memoization-via-content-addressing"><a class="header" href="#memoization-via-content-addressing">Memoization via Content Addressing</a></h3>
<pre><code class="language-python">class MemoizedNormalizer:
    """Use content addressing to memoize normalizations."""

    def __init__(self):
        self.cache = {}  # Address → Normal form

    def normalize(self, config):
        # Check cache
        address = H(config)
        if address in self.cache:
            return self.cache[address]

        # Compute normal form
        normal = compute_normal_form(config)

        # Cache for reuse
        self.cache[address] = normal
        self.cache[H(normal)] = normal  # Normal form of NF is itself

        return normal

    def batch_normalize(self, configs):
        """Normalize batch, exploiting shared subterms."""
        # Build dependency graph
        graph = build_reduction_graph(configs)

        # Topological sort for optimal order
        order = topological_sort(graph)

        results = []
        for config in order:
            # Many subterms already normalized
            normal = self.normalize(config)
            results.append(normal)

        return results
</code></pre>
<h2 id="confluence-modulo-theories"><a class="header" href="#confluence-modulo-theories">Confluence Modulo Theories</a></h2>
<h3 id="confluence-with-r96-classes"><a class="header" href="#confluence-with-r96-classes">Confluence with R96 Classes</a></h3>
<pre><code class="language-python">def confluence_modulo_r96():
    """Confluence modulo R96 equivalence."""

    def reduce_modulo_r96(config):
        """Reduce treating R96-equivalent bytes as equal."""
        # Partition by R96 class
        partitions = partition_by_r96(config)

        # Reduce within each partition independently
        reduced_partitions = {}
        for r_class, partition in partitions.items():
            reduced_partitions[r_class] = reduce_partition(partition)

        # Reassemble
        return reassemble_partitions(reduced_partitions)

    # Test confluence
    config = random_configuration()

    # Different reduction orders
    r1 = reduce_modulo_r96(reduce_left_first(config))
    r2 = reduce_modulo_r96(reduce_right_first(config))

    # Should be R96-equivalent
    assert same_r96_distribution(r1, r2)
</code></pre>
<h3 id="confluence-with-c768-scheduling"><a class="header" href="#confluence-with-c768-scheduling">Confluence with C768 Scheduling</a></h3>
<pre><code class="language-python">def confluence_with_scheduling():
    """Confluence respecting C768 schedule."""

    def scheduled_reduction(config, phase):
        """Reduce only sites active in current phase."""
        active_sites = get_active_sites(phase)
        return reduce_sites(config, active_sites)

    # Full cycle should be confluent
    config = random_configuration()

    # Path 1: Phase order 0,1,2,...,767
    result1 = config
    for phase in range(768):
        result1 = scheduled_reduction(result1, phase)

    # Path 2: Different phase order (respecting dependencies)
    result2 = config
    for phase in random_permutation_respecting_deps(range(768)):
        result2 = scheduled_reduction(result2, phase)

    # Results should be gauge-equivalent
    assert normalize(result1).gauge_equivalent(normalize(result2))
</code></pre>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p><strong>Exercise 14.1</strong>: Prove that parallel reduction terminates faster than sequential.</p>
<p><strong>Exercise 14.2</strong>: Find a critical pair that cannot be resolved without gauge fixing.</p>
<p><strong>Exercise 14.3</strong>: Design a reduction strategy that minimizes budget usage.</p>
<p><strong>Exercise 14.4</strong>: Prove that conservation laws strengthen confluence.</p>
<p><strong>Exercise 14.5</strong>: Implement incremental normalization that reuses previous work.</p>
<h2 id="takeaways"><a class="header" href="#takeaways">Takeaways</a></h2>
<ol>
<li><strong>Confluence up to gauge</strong>: Different paths converge modulo gauge equivalence</li>
<li><strong>Strong normalization via budget</strong>: Finite budget ensures termination</li>
<li><strong>Church-Rosser holds</strong>: For conservation-preserving reductions</li>
<li><strong>Unique normal forms</strong>: Up to gauge equivalence</li>
<li><strong>Conservation simplifies confluence</strong>: Fewer valid reduction paths</li>
<li><strong>Efficient normalization</strong>: Via memoization and incremental updates</li>
</ol>
<p>Normalization in the Hologram model is both guaranteed (by budget) and efficient (by structure).</p>
<hr />
<p><em>Next: Chapter 15 develops the categorical semantics of the model.</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part-4/13-meta-theory-expressivity.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part-4/15-categorical-semantics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part-4/13-meta-theory-expressivity.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part-4/15-categorical-semantics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
