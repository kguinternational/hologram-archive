<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 2: The Universal Automaton - The Hologram (12,288): A Complete Computer Science Formalization</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A comprehensive computer science formalization of the 12,288 Hologram model of computation using mainstream CS formalisms">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title-page.html">Title Page</a></li><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="../readers-guide.html">Reader's Guide & Conventions</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part I: Mathematical Foundations</li><li class="chapter-item expanded "><a href="../part-1/01-information-as-lawful-structure.html"><strong aria-hidden="true">1.</strong> Chapter 1: Information as Lawful Structure</a></li><li class="chapter-item expanded "><a href="../part-1/02-universal-automaton.html" class="active"><strong aria-hidden="true">2.</strong> Chapter 2: The Universal Automaton</a></li><li class="chapter-item expanded "><a href="../part-1/03-labels-schedules-receipts.html"><strong aria-hidden="true">3.</strong> Chapter 3: Intrinsic Labels, Schedules, and Receipts</a></li><li class="chapter-item expanded "><a href="../part-1/04-content-addressable-memory.html"><strong aria-hidden="true">4.</strong> Chapter 4: Content-Addressable Memory</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part II: Algebraic Structure</li><li class="chapter-item expanded "><a href="../part-2/05-lawfulness-as-type-system.html"><strong aria-hidden="true">5.</strong> Chapter 5: Lawfulness as a Type System</a></li><li class="chapter-item expanded "><a href="../part-2/06-programs-as-geometry.html"><strong aria-hidden="true">6.</strong> Chapter 6: Programs as Geometry</a></li><li class="chapter-item expanded "><a href="../part-2/07-algorithmic-reification.html"><strong aria-hidden="true">7.</strong> Chapter 7: Algorithmic Reification</a></li><li class="chapter-item expanded "><a href="../part-2/08-universal-cost.html"><strong aria-hidden="true">8.</strong> Chapter 8: The Universal Cost</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part III: System Architecture</li><li class="chapter-item expanded "><a href="../part-3/09-security-safety-correctness.html"><strong aria-hidden="true">9.</strong> Chapter 9: Security, Safety, and Correctness</a></li><li class="chapter-item expanded "><a href="../part-3/10-worked-micro-examples.html"><strong aria-hidden="true">10.</strong> Chapter 10: Worked Micro-Examples</a></li><li class="chapter-item expanded "><a href="../part-3/11-interfaces-to-mainstream-cs.html"><strong aria-hidden="true">11.</strong> Chapter 11: Interfaces to Mainstream CS</a></li><li class="chapter-item expanded "><a href="../part-3/12-minimal-core.html"><strong aria-hidden="true">12.</strong> Chapter 12: Minimal Core</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part IV: Protocol Design</li><li class="chapter-item expanded "><a href="../part-4/13-meta-theory-expressivity.html"><strong aria-hidden="true">13.</strong> Chapter 13: Meta-Theory & Expressivity</a></li><li class="chapter-item expanded "><a href="../part-4/14-normalization-confluence.html"><strong aria-hidden="true">14.</strong> Chapter 14: Normalization & Confluence</a></li><li class="chapter-item expanded "><a href="../part-4/15-categorical-semantics.html"><strong aria-hidden="true">15.</strong> Chapter 15: Categorical Semantics</a></li><li class="chapter-item expanded "><a href="../part-4/16-security-proofs.html"><strong aria-hidden="true">16.</strong> Chapter 16: Security Proofs</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part V: Implementation</li><li class="chapter-item expanded "><a href="../part-5/17-optimization-landscape.html"><strong aria-hidden="true">17.</strong> Chapter 17: Optimization Landscape</a></li><li class="chapter-item expanded "><a href="../part-5/18-data-structure-implementation.html"><strong aria-hidden="true">18.</strong> Chapter 18: Data Structure Implementation</a></li><li class="chapter-item expanded "><a href="../part-5/19-runtime-architecture.html"><strong aria-hidden="true">19.</strong> Chapter 19: Runtime Architecture</a></li><li class="chapter-item expanded "><a href="../part-5/20-verification-system.html"><strong aria-hidden="true">20.</strong> Chapter 20: Verification System</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part VI: Applications</li><li class="chapter-item expanded "><a href="../part-6/21-distributed-systems.html"><strong aria-hidden="true">21.</strong> Chapter 21: Distributed Systems</a></li><li class="chapter-item expanded "><a href="../part-6/22-database-systems.html"><strong aria-hidden="true">22.</strong> Chapter 22: Database Systems</a></li><li class="chapter-item expanded "><a href="../part-6/23-compiler-construction.html"><strong aria-hidden="true">23.</strong> Chapter 23: Compiler Construction</a></li><li class="chapter-item expanded "><a href="../part-6/24-machine-learning-integration.html"><strong aria-hidden="true">24.</strong> Chapter 24: Machine Learning Integration</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="../appendices/A-glossary.html"><strong aria-hidden="true">25.</strong> Appendix A: Glossary</a></li><li class="chapter-item expanded "><a href="../appendices/B-mathematical-notation.html"><strong aria-hidden="true">26.</strong> Appendix B: Mathematical Notation</a></li><li class="chapter-item expanded "><a href="../appendices/C-cs-mappings.html"><strong aria-hidden="true">27.</strong> Appendix C: Side-by-Side CS Mappings</a></li><li class="chapter-item expanded "><a href="../appendices/D-exercise-solutions.html"><strong aria-hidden="true">28.</strong> Appendix D: Exercise Solutions</a></li><li class="chapter-item expanded "><a href="../appendices/E-implementation-code.html"><strong aria-hidden="true">29.</strong> Appendix E: Implementation Code</a></li><li class="chapter-item expanded "><a href="../appendices/F-research-problems.html"><strong aria-hidden="true">30.</strong> Appendix F: Research Problems</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../bibliography.html">Bibliography</a></li><li class="chapter-item expanded affix "><a href="../index.html">Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hologram (12,288): A Complete Computer Science Formalization</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/uor-foundation/hologram-cs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-2-the-universal-automaton"><a class="header" href="#chapter-2-the-universal-automaton">Chapter 2: The Universal Automaton</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Every model of computation needs a space where computation happens. Turing machines have their infinite tape, lambda calculus has its terms, and cellular automata have their grids. The Hologram model has the 12,288 lattice—a finite, fixed, universal space where all possible computations live.</p>
<p>Why 12,288? Why not infinite memory like a Turing machine? The answer reveals a deep principle: with the right structure, a finite space can be computationally universal through reuse, symmetry, and careful organization. The number 12,288 = 48 × 256 = 3 × 16 × 256 offers rich factorization, enabling efficient addressing, natural parallelism, and elegant mathematical properties.</p>
<h2 id="the-12288-lattice"><a class="header" href="#the-12288-lattice">The 12,288 Lattice</a></h2>
<h3 id="carrier-indexing-and-neighborhoods"><a class="header" href="#carrier-indexing-and-neighborhoods">Carrier, Indexing, and Neighborhoods</a></h3>
<p><strong>Definition 2.1 (The Lattice T)</strong>:</p>
<pre><code>T = ℤ/48 × ℤ/256
</code></pre>
<p>This is a two-dimensional toroidal lattice with:</p>
<ul>
<li>48 pages (p-coordinate)</li>
<li>256 bytes per page (b-coordinate)</li>
<li>Total sites: 48 × 256 = 12,288</li>
</ul>
<p><strong>Definition 2.2 (Coordinate Systems)</strong>:</p>
<pre><code>Cartesian: (p,b) where p ∈ [0,47], b ∈ [0,255]
Linear: i = 256p + b where i ∈ [0,12287]
Residue: (p mod 3, p mod 16, b) factored form
</code></pre>
<p>The multiple coordinate systems aren’t arbitrary—each reveals different structural properties.</p>
<h3 id="toroidal-topology"><a class="header" href="#toroidal-topology">Toroidal Topology</a></h3>
<p>The lattice wraps around in both dimensions:</p>
<pre><code>(p, b) + (Δp, Δb) = ((p + Δp) mod 48, (b + Δb) mod 256)
</code></pre>
<p>This creates a space with:</p>
<ul>
<li>No boundaries (every site has full neighborhoods)</li>
<li>Uniform connectivity (no edge effects)</li>
<li>Natural periodicity (aligns with cycles)</li>
</ul>
<h3 id="neighborhoods-and-locality"><a class="header" href="#neighborhoods-and-locality">Neighborhoods and Locality</a></h3>
<p><strong>Definition 2.3 (Neighborhoods)</strong>:</p>
<pre><code>N₁(p,b) = {(p±1,b), (p,b±1)}           // 4-neighborhood
N₂(p,b) = {(p±i,b±j) : i,j ∈ {0,1}}    // 8-neighborhood
Nₖ(p,b) = {(p',b') : d((p,b),(p',b')) ≤ k}  // k-radius ball
</code></pre>
<p>Locality is fundamental—operations that respect neighborhood structure are efficient and parallelizable.</p>
<h3 id="cs-analogue"><a class="header" href="#cs-analogue">CS Analogue</a></h3>
<p>Think of T as:</p>
<ul>
<li>A <strong>universal RAM</strong> with 12,288 addressable locations</li>
<li>A <strong>finite state automaton</strong> with structured state space</li>
<li>A <strong>distributed hash table</strong> with perfect load balancing</li>
<li>A <strong>processor cache</strong> with guaranteed hit rates for lawful access patterns</li>
</ul>
<h2 id="symmetries--gauge"><a class="header" href="#symmetries--gauge">Symmetries &amp; Gauge</a></h2>
<h3 id="global-symmetries"><a class="header" href="#global-symmetries">Global Symmetries</a></h3>
<p>The lattice admits several symmetry groups:</p>
<p><strong>Definition 2.4 (Translation Group)</strong>:</p>
<pre><code>T_trans = {τ_{(a,b)} : T → T | τ_{(a,b)}(p,q) = (p+a, q+b)}
</code></pre>
<p>Translations form a group isomorphic to T itself.</p>
<p><strong>Definition 2.5 (Schedule Rotation)</strong>:</p>
<pre><code>σ: T → T with order 768
σ = σ_p × σ_b where:
  σ_p: ℤ/48 → ℤ/48 has order 48
  σ_b: ℤ/256 → ℤ/256 has order 16
  lcm(48,16) = 768
</code></pre>
<p>The schedule rotation ensures every site gets equal “processor time” over a complete cycle.</p>
<p><strong>Definition 2.6 (Boundary Automorphisms G°)</strong>:
A finite subgroup of automorphisms that fix the bulk but permute boundary sites. These represent different ways of connecting to the external world.</p>
<h3 id="gauge-invariance"><a class="header" href="#gauge-invariance">Gauge Invariance</a></h3>
<p><strong>Definition 2.7 (Gauge Equivalence)</strong>:
Two configurations s,s’ are gauge-equivalent (s ≡ᵍ s’) if there exists a symmetry g such that s’ = g(s).</p>
<p><strong>Theorem 2.1 (Gauge Invariance of Physics)</strong>:
Conservation laws and receipts are invariant under gauge transformations.</p>
<p><em>Proof</em>: By construction:</p>
<ul>
<li>R96: Multiset of residues unchanged by permutation</li>
<li>C768: Rotation commutes with schedule</li>
<li>Φ: Designed to be gauge-covariant</li>
<li>Budget: Scalar quantity, unaffected by position</li>
</ul>
<p>This means gauge-equivalent configurations are physically indistinguishable. □</p>
<h3 id="quotient-by-gauge"><a class="header" href="#quotient-by-gauge">Quotient by Gauge</a></h3>
<p>The space of truly distinct configurations is:</p>
<pre><code>T_phys = T_configs / ≡ᵍ
</code></pre>
<p>This quotient space is much smaller than the raw configuration space, enabling efficient search and storage.</p>
<h3 id="cs-interpretation"><a class="header" href="#cs-interpretation">CS Interpretation</a></h3>
<p>Gauge symmetry appears throughout computer science:</p>
<ul>
<li><strong>Memory allocation</strong>: Address independence—a data structure works regardless of where it’s allocated</li>
<li><strong>Register allocation</strong>: The specific registers don’t matter, only the dataflow</li>
<li><strong>Hash tables</strong>: Collision resolution chains can be permuted without changing semantics</li>
<li><strong>Process scheduling</strong>: Different schedules that produce the same result</li>
</ul>
<p>The Hologram model makes these symmetries explicit and exploitable.</p>
<h2 id="the-universal-machine-interpretation"><a class="header" href="#the-universal-machine-interpretation">The Universal Machine Interpretation</a></h2>
<h3 id="fixed-vs-unbounded-memory"><a class="header" href="#fixed-vs-unbounded-memory">Fixed vs. Unbounded Memory</a></h3>
<p>Traditional models assume unbounded resources:</p>
<ul>
<li>Turing machines: Infinite tape</li>
<li>Lambda calculus: Unlimited term size</li>
<li>RAM machines: Arbitrary address space</li>
</ul>
<p>The Hologram model is deliberately finite. Why?</p>
<p><strong>Theorem 2.2 (Computational Universality)</strong>:
The 12,288 lattice with conservation laws can simulate any Turing machine for computations that halt within bounded space.</p>
<p><em>Proof sketch</em>:</p>
<ol>
<li>Encode TM tape segments as lattice regions</li>
<li>Use gauge freedom to “scroll” the tape</li>
<li>Implement state transitions as morphisms</li>
<li>Budget tracks space usage</li>
</ol>
<p>The finiteness isn’t a limitation—it’s a feature that enables perfect hashing, guaranteed termination, and resource accountability. □</p>
<h3 id="the-reuse-principle"><a class="header" href="#the-reuse-principle">The Reuse Principle</a></h3>
<p>With only 12,288 sites, how do we handle large computations? Through systematic reuse:</p>
<ol>
<li><strong>Temporal multiplexing</strong>: The C768 schedule rotation time-shares sites</li>
<li><strong>Spatial compression</strong>: The Φ operator packs/unpacks data</li>
<li><strong>Gauge freedom</strong>: Equivalent configurations share storage</li>
<li><strong>Content addressing</strong>: Deduplication is automatic</li>
</ol>
<h3 id="running-example-simulating-a-stack-machine"><a class="header" href="#running-example-simulating-a-stack-machine">Running Example: Simulating a Stack Machine</a></h3>
<p>Let’s implement a simple stack machine on T:</p>
<pre><code>Stack layout on T:
  Pages 0-15:   Stack storage (4096 bytes)
  Pages 16-31:  Code segment (4096 bytes)
  Pages 32-39:  Heap/working memory (2048 bytes)
  Pages 40-47:  I/O buffers (2048 bytes)

Stack operations:
  PUSH(x):
    1. Find stack pointer at (0,0)
    2. Write x at (sp_page, sp_byte)
    3. Increment sp with wraparound
    4. Update receipt

  POP():
    1. Decrement sp
    2. Read from (sp_page, sp_byte)
    3. Clear site (conservation!)
    4. Update receipt
</code></pre>
<p>The key insight: we’re not simulating external memory—we’re organizing the intrinsic lattice structure.</p>
<h2 id="visualizing-the-lattice"><a class="header" href="#visualizing-the-lattice">Visualizing the Lattice</a></h2>
<p>The 12,288 structure has natural visualizations:</p>
<h3 id="as-a-cylinder"><a class="header" href="#as-a-cylinder">As a Cylinder</a></h3>
<ul>
<li>48 rings (pages)</li>
<li>256 sites per ring (bytes)</li>
<li>Rotation σ spirals around</li>
</ul>
<h3 id="as-a-torus"><a class="header" href="#as-a-torus">As a Torus</a></h3>
<ul>
<li>Both dimensions wrap</li>
<li>No privileged origin</li>
<li>Geodesics are helices</li>
</ul>
<h3 id="as-a-matrix"><a class="header" href="#as-a-matrix">As a Matrix</a></h3>
<pre><code>     b=0  b=1  ...  b=255
p=0   □    □         □
p=1   □    □         □
...
p=47  □    □         □
</code></pre>
<p>Each visualization emphasizes different properties.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p><strong>Exercise 2.1</strong>: Prove that the automorphism group of T contains a subgroup isomorphic to T itself.</p>
<p><strong>Exercise 2.2</strong>: Calculate how many distinct gauge orbits exist for configurations with exactly 100 non-zero bytes.</p>
<p><strong>Exercise 2.3</strong>: Design an addressing scheme that maps 2D images efficiently onto T while preserving spatial locality.</p>
<p><strong>Exercise 2.4</strong>: Show that the schedule rotation σ visits every site exactly once per 768-step cycle.</p>
<p><strong>Exercise 2.5</strong>: Implement a ring buffer on T that maintains conservation laws during wraparound.</p>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<p>Here’s how to implement the lattice in code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug)]
struct Site {
    page: u8,    // 0..47
    byte: u8,    // 0..255
}

impl Site {
    fn linear_index(&amp;self) -&gt; u16 {
        (self.page as u16) * 256 + (self.byte as u16)
    }

    fn from_linear(index: u16) -&gt; Self {
        Site {
            page: (index / 256) as u8,
            byte: (index % 256) as u8,
        }
    }

    fn add(&amp;self, delta: Site) -&gt; Site {
        Site {
            page: (self.page + delta.page) % 48,
            byte: (self.byte + delta.byte) % 256,
        }
    }

    fn rotate_schedule(&amp;self) -&gt; Site {
        // Implement the order-768 rotation
        let p_rot = (self.page + 1) % 48;
        let b_rot = if self.page == 47 {
            (self.byte + 1) % 256
        } else {
            self.byte
        };
        Site { page: p_rot, byte: b_rot }
    }
}

struct Lattice {
    data: [u8; 12288],
}

impl Lattice {
    fn get(&amp;self, site: Site) -&gt; u8 {
        self.data[site.linear_index() as usize]
    }

    fn set(&amp;mut self, site: Site, value: u8) {
        self.data[site.linear_index() as usize] = value;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The implementation is straightforward because the structure is fundamental.</p>
<h2 id="takeaways"><a class="header" href="#takeaways">Takeaways</a></h2>
<ol>
<li><strong>T = ℤ/48 × ℤ/256 is the universal carrier</strong>: All computation happens here</li>
<li><strong>Toroidal topology eliminates boundaries</strong>: Every site is equal</li>
<li><strong>Gauge symmetry identifies equivalent states</strong>: Massive reduction in state space</li>
<li><strong>12,288 is carefully chosen</strong>: Rich factorization enables efficient operations</li>
<li><strong>Finite but universal</strong>: Boundedness enables perfect hashing and guaranteed termination</li>
</ol>
<p>The lattice isn’t just where computation happens—its structure determines what computations are possible and efficient.</p>
<hr />
<p><em>Next: Chapter 3 introduces the labeling system (R96, C768, Φ) that gives semantic meaning to lattice configurations.</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part-1/01-information-as-lawful-structure.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part-1/03-labels-schedules-receipts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part-1/01-information-as-lawful-structure.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part-1/03-labels-schedules-receipts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
