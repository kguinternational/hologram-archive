<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 4: Content-Addressable Memory - The Hologram (12,288): A Complete Computer Science Formalization</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A comprehensive computer science formalization of the 12,288 Hologram model of computation using mainstream CS formalisms">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title-page.html">Title Page</a></li><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="../readers-guide.html">Reader's Guide & Conventions</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part I: Mathematical Foundations</li><li class="chapter-item expanded "><a href="../part-1/01-information-as-lawful-structure.html"><strong aria-hidden="true">1.</strong> Chapter 1: Information as Lawful Structure</a></li><li class="chapter-item expanded "><a href="../part-1/02-universal-automaton.html"><strong aria-hidden="true">2.</strong> Chapter 2: The Universal Automaton</a></li><li class="chapter-item expanded "><a href="../part-1/03-labels-schedules-receipts.html"><strong aria-hidden="true">3.</strong> Chapter 3: Intrinsic Labels, Schedules, and Receipts</a></li><li class="chapter-item expanded "><a href="../part-1/04-content-addressable-memory.html" class="active"><strong aria-hidden="true">4.</strong> Chapter 4: Content-Addressable Memory</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part II: Algebraic Structure</li><li class="chapter-item expanded "><a href="../part-2/05-lawfulness-as-type-system.html"><strong aria-hidden="true">5.</strong> Chapter 5: Lawfulness as a Type System</a></li><li class="chapter-item expanded "><a href="../part-2/06-programs-as-geometry.html"><strong aria-hidden="true">6.</strong> Chapter 6: Programs as Geometry</a></li><li class="chapter-item expanded "><a href="../part-2/07-algorithmic-reification.html"><strong aria-hidden="true">7.</strong> Chapter 7: Algorithmic Reification</a></li><li class="chapter-item expanded "><a href="../part-2/08-universal-cost.html"><strong aria-hidden="true">8.</strong> Chapter 8: The Universal Cost</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part III: System Architecture</li><li class="chapter-item expanded "><a href="../part-3/09-security-safety-correctness.html"><strong aria-hidden="true">9.</strong> Chapter 9: Security, Safety, and Correctness</a></li><li class="chapter-item expanded "><a href="../part-3/10-worked-micro-examples.html"><strong aria-hidden="true">10.</strong> Chapter 10: Worked Micro-Examples</a></li><li class="chapter-item expanded "><a href="../part-3/11-interfaces-to-mainstream-cs.html"><strong aria-hidden="true">11.</strong> Chapter 11: Interfaces to Mainstream CS</a></li><li class="chapter-item expanded "><a href="../part-3/12-minimal-core.html"><strong aria-hidden="true">12.</strong> Chapter 12: Minimal Core</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part IV: Protocol Design</li><li class="chapter-item expanded "><a href="../part-4/13-meta-theory-expressivity.html"><strong aria-hidden="true">13.</strong> Chapter 13: Meta-Theory & Expressivity</a></li><li class="chapter-item expanded "><a href="../part-4/14-normalization-confluence.html"><strong aria-hidden="true">14.</strong> Chapter 14: Normalization & Confluence</a></li><li class="chapter-item expanded "><a href="../part-4/15-categorical-semantics.html"><strong aria-hidden="true">15.</strong> Chapter 15: Categorical Semantics</a></li><li class="chapter-item expanded "><a href="../part-4/16-security-proofs.html"><strong aria-hidden="true">16.</strong> Chapter 16: Security Proofs</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part V: Implementation</li><li class="chapter-item expanded "><a href="../part-5/17-optimization-landscape.html"><strong aria-hidden="true">17.</strong> Chapter 17: Optimization Landscape</a></li><li class="chapter-item expanded "><a href="../part-5/18-data-structure-implementation.html"><strong aria-hidden="true">18.</strong> Chapter 18: Data Structure Implementation</a></li><li class="chapter-item expanded "><a href="../part-5/19-runtime-architecture.html"><strong aria-hidden="true">19.</strong> Chapter 19: Runtime Architecture</a></li><li class="chapter-item expanded "><a href="../part-5/20-verification-system.html"><strong aria-hidden="true">20.</strong> Chapter 20: Verification System</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Part VI: Applications</li><li class="chapter-item expanded "><a href="../part-6/21-distributed-systems.html"><strong aria-hidden="true">21.</strong> Chapter 21: Distributed Systems</a></li><li class="chapter-item expanded "><a href="../part-6/22-database-systems.html"><strong aria-hidden="true">22.</strong> Chapter 22: Database Systems</a></li><li class="chapter-item expanded "><a href="../part-6/23-compiler-construction.html"><strong aria-hidden="true">23.</strong> Chapter 23: Compiler Construction</a></li><li class="chapter-item expanded "><a href="../part-6/24-machine-learning-integration.html"><strong aria-hidden="true">24.</strong> Chapter 24: Machine Learning Integration</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="../appendices/A-glossary.html"><strong aria-hidden="true">25.</strong> Appendix A: Glossary</a></li><li class="chapter-item expanded "><a href="../appendices/B-mathematical-notation.html"><strong aria-hidden="true">26.</strong> Appendix B: Mathematical Notation</a></li><li class="chapter-item expanded "><a href="../appendices/C-cs-mappings.html"><strong aria-hidden="true">27.</strong> Appendix C: Side-by-Side CS Mappings</a></li><li class="chapter-item expanded "><a href="../appendices/D-exercise-solutions.html"><strong aria-hidden="true">28.</strong> Appendix D: Exercise Solutions</a></li><li class="chapter-item expanded "><a href="../appendices/E-implementation-code.html"><strong aria-hidden="true">29.</strong> Appendix E: Implementation Code</a></li><li class="chapter-item expanded "><a href="../appendices/F-research-problems.html"><strong aria-hidden="true">30.</strong> Appendix F: Research Problems</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../bibliography.html">Bibliography</a></li><li class="chapter-item expanded affix "><a href="../index.html">Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hologram (12,288): A Complete Computer Science Formalization</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/uor-foundation/hologram-cs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-4-content-addressable-memory"><a class="header" href="#chapter-4-content-addressable-memory">Chapter 4: Content-Addressable Memory</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Traditional memory systems use arbitrary addresses—pointers that have no relationship to the data they reference. This creates fundamental problems: dangling pointers, buffer overflows, cache misses, and the entire machinery of memory management.</p>
<p>The Hologram model takes a radical approach: addresses ARE the content. More precisely, the address of an object is a mathematical function of its receipts and normal form. This gives us perfect hashing on the lawful domain—no collisions, no collision resolution, no load factors. Memory safety isn’t added through checks and bounds; it’s intrinsic to the addressing scheme.</p>
<h2 id="lawful-domain-of-addressability"><a class="header" href="#lawful-domain-of-addressability">Lawful Domain of Addressability</a></h2>
<h3 id="what-can-be-addressed"><a class="header" href="#what-can-be-addressed">What Can Be Addressed?</a></h3>
<p>Not everything deserves an address. In the Hologram model, only lawful objects can be addressed.</p>
<p><strong>Definition 4.1 (Lawful Object)</strong>:
An object ω is lawful if:</p>
<ol>
<li>Its R96 digest verifies</li>
<li>Its C768 metrics are fair</li>
<li>It passes Φ round-trip at budget 0</li>
<li>Its total budget is 0</li>
</ol>
<p><strong>Definition 4.2 (Domain of Addressability)</strong>:</p>
<pre><code>DOM = {ω ∈ Configurations | is_lawful(ω)}
</code></pre>
<p>This immediately eliminates malformed data, corrupted structures, and adversarial inputs—they literally cannot have addresses.</p>
<h3 id="the-unlawful-wilderness"><a class="header" href="#the-unlawful-wilderness">The Unlawful Wilderness</a></h3>
<p>What about unlawful objects? They exist mathematically but cannot be stored:</p>
<ul>
<li>No address → no storage location</li>
<li>No receipt → no verification</li>
<li>No normal form → no canonical representation</li>
</ul>
<p>They’re computational “dark matter”—theoretically present but practically inaccessible.</p>
<h2 id="canonicalization-via-gauge-fixing"><a class="header" href="#canonicalization-via-gauge-fixing">Canonicalization via Gauge Fixing</a></h2>
<h3 id="the-problem-of-equivalence"><a class="header" href="#the-problem-of-equivalence">The Problem of Equivalence</a></h3>
<p>Many distinct configurations represent the same semantic object:</p>
<pre><code class="language-python"># These are semantically identical:
list1 = [1,2,3] at sites (0,0), (0,1), (0,2)
list2 = [1,2,3] at sites (5,10), (5,11), (5,12)  # Translated
list3 = [1,2,3] at sites (0,0), (1,0), (2,0)      # Different layout
</code></pre>
<p>We need a canonical choice—a normal form.</p>
<h3 id="gauge-fixing-protocol"><a class="header" href="#gauge-fixing-protocol">Gauge Fixing Protocol</a></h3>
<p><strong>Algorithm 4.1 (Normalization)</strong>:</p>
<pre><code class="language-python">def normalize(object):
    # Step 1: Fix translation
    object = translate_to_origin(object)

    # Step 2: Fix schedule phase
    object = align_to_phase_zero(object)

    # Step 3: Fix boundary orientation
    object = canonical_boundary(object)

    # Step 4: Apply Φ lift for interior
    object.interior = lift_phi(object.boundary)

    return object
</code></pre>
<p><strong>Definition 4.3 (Normal Form)</strong>:
The normal form NF(ω) of object ω is the unique representative in its gauge equivalence class selected by the normalization protocol.</p>
<p><strong>Theorem 4.1 (Normal Form Uniqueness)</strong>:
For lawful object ω, NF(ω) is unique and computable in O(|ω|) time.</p>
<p><em>Proof</em>: Each gauge fixing step has a unique outcome:</p>
<ul>
<li>Translation: Leftmost-topmost non-empty site goes to (0,0)</li>
<li>Schedule: Align to phase 0 of C768 cycle</li>
<li>Boundary: Lexicographic ordering of boundary sites</li>
<li>Φ: Deterministic lift operation</li>
</ul>
<p>The composition of deterministic operations is deterministic. □</p>
<h3 id="canonical-coordinates"><a class="header" href="#canonical-coordinates">Canonical Coordinates</a></h3>
<p>Once normalized, objects have canonical coordinates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NormalForm {
    anchor: Site,           // Always (0,0) after normalization
    extent: (u8, u8),      // Bounding box dimensions
    phase: u16,            // Always 0 after normalization
    boundary: Vec&lt;u8&gt;,     // Canonical boundary ordering
    interior: Vec&lt;u8&gt;,     // Determined by lift_Φ(boundary)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="address-map-h"><a class="header" href="#address-map-h">Address Map H</a></h2>
<h3 id="the-perfect-hash-function"><a class="header" href="#the-perfect-hash-function">The Perfect Hash Function</a></h3>
<p><strong>Definition 4.4 (Address Map)</strong>:</p>
<pre><code>H: DOM → T
H(ω) = reduce(hash(NF(ω).receipt), T)
</code></pre>
<p>Breaking this down:</p>
<ol>
<li>Normalize ω to get NF(ω)</li>
<li>Extract the receipt of NF(ω)</li>
<li>Hash the receipt to get uniform distribution</li>
<li>Reduce modulo 12,288 to get a lattice site</li>
</ol>
<p><strong>Theorem 4.2 (Perfect Hashing on Lawful Domain)</strong>:
For lawful objects ω₁, ω₂ ∈ DOM:</p>
<pre><code>H(ω₁) = H(ω₂) ⟺ ω₁ ≡ᵍ ω₂
</code></pre>
<p>That is, addresses collide if and only if objects are gauge-equivalent (semantically identical).</p>
<p><em>Proof</em>:
(⟸) If ω₁ ≡ᵍ ω₂, then NF(ω₁) = NF(ω₂), so H(ω₁) = H(ω₂).</p>
<p>(⟹) If H(ω₁) = H(ω₂), then receipts match after normalization. By lawfulness and receipt completeness, ω₁ ≡ᵍ ω₂. □</p>
<h3 id="no-collision-resolution-needed"><a class="header" href="#no-collision-resolution-needed">No Collision Resolution Needed</a></h3>
<p>Traditional hash tables need collision resolution:</p>
<ul>
<li>Chaining (linked lists at each bucket)</li>
<li>Open addressing (probing for empty slots)</li>
<li>Cuckoo hashing (multiple hash functions)</li>
</ul>
<p>The Hologram model needs none of this. Collisions only occur for semantically identical objects, which should map to the same address anyway.</p>
<h3 id="load-factor-is-meaningless"><a class="header" href="#load-factor-is-meaningless">Load Factor Is Meaningless</a></h3>
<p>Traditional hash tables track load factor (items/buckets) and resize when it gets too high. In the Hologram model:</p>
<ul>
<li>No resize needed (T is fixed at 12,288)</li>
<li>No performance degradation with occupancy</li>
<li>Deduplication is automatic (identical objects share addresses)</li>
</ul>
<h2 id="content-addressed-storage-in-practice"><a class="header" href="#content-addressed-storage-in-practice">Content-Addressed Storage in Practice</a></h2>
<h3 id="writing-objects"><a class="header" href="#writing-objects">Writing Objects</a></h3>
<pre><code class="language-python">def store(object):
    # Verify lawfulness
    if not is_lawful(object):
        raise ValueError("Cannot store unlawful object")

    # Normalize
    normal_form = normalize(object)

    # Compute address
    address = H(normal_form)

    # Store at address
    lattice[address] = normal_form

    return address
</code></pre>
<h3 id="reading-objects"><a class="header" href="#reading-objects">Reading Objects</a></h3>
<pre><code class="language-python">def retrieve(address):
    # Direct lookup - O(1)
    normal_form = lattice[address]

    if normal_form is None:
        return None

    # Verify receipts (paranoid mode)
    if not verify_receipt(normal_form):
        raise IntegrityError("Corrupted object")

    return normal_form
</code></pre>
<h3 id="deduplication-example"><a class="header" href="#deduplication-example">Deduplication Example</a></h3>
<pre><code class="language-python"># Create two "different" strings
s1 = create_string("Hello", position=(0,0))
s2 = create_string("Hello", position=(10,20))

# Store both
addr1 = store(s1)  # Normalizes and stores
addr2 = store(s2)  # Normalizes to same form

assert addr1 == addr2  # Same address!
assert lattice[addr1] == NF("Hello")  # Single copy stored
</code></pre>
<h2 id="running-example-building-a-dictionary"><a class="header" href="#running-example-building-a-dictionary">Running Example: Building a Dictionary</a></h2>
<p>Let’s implement a key-value dictionary using content addressing:</p>
<pre><code class="language-python">class ContentDict:
    def __init__(self):
        self.lattice = Lattice()

    def put(self, key, value):
        # Create lawful pair object
        pair = create_pair(key, value)
        receipt = compute_receipt(pair)

        # Normalize and address
        normal = normalize(pair)
        address = H(normal)

        # Store
        self.lattice[address] = normal

        return address

    def get(self, key):
        # Create probe with key
        probe = create_probe(key)

        # Normalize probe
        normal_probe = normalize(probe)

        # Compute expected address
        address = H_partial(normal_probe)  # Hash of partial key

        # Retrieve and extract value
        stored = self.lattice[address]
        if stored and matches_key(stored, key):
            return extract_value(stored)
        return None

# Usage
d = ContentDict()
d.put("name", "Alice")
d.put("age", 30)

print(d.get("name"))  # "Alice"
print(d.get("age"))   # 30

# Duplicate puts are free
d.put("name", "Alice")  # No new storage used
</code></pre>
<h2 id="identity-and-equality"><a class="header" href="#identity-and-equality">Identity and Equality</a></h2>
<h3 id="content-determines-identity"><a class="header" href="#content-determines-identity">Content Determines Identity</a></h3>
<p>In traditional systems:</p>
<pre><code class="language-c">int* p1 = malloc(sizeof(int));
int* p2 = malloc(sizeof(int));
*p1 = 42;
*p2 = 42;
// p1 != p2 (different addresses despite same content)
</code></pre>
<p>In the Hologram model:</p>
<pre><code class="language-python">obj1 = create_int(42)
obj2 = create_int(42)
addr1 = H(obj1)
addr2 = H(obj2)
# addr1 == addr2 (same content → same address)
</code></pre>
<h3 id="equality-is-decidable"><a class="header" href="#equality-is-decidable">Equality Is Decidable</a></h3>
<p><strong>Algorithm 4.2 (Object Equality)</strong>:</p>
<pre><code class="language-python">def equal(obj1, obj2):
    # Lawfulness check
    if not (is_lawful(obj1) and is_lawful(obj2)):
        return False

    # Address comparison
    return H(obj1) == H(obj2)
</code></pre>
<p>This is O(n) in object size, not O(n²) deep comparison.</p>
<h2 id="distributed-cam"><a class="header" href="#distributed-cam">Distributed CAM</a></h2>
<p>Content addressing naturally extends to distributed systems:</p>
<h3 id="global-address-space"><a class="header" href="#global-address-space">Global Address Space</a></h3>
<p>Every node in a distributed system sees the same address for the same content:</p>
<pre><code class="language-python"># Node A
obj = create_object(data)
addr = H(obj)  # 0x7A3F

# Node B (independent)
obj2 = create_object(same_data)
addr2 = H(obj2)  # 0x7A3F (same!)
</code></pre>
<h3 id="automatic-deduplication"><a class="header" href="#automatic-deduplication">Automatic Deduplication</a></h3>
<p>When nodes exchange objects:</p>
<pre><code class="language-python">def receive_object(obj, sender):
    addr = H(obj)

    if lattice[addr] is not None:
        # Already have it, ignore duplicate
        return addr

    # New object, store it
    lattice[addr] = normalize(obj)
    return addr
</code></pre>
<h3 id="content-based-routing"><a class="header" href="#content-based-routing">Content-Based Routing</a></h3>
<p>Route requests based on content, not location:</p>
<pre><code class="language-python">def route_request(content_hash):
    # Determine which node owns this content
    responsible_node = content_hash % num_nodes

    if responsible_node == self.node_id:
        return handle_locally(content_hash)
    else:
        return forward_to(responsible_node, content_hash)
</code></pre>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p><strong>Exercise 4.1</strong>: Prove that normalization is idempotent: NF(NF(ω)) = NF(ω).</p>
<p><strong>Exercise 4.2</strong>: Calculate the probability of address collision for unlawful (random) data. Why is it much higher than for lawful data?</p>
<p><strong>Exercise 4.3</strong>: Design a version control system using content addressing. How do you handle commits and branches?</p>
<p><strong>Exercise 4.4</strong>: Implement a B-tree where node addresses are content-determined. What happens during rebalancing?</p>
<p><strong>Exercise 4.5</strong>: Show that content addressing makes certain attacks impossible. Which attacks remain possible?</p>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<p>Here’s production code for the address map:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sha3::{Sha3_256, Digest};

pub struct AddressMap {
    hasher: Sha3_256,
}

impl AddressMap {
    pub fn address_of(&amp;mut self, object: &amp;LawfulObject) -&gt; Site {
        // Normalize
        let normal_form = object.normalize();

        // Extract receipt
        let receipt = normal_form.receipt();

        // Hash receipt
        self.hasher.reset();
        self.hasher.update(receipt.as_bytes());
        let hash = self.hasher.finalize();

        // Reduce to lattice site
        let index = u16::from_le_bytes([hash[0], hash[1]]) % 12288;
        Site::from_linear(index)
    }
}

pub struct ContentStore {
    lattice: Lattice,
    address_map: AddressMap,
}

impl ContentStore {
    pub fn put(&amp;mut self, object: LawfulObject) -&gt; Result&lt;Site, StoreError&gt; {
        // Compute address
        let addr = self.address_map.address_of(&amp;object);

        // Check for existing object
        if let Some(existing) = self.lattice.get(addr) {
            if !existing.equivalent_to(&amp;object) {
                // This should be impossible for lawful objects
                return Err(StoreError::ImpossibleCollision);
            }
            // Deduplicated
            return Ok(addr);
        }

        // Store new object
        self.lattice.set(addr, object.normalize());
        Ok(addr)
    }

    pub fn get(&amp;self, addr: Site) -&gt; Option&lt;&amp;LawfulObject&gt; {
        self.lattice.get(addr)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="takeaways"><a class="header" href="#takeaways">Takeaways</a></h2>
<ol>
<li><strong>Addresses are content</strong>: H(object) determined by receipts and normal form</li>
<li><strong>Perfect hashing on lawful domain</strong>: No collisions between distinct lawful objects</li>
<li><strong>Normalization ensures uniqueness</strong>: Each equivalence class has one representative</li>
<li><strong>Deduplication is automatic</strong>: Identical content → same address</li>
<li><strong>Memory safety is intrinsic</strong>: No pointers, no dangling references</li>
<li><strong>Distributed systems benefit</strong>: Global content addressing across nodes</li>
</ol>
<p>Content-addressable memory isn’t just an optimization—it’s a fundamental restructuring of how we think about storage and identity.</p>
<hr />
<p><em>This completes Part I. Next, Part II explores how these foundations support a complete type system and programming model.</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part-1/03-labels-schedules-receipts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part-2/05-lawfulness-as-type-system.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part-1/03-labels-schedules-receipts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part-2/05-lawfulness-as-type-system.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
