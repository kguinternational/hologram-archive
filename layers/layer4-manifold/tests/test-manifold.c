/*
 * Atlas Manifold Layer 4 - C Integration Tests
 * 
 * Tests basic manifold operations via FFI to ensure C interoperability
 * and verify that the Rust implementation works correctly from C code.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include <stdint.h>
#include <time.h>

// Include the generated C headers (these would be generated by cbindgen)
// For now, we'll define the essential structures and function prototypes

#ifdef __cplusplus
extern "C" {
#endif

// C-compatible structures
typedef struct {
    double *coords;
    size_t dim;
} CAtlasPoint;

typedef struct {
    double *elements;
    size_t rows;
    size_t cols;
} CAtlasMatrix;

typedef struct {
    void *inner;
} AtlasManifoldHandle;

// Function prototypes
const char* atlas_manifold_version(void);
int atlas_manifold_init(void);
int atlas_manifold_cleanup(void);

AtlasManifoldHandle* atlas_manifold_create(uint32_t intrinsic_dim, uint32_t embedding_dim);
int atlas_manifold_destroy(AtlasManifoldHandle* handle);

int atlas_manifold_transform_point(
    const AtlasManifoldHandle* handle,
    const CAtlasPoint* input,
    CAtlasPoint* output
);

int atlas_manifold_linear_transform(
    const CAtlasMatrix* matrix,
    const CAtlasPoint* input,
    CAtlasPoint* output
);

int atlas_manifold_curvature(
    const AtlasManifoldHandle* handle,
    const CAtlasPoint* point,
    double* curvature
);

int atlas_manifold_serialize(
    const AtlasManifoldHandle* handle,
    uint8_t* buffer,
    size_t buffer_size,
    size_t* bytes_written
);

int atlas_manifold_deserialize(
    const uint8_t* buffer,
    size_t buffer_size,
    AtlasManifoldHandle** handle
);

#ifdef __cplusplus
}
#endif

// Test utility functions
void test_assert(int condition, const char* message) {
    if (!condition) {
        fprintf(stderr, "TEST FAILED: %s\n", message);
        exit(1);
    }
    printf("✓ %s\n", message);
}

CAtlasPoint* create_point(double* coords, size_t dim) {
    CAtlasPoint* point = malloc(sizeof(CAtlasPoint));
    point->coords = malloc(dim * sizeof(double));
    memcpy(point->coords, coords, dim * sizeof(double));
    point->dim = dim;
    return point;
}

void destroy_point(CAtlasPoint* point) {
    if (point) {
        free(point->coords);
        free(point);
    }
}

CAtlasMatrix* create_matrix(double* elements, size_t rows, size_t cols) {
    CAtlasMatrix* matrix = malloc(sizeof(CAtlasMatrix));
    matrix->elements = malloc(rows * cols * sizeof(double));
    memcpy(matrix->elements, elements, rows * cols * sizeof(double));
    matrix->rows = rows;
    matrix->cols = cols;
    return matrix;
}

void destroy_matrix(CAtlasMatrix* matrix) {
    if (matrix) {
        free(matrix->elements);
        free(matrix);
    }
}

void print_test_header(const char* test_name) {
    printf("\n--- %s ---\n", test_name);
}

// Test functions
void test_library_initialization(void) {
    print_test_header("Library Initialization Test");
    
    // Test version function
    const char* version = atlas_manifold_version();
    test_assert(version != NULL, "Version string is not null");
    printf("Library version: %s\n", version);
    
    // Test initialization
    int init_result = atlas_manifold_init();
    test_assert(init_result == 0, "Library initialization successful");
    
    // Test multiple initializations are safe
    init_result = atlas_manifold_init();
    test_assert(init_result == 0, "Multiple initializations are safe");
    
    // Test cleanup
    int cleanup_result = atlas_manifold_cleanup();
    test_assert(cleanup_result == 0, "Library cleanup successful");
    
    // Test cleanup is idempotent
    cleanup_result = atlas_manifold_cleanup();
    test_assert(cleanup_result == 0, "Multiple cleanups are safe");
}

void test_manifold_handle_creation(void) {
    print_test_header("Manifold Handle Creation Test");
    
    // Initialize library first
    atlas_manifold_init();
    
    // Test basic handle creation - currently returns null as it's not implemented
    AtlasManifoldHandle* handle = atlas_manifold_create(2, 3);
    // Note: Current implementation returns null, so we test for that
    test_assert(handle == NULL, "Handle creation returns null (not yet implemented)");
    
    // Test destruction with null handle
    int destroy_result = atlas_manifold_destroy(NULL);
    test_assert(destroy_result != 0, "Destroying null handle returns error");
    
    atlas_manifold_cleanup();
}

void test_point_operations(void) {
    print_test_header("Point Operations Test");
    
    atlas_manifold_init();
    
    // Create test points
    double coords1[] = {1.0, 2.0, 3.0};
    double coords2[] = {4.0, 5.0, 6.0};
    
    CAtlasPoint* point1 = create_point(coords1, 3);
    CAtlasPoint* point2 = create_point(coords2, 3);
    CAtlasPoint* output = create_point(coords2, 3); // Reuse coords2 for output buffer
    
    test_assert(point1->dim == 3, "Point 1 has correct dimension");
    test_assert(point2->dim == 3, "Point 2 has correct dimension");
    test_assert(point1->coords[0] == 1.0, "Point 1 x-coordinate is correct");
    test_assert(point2->coords[1] == 5.0, "Point 2 y-coordinate is correct");
    
    // Test transformation with null handle (should fail)
    int transform_result = atlas_manifold_transform_point(NULL, point1, output);
    test_assert(transform_result != 0, "Transform with null handle fails");
    
    // Test with null input point
    transform_result = atlas_manifold_transform_point(NULL, NULL, output);
    test_assert(transform_result != 0, "Transform with null input fails");
    
    // Test with null output point
    transform_result = atlas_manifold_transform_point(NULL, point1, NULL);
    test_assert(transform_result != 0, "Transform with null output fails");
    
    destroy_point(point1);
    destroy_point(point2);
    destroy_point(output);
    
    atlas_manifold_cleanup();
}

void test_linear_transformations(void) {
    print_test_header("Linear Transformations Test");
    
    atlas_manifold_init();
    
    // Create a 2x2 identity matrix
    double identity_elements[] = {
        1.0, 0.0,
        0.0, 1.0
    };
    CAtlasMatrix* identity = create_matrix(identity_elements, 2, 2);
    
    // Create test point
    double coords[] = {3.0, 4.0};
    CAtlasPoint* input = create_point(coords, 2);
    CAtlasPoint* output = create_point(coords, 2); // Reuse for output
    
    // Test linear transformation with null matrix (should fail)
    int result = atlas_manifold_linear_transform(NULL, input, output);
    test_assert(result != 0, "Linear transform with null matrix fails");
    
    // Test with null input
    result = atlas_manifold_linear_transform(identity, NULL, output);
    test_assert(result != 0, "Linear transform with null input fails");
    
    // Test with null output
    result = atlas_manifold_linear_transform(identity, input, NULL);
    test_assert(result != 0, "Linear transform with null output fails");
    
    // Test with valid parameters (currently returns 0 but doesn't do anything)
    result = atlas_manifold_linear_transform(identity, input, output);
    test_assert(result == 0, "Linear transform with valid parameters succeeds");
    
    destroy_matrix(identity);
    destroy_point(input);
    destroy_point(output);
    
    atlas_manifold_cleanup();
}

void test_curvature_computation(void) {
    print_test_header("Curvature Computation Test");
    
    atlas_manifold_init();
    
    // Create test point
    double coords[] = {1.0, 1.0};
    CAtlasPoint* point = create_point(coords, 2);
    double curvature = 0.0;
    
    // Test curvature computation with null handle (should fail)
    int result = atlas_manifold_curvature(NULL, point, &curvature);
    test_assert(result != 0, "Curvature with null handle fails");
    
    // Test with null point
    result = atlas_manifold_curvature(NULL, NULL, &curvature);
    test_assert(result != 0, "Curvature with null point fails");
    
    // Test with null curvature output
    result = atlas_manifold_curvature(NULL, point, NULL);
    test_assert(result != 0, "Curvature with null output fails");
    
    destroy_point(point);
    
    atlas_manifold_cleanup();
}

void test_serialization(void) {
    print_test_header("Serialization Test");
    
    atlas_manifold_init();
    
    uint8_t buffer[1024];
    size_t bytes_written = 0;
    
    // Test serialization with null handle (should fail)
    int result = atlas_manifold_serialize(NULL, buffer, sizeof(buffer), &bytes_written);
    test_assert(result != 0, "Serialization with null handle fails");
    
    // Test with null buffer
    result = atlas_manifold_serialize(NULL, NULL, sizeof(buffer), &bytes_written);
    test_assert(result != 0, "Serialization with null buffer fails");
    
    // Test with null bytes_written
    result = atlas_manifold_serialize(NULL, buffer, sizeof(buffer), NULL);
    test_assert(result != 0, "Serialization with null bytes_written fails");
    
    // Test deserialization with null buffer
    AtlasManifoldHandle* handle = NULL;
    result = atlas_manifold_deserialize(NULL, 0, &handle);
    test_assert(result != 0, "Deserialization with null buffer fails");
    
    // Test deserialization with null handle output
    result = atlas_manifold_deserialize(buffer, sizeof(buffer), NULL);
    test_assert(result != 0, "Deserialization with null handle output fails");
    
    atlas_manifold_cleanup();
}

void test_error_conditions(void) {
    print_test_header("Error Conditions Test");
    
    // Test functions without initialization
    AtlasManifoldHandle* handle = atlas_manifold_create(2, 3);
    test_assert(handle == NULL, "Creation without init returns null");
    
    // Initialize and test edge cases
    atlas_manifold_init();
    
    // Test creation with invalid dimensions
    handle = atlas_manifold_create(0, 3);
    test_assert(handle == NULL, "Creation with zero intrinsic dimension fails");
    
    handle = atlas_manifold_create(2, 0);
    test_assert(handle == NULL, "Creation with zero embedding dimension fails");
    
    // Test very large dimensions
    handle = atlas_manifold_create(UINT32_MAX, 3);
    test_assert(handle == NULL, "Creation with very large dimension fails");
    
    atlas_manifold_cleanup();
}

void test_memory_safety(void) {
    print_test_header("Memory Safety Test");
    
    atlas_manifold_init();
    
    // Test multiple allocations and deallocations
    for (int i = 0; i < 100; i++) {
        double coords[] = {(double)i, (double)(i + 1), (double)(i + 2)};
        CAtlasPoint* point = create_point(coords, 3);
        
        // Verify point data
        test_assert(point->coords[0] == (double)i, "Point allocation correct");
        
        destroy_point(point);
    }
    
    // Test matrix allocations
    for (int i = 0; i < 50; i++) {
        double elements[9] = {1, 0, 0, 0, 1, 0, 0, 0, 1}; // 3x3 identity
        CAtlasMatrix* matrix = create_matrix(elements, 3, 3);
        
        test_assert(matrix->rows == 3, "Matrix rows correct");
        test_assert(matrix->cols == 3, "Matrix cols correct");
        
        destroy_matrix(matrix);
    }
    
    atlas_manifold_cleanup();
}

void run_performance_tests(void) {
    print_test_header("Performance Tests");
    
    atlas_manifold_init();
    
    const int NUM_OPERATIONS = 10000;
    
    printf("Running %d point operations...\n", NUM_OPERATIONS);
    
    // Create reusable points for performance testing
    double coords1[] = {1.0, 2.0, 3.0};
    double coords2[] = {4.0, 5.0, 6.0};
    CAtlasPoint* point1 = create_point(coords1, 3);
    CAtlasPoint* point2 = create_point(coords2, 3);
    
    // Time point operations
    clock_t start = clock();
    for (int i = 0; i < NUM_OPERATIONS; i++) {
        // Just test the error path since actual implementation isn't complete
        atlas_manifold_transform_point(NULL, point1, point2);
    }
    clock_t end = clock();
    
    double time_spent = ((double)(end - start)) / CLOCKS_PER_SEC;
    printf("Completed %d operations in %.4f seconds\n", NUM_OPERATIONS, time_spent);
    printf("Average time per operation: %.6f seconds\n", time_spent / NUM_OPERATIONS);
    
    destroy_point(point1);
    destroy_point(point2);
    
    atlas_manifold_cleanup();
}

int main(void) {
    printf("=== Atlas Manifold Layer 4 - C Integration Tests ===\n");
    
    // Run all tests
    test_library_initialization();
    test_manifold_handle_creation();
    test_point_operations();
    test_linear_transformations();
    test_curvature_computation();
    test_serialization();
    test_error_conditions();
    test_memory_safety();
    run_performance_tests();
    
    printf("\n=== All Tests Completed Successfully ===\n");
    printf("✓ Library initialization and cleanup\n");
    printf("✓ Manifold handle management\n");
    printf("✓ Point operations and transformations\n");
    printf("✓ Linear algebra operations\n");
    printf("✓ Curvature computations\n");
    printf("✓ Serialization/deserialization\n");
    printf("✓ Error condition handling\n");
    printf("✓ Memory safety verification\n");
    printf("✓ Basic performance characteristics\n");
    
    printf("\nNote: This test suite validates the FFI interface and error handling.\n");
    printf("Full implementation testing will require completed Rust backend.\n");
    
    return 0;
}